/* Tangled output generated by inweb-C: do not edit */
#include <ctype.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#define TRUE 1
#define FALSE 0
#define UNKNOWN 2
#define INWEB_BUILD "inweb 6/110818 ('The Zarbi')"
#define SEP_CHAR '/' /* local file-system filename separator */
#define MAX_STRING_LENGTH 4096
#define MEMORY_MANAGEMENT \
    	int allocation_id; /* Numbered from 0 upwards in creation order */\
    	void *next_structure; /* Next object in double-linked list */\
    	void *prev_structure; /* Previous object in double-linked list */
#define bibliographic_datum_MT 0
#define chapter_MT 1
#define section_MT 2
#define tangle_target_MT 3
#define source_line_array_MT 4
#define web_MT 5
#define paragraph_MT 6
#define cweb_macro_MT 7
#define programming_language_MT 8
#define c_structure_MT 9
#define structure_dependence_MT 10
#define function_MT 11
#define preform_nonterminal_MT 12
#define string_storage_area_MT 13
#define nonterminal_variable_MT 14
#define weave_target_MT 15
#define macro_usage_MT 16
#define weave_format_MT 17
#define hash_table_entry_MT 18
#define hash_table_entry_usage_MT 19
#define structure_element_MT 20
#define structure_permission_MT 21
#define theme_tag_MT 22
#define paragraph_tag_MT 23
#define tex_results_MT 24
#define NO_MEMORY_TYPES 25 /* must be 1 more than the highest |_MT| constant above */
#define SAFETY_MARGIN 64
#define BLANK_END_SIZE 128
#define MAX_BLOCKS_ALLOWED 15000
#define MEMORY_GRANULARITY 100*1024*4 /* which must be divisible by 1024 */
#define INTEGRITY_NUMBER 0x12345678 /* a value unlikely to be in memory just by chance */
#define CREATE(type_name) (allocate_##type_name())
#define CREATE_BEFORE(existing, type_name) (allocate_##type_name##_before(existing))
#define DESTROY(this, type_name) (deallocate_##type_name(this))
#define FIRST_OBJECT(type_name) ((type_name *) alloc_status[type_name##_MT].first_in_memory)
#define LAST_OBJECT(type_name) ((type_name *) alloc_status[type_name##_MT].last_in_memory)
#define NEXT_OBJECT(this, type_name) ((type_name *) (this->next_structure))
#define PREV_OBJECT(this, type_name) ((type_name *) (this->prev_structure))
#define NUMBER_CREATED(type_name) (alloc_status[type_name##_MT].objects_count)
#define LOOP_OVER(var, type_name)\
    	for (var=FIRST_OBJECT(type_name); var != NULL; var = NEXT_OBJECT(var, type_name))
#define LOOP_BACKWARDS_OVER(var, type_name)\
    	for (var=LAST_OBJECT(type_name); var != NULL; var = PREV_OBJECT(var, type_name))
#define NEW_OBJECT(type_name) ((type_name *) allocate_mem(type_name##_MT, sizeof(type_name)))
#define ALLOCATE_INDIVIDUALLY(type_name) \
    type_name *allocate_##type_name(void) {\
    	alloc_status[type_name##_MT].name_of_type = #type_name;\
    	type_name *prev_obj = LAST_OBJECT(type_name);\
    	type_name *new_obj = NEW_OBJECT(type_name);\
    	new_obj->allocation_id = alloc_status[type_name##_MT].objects_allocated-1;\
    	new_obj->next_structure = NULL;\
    	if (prev_obj != NULL)\
    		prev_obj->next_structure = (void *) new_obj;\
    	new_obj->prev_structure = prev_obj;\
    	alloc_status[type_name##_MT].objects_count++;\
    	return new_obj;\
    }\
    void deallocate_##type_name(type_name *kill_me) {\
    	type_name *prev_obj = PREV_OBJECT(kill_me, type_name);\
    	type_name *next_obj = NEXT_OBJECT(kill_me, type_name);\
    	if (prev_obj == NULL) {\
    		alloc_status[type_name##_MT].first_in_memory = next_obj;\
    	} else {\
    		prev_obj->next_structure = next_obj;\
    	}\
    	if (next_obj == NULL) {\
    		alloc_status[type_name##_MT].last_in_memory = prev_obj;\
    	} else {\
    		next_obj->prev_structure = prev_obj;\
    	}\
    	alloc_status[type_name##_MT].objects_count--;\
    }\
    type_name *allocate_##type_name##_before(type_name *existing) {\
    	type_name *new_obj = allocate_##type_name();\
    	deallocate_##type_name(new_obj);\
    	new_obj->prev_structure = existing->prev_structure;\
    	if (existing->prev_structure != NULL)\
    		((type_name *) existing->prev_structure)->next_structure = new_obj;\
    	else alloc_status[type_name##_MT].first_in_memory = (void *) new_obj;\
    	new_obj->next_structure = existing;\
    	existing->prev_structure = new_obj;\
    	alloc_status[type_name##_MT].objects_count++;\
    	return new_obj;\
    }
#define ALLOCATE_IN_ARRAYS(type_name, NO_TO_ALLOCATE_TOGETHER)\
    typedef struct type_name##_array {\
    	int used;\
    	struct type_name array[NO_TO_ALLOCATE_TOGETHER];\
    	MEMORY_MANAGEMENT\
    } type_name##_array;\
    ALLOCATE_INDIVIDUALLY(type_name##_array)\
    type_name##_array *next_##type_name##_array = NULL;\
    struct type_name *allocate_##type_name(void) {\
    	if ((next_##type_name##_array == NULL) ||\
    		(next_##type_name##_array->used >= NO_TO_ALLOCATE_TOGETHER)) {\
    		alloc_status[type_name##_array_MT].no_allocated_together = NO_TO_ALLOCATE_TOGETHER;\
    		next_##type_name##_array = allocate_##type_name##_array();\
    		next_##type_name##_array->used = 0;\
    	}\
    	return &(next_##type_name##_array->array[\
    		next_##type_name##_array->used++]);\
    }
#define SSA_CAPACITY 64*1024
#define ANY_CLASS 1
#define DIGIT_CLASS 2
#define WHITESPACE_CLASS 3
#define NONWHITESPACE_CLASS 4
#define IDENTIFIER_CLASS 5
#define PREFORM_CLASS 6
#define PREFORMC_CLASS 7
#define LITERAL_CLASS 8
#define NO_MODE 0 /* a special mode for doing nothing except printing command-line syntax */
#define ANALYSE_MODE 1
#define TANGLE_MODE 2
#define WEAVE_MODE 3
#define CREATE_MODE 4 /* a special mode for creating a new web, not acting on an existing one */
#define SWARM_OFF 0
#define SWARM_INDEX 1 /* make index(es) as if swarming, but don't actually swarm */
#define SWARM_CHAPTERS 2 /* swarm the chapters */
#define SWARM_SECTIONS 3 /* that, and also all of the individual sections */
#define LOOP_OVER_BIBLIOGRAPHIC_DATA(bd, W)\
    	for (bd = W->first_bd; bd; bd = bd->next_bd)
#define NO_LCAT 0                 /* none set as yet */
#define CHAPTER_HEADING_LCAT 1    /* chapter heading line inserted automatically, not read from web */
#define SECTION_HEADING_LCAT 2    /* section heading line, at top of file */
#define PURPOSE_LCAT 3            /* first line of |@Purpose:| declaration; TO is rest of line */
#define INTERFACE_LCAT 4          /* line holding the |@Interface:| heading */
#define INTERFACE_BODY_LCAT 5     /* line within the interface, under this heading */
#define DEFINITIONS_LCAT 6        /* line holding the |@Definitions:| heading */
#define BAR_LCAT 7                /* a bar line |@---------------|... */
#define PB_PARAGRAPH_START_LCAT 8 /* |@p| or |@pp| paragraph start: TO is title, TO2 is rest of line */
#define PARAGRAPH_START_LCAT 9    /* simple |@| paragraph start: TO is blank, TO2 is rest of line */
#define COMMENT_BODY_LCAT 10      /* text following a paragraph header, which is all comment */
#define SOURCE_DISPLAY_LCAT 11    /* commentary line beginning |>>| for display: TO is display text */
#define MACRO_DEFINITION_LCAT 12  /* line on which a CWEB macro is defined with an |=| sign */
#define BEGIN_VERBATIM_LCAT 13    /* an |@c|, |@e| or |@x| line below which is code, early code or extract */
#define CODE_BODY_LCAT 14         /* the rest of the paragraph under an |@c| or |@e| or macro definition */
#define TEXT_EXTRACT_LCAT 15      /* the rest of the paragraph under an |@x| */
#define TOGGLE_WEAVING_LCAT 16    /* a line telling the weaver to toggle code weaving on or off */
#define BEGIN_DEFINITION_LCAT 17  /* an |@d| definition: TO is term, TO2 is this line's part of defn */
#define CONT_DEFINITION_LCAT 18   /* subsequent lines of an |@d| definition */
#define COMMAND_LCAT 19           /* a |[[Command]]| line, with the operand set to the |*_CMD| value */
#define C_LIBRARY_INCLUDE_LCAT 20 /* C-like languages only: a |#include| for an ANSI C header file */
#define TYPEDEF_LCAT 21           /* C-like languages only: a |typedef| which isn't a structure definition */
#define PREFORM_LCAT 22           /* C-for-Inform only: opening line of a Preform nonterminal */
#define PREFORM_GRAMMAR_LCAT 23   /* C-for-Inform only: line of Preform grammar */
#define PURPOSE_BODY_LCAT 24      /* continuation lines of |@Purpose:| declaration */
#define NO_CMD 0
#define PAGEBREAK_CMD 1
#define GRAMMAR_INDEX_CMD 2
#define FIGURE_CMD 3
#define TAG_CMD 4
#define LOOP_WITHIN_TANGLE(T) \
    	for (chapter *C = W->first_chapter; C; C = C->next_chapter)\
    		for (section *S = C->first_section; S; S = S->next_section)\
    			if (S->sect_target == T)\
    				for (source_line *L = S->first_line; L; L = L->next_line)
#define ORDINARY_WEIGHT 0 /* an ordinary |@| paragraph */
#define SUBHEADING_WEIGHT 1 /* an |@p| or |@pp| paragraph */
#define ELEMENT_ACCESS_USAGE 0x00000001 /* C-like languages: access via |->| or |.| operators to structure element */
#define FCALL_USAGE 0x00000002 /* C-like languages: function call made using brackets, |name(args)| */
#define PREFORM_IN_CODE_USAGE 0x00000004 /* C-for-Inform only: use of a Preform nonterminal as a C "constant" */
#define PREFORM_IN_GRAMMAR_USAGE 0x00000008 /* C-for-Inform only: ditto, but within Preform production rather than C code */
#define MISC_USAGE 0x00000010 /* any other appearance as an identifier */
#define ANY_USAGE 0xffffffff /* any of the above */
#define HASH_TAB_SIZE 1000 /* the possible hash codes are 0 up to this minus 1 */
#define NUMBER_HASH 0 /* literal decimal integers, and no other words, have this hash code */
#define TRACE_CI_EXECUTION FALSE /* set true for debugging */
#define MAX_TEMPLATE_LINES 256 /* maximum number of lines in template */
#define CI_STACK_CAPACITY 8 /* maximum recursion of chapter/section iteration */
#define CHAPTER_LEVEL 1
#define SECTION_LEVEL 2
#define REGULAR_MATERIAL 1
#define MACRO_MATERIAL 2       /* when a macro is being defined... */
#define DEFINITION_MATERIAL 3  /* ...versus when an |@d| definition is being made */
#define CODE_MATERIAL 4
#define WEAVE_FIRST_HALF 1
#define WEAVE_SECOND_HALF 2
#define IN_SECOND_HALF 4
#define SHOW_INTERFACES FALSE
#define LOOP_OVER_PARAGRAPHS(T) \
    	for (chapter *C = W->first_chapter; C; C = C->next_chapter)\
    		for (section *S = C->first_section; S; S = S->next_section)\
    			if (S->sect_target == T)\
    				for (paragraph *P = S->first_paragraph; P; P = P->next_paragraph_in_section)
#define MAX_ARG_LINES 8 /* maximum number of lines over which a function's header can extend */
#define INFINITE_WORD_COUNT 1000000000
#define NOT_A_NONTERMINAL -4
#define A_FLEXIBLE_NONTERMINAL -3
#define A_VORACIOUS_NONTERMINAL -2
#define A_GRAMMAR_NONTERMINAL -1
#define MACRO_CODE 1
#define FUNCTION_CODE 2
#define RESERVED_CODE 3
#define ELEMENT_CODE 4
#define IDENTIFIER_CODE 5
#define CHAR_LITERAL_CODE 6
#define CONSTANT_CODE 7
#define STRING_CODE 8
#define PLAIN_CODE 9
#define HTML_OUT 0
#define HTML_IN_P 1
#define HTML_IN_PRE 2
#define HTML_IN_ITEM 3
typedef char string[MAX_STRING_LENGTH+1];
#line 72 "inwebc/Chapter 1/Memory.w"
typedef struct allocation_status_structure {

	/* actually needed for allocation purposes: */
	int objects_allocated; /* total number of objects (or arrays) ever allocated */
	void *first_in_memory; /* head of doubly linked list */
	void *last_in_memory; /* tail of doubly linked list */

	/* used only to provide statistics for the debugging log: */
	char *name_of_type; /* e.g., |"lexicon_entry_MT"| */
	int bytes_allocated; /* total allocation for this type of object, not counting overhead */
	int objects_count; /* total number currently in existence (i.e., undeleted) */
	int no_allocated_together; /* number of objects in each array of this type of object */
} allocation_status_structure;
#line 155 "inwebc/Chapter 1/Memory.w"
typedef struct memblock_header {
	int block_number;
	struct memblock_header *next;
	char *the_memory;
} memblock_header;
#line 239 "inwebc/Chapter 1/Memory.w"
typedef struct memory_frame {
	int integrity_check; /* this should always contain the |INTEGRITY_NUMBER| */
	struct memory_frame *next_frame; /* next frame in the list of memory frames */
	int mem_type; /* type of object stored in this frame */
	int allocation_id; /* allocation ID number of object stored in this frame */
} memory_frame;
#line 520 "inwebc/Chapter 1/Memory.w"
typedef struct string_storage_area {
	char *storage_at;
	int first_free_byte;
	MEMORY_MANAGEMENT
} string_storage_area;
#line 10 "inwebc/Chapter 1/Text Files.w"
typedef struct text_file_position {
	char *text_file_filename;
	int line_count;
	int line_position;
	int skip_terminator;
	int actively_scanning; /* whether we are still interested in the rest of the file */
} text_file_position;
#line 97 "inwebc/Chapter 1/Pattern Matching.w"
typedef struct match_position {
	int tpos; /* position within text being matched */
	int ppos; /* position within pattern */
	int bc; /* count of bracketed subexpressions so far begun */
	int bl; /* bracket indentation level */
	int bracket_nesting[4]; /* which subexpression numbers (0, 1, 2, 3) correspond to which nesting */
	int brackets_start[4], brackets_end[4]; /* positions in text being matched, inclusive */
} match_position;
#line 11 "inwebc/Chapter 2/Command Line Arguments.w"
typedef struct inweb_instructions {
	int inweb_mode; /* our main mode of operation: one of the |*_MODE| constants */
	string chosen_web; /* project folder relative to cwd */
	string chosen_subweb; /* which subset of this web we apply to (often, all of it) */

	int swarm_mode; /* relevant to weaving only: one of the |*_SWARM| constants */
	string theme_setting; /* |-theme X|: theme for a topic-restricted weave */
	string weave_format; /* |-format X|: for example, |-format TeX| */

	int catalogue_switch; /* |-catalogue|: print catalogue of sections */
	int functions_switch; /* |-functions|: print catalogue of functions within sections */
	int open_pdf_switch; /* |-open-pdf|: open any woven PDF in the OS once it is made */
	int scan_switch; /* |-scan|: simply show the syntactic scan of the source */
	string tangle_setting; /* |-tangle X|: the pathname X, if supplied */
	int verbose_switch; /* |-verbose|: print names of files read to stdout */

	string location_setting; /* |-at X|: where this program is */
} inweb_instructions;
#line 11 "inwebc/Chapter 3/Bibliographic Data.w"
typedef struct bibliographic_datum {
	string key;
	string value;
	int declaration_permitted; /* is the contents page of the web allowed to set this? */
	int declaration_mandatory; /* is it positively required to? */
	int on_or_off; /* boolean: which we handle as the string "On" or "Off" */
	struct bibliographic_datum *alias;
	struct bibliographic_datum *next_bd; /* within the linked list for a web */
	MEMORY_MANAGEMENT
} bibliographic_datum;
#line 16 "inwebc/Chapter 3/Line Categories.w"
typedef struct source_line {
	char *text; /* the text as read in */
	char *text_operand; /* meaning depends on category */
	char *text_operand2; /* meaning depends on category */

	int category; /* what sort of line this is: an |*_LCAT| value */
	int command_code; /* used only for |COMMAND_LCAT| lines: a |*_CMD| value */
	int is_commentary; /* flag */
	struct function *function_defined; /* if any C-like function is defined on this line */
	struct preform_nonterminal *preform_nonterminal_defined; /* similarly */
	int suppress_tangling; /* if e.g., lines are tangled out of order */
	int interface_line_identified; /* only relevant during parsing of Interface lines */

	struct text_file_position source; /* which file this was read in from, if any */

	struct section *owning_section; /* for interleaved title lines, it's the one about to start */
	struct source_line *next_line; /* within the owning section's linked list */
	struct paragraph *owning_paragraph; /* for lines falling under paragraphs; |NULL| if not */
} source_line;
#line 24 "inwebc/Chapter 3/Reading Sections.w"
typedef struct web {
	string path_to_web; /* relative to the current working directory */

	/* convenient statistics */
	int no_lines; /* total lines in literate source, excluding contents */
	int no_paragraphs; /* this will be at least 1 */
	int no_sections; /* again, excluding contents: it will eventually be at least 1 */
	int no_chapters; /* this will be at least 1 */
	int chaptered; /* has the author explicitly divided it into named chapters? */
	int analysed; /* has this been scanned for function usage and such? */

	struct bibliographic_datum *first_bd; /* key-value pairs for title, author and such */
	struct programming_language *main_language; /* in which most of the sections are written */

	struct chapter *first_chapter; /* two ends of a linked list */
	struct chapter *last_chapter;

	struct c_structure *first_c_structure; /* two ends of a linked list, used only for C */
	struct c_structure *last_c_structure;

	struct tangle_target *first_target; /* linked list of tangle targets */

	MEMORY_MANAGEMENT
} web;
#line 83 "inwebc/Chapter 3/Reading Sections.w"
typedef struct chapter {
	string ch_sigil; /* e.g., |P| for Preliminaries, |7| for Chapter 7, |C| for Appendix C */
	string ch_title; /* e.g., "Chapter 3: Fresh Water Fish" */
	string rubric; /* optional; without double-quotation marks */

	string woven_pdf_leafname; /* a leafname for a standalone weave of this chapter */
	struct tangle_target *ch_target; /* |NULL| unless this chapter produces a tangle of its own */
	struct weave_target *ch_weave; /* |NULL| unless this chapter produces a weave of its own */
	struct programming_language *ch_language; /* in which most of the sections are written */

	int titling_line_inserted; /* has an interleaved chapter heading been added yet? */

	int ch_extent; /* total number of lines in the sections of this chapter */
	struct section *first_section; /* two ends of a linked list */
	struct section *last_section;

	struct web *owning_web;
	struct chapter *next_chapter; /* within the owning web's linked list */
	MEMORY_MANAGEMENT
} chapter;
#line 107 "inwebc/Chapter 3/Reading Sections.w"
typedef struct section {
	string sigil; /* e.g., "9/tfto" */
	string sect_title; /* e.g., "Program Control" */
	string sect_namespace; /* e.g., "Text::Languages::" */
	string sect_purpose; /* e.g., "To manage the zoo, and feed all penguins" */
	int barred; /* contains a dividing bar? */

	string pathname_relative_to_web;
	string leafname;

	struct tangle_target *sect_target; /* |NULL| unless this section produces a tangle of its own */
	struct weave_target *sect_weave; /* |NULL| unless this section produces a weave of its own */
	struct programming_language *sect_language; /* in which this section is written */

	int sect_extent; /* total number of lines in this section */
	struct source_line *first_line; /* two ends of a linked list */
	struct source_line *last_line;

	int sect_paragraphs; /* total number of paragraphs in this section */
	struct paragraph *first_paragraph; /* two ends of a linked list */
	struct paragraph *last_paragraph;
	struct theme_tag *tag_with; /* automatically tag paras in this section thus */

	struct cweb_macro *first_macro; /* two ends of a linked list */
	struct cweb_macro *last_macro;

	struct chapter *owning_chapter;
	struct section *next_section; /* within the owning chapter's linked list */

	int scratch_flag; /* temporary workspace */
	int erroneous_interface; /* problem with Interface declarations */
	MEMORY_MANAGEMENT
} section;
#line 155 "inwebc/Chapter 3/Reading Sections.w"
typedef struct reader_state {
	struct web *current_web;
	int in_biblio;
	int in_purpose; /* Reading the bit just after the new chapter? */
	struct chapter *chapter_being_scanned;
	string path_to_chapter_being_read; /* Where sections in the current chapter live */
	string titling_line_to_insert; /* To be inserted automagically */
	int scan_verbosely;
} reader_state;
#line 187 "inwebc/Chapter 4/The Analyser.w"
typedef struct hash_table {
	struct hash_table_entry *analysis_hash[HASH_TAB_SIZE]; /* linked list of identifiers sharing this hash code */
	int analysis_hash_initialised; /* when we start up, array's contents are undefined */
} hash_table;
#line 591 "inwebc/Chapter 3/Reading Sections.w"
typedef struct tangle_target {
	struct programming_language *tangle_language; /* common to the entire contents */
	struct hash_table symbols; /* a table of identifiable names in this program */
	struct tangle_target *next_target; /* within the web's linked list */
	MEMORY_MANAGEMENT
} tangle_target;
#line 128 "inwebc/Chapter 3/The Parser.w"
typedef struct cweb_macro {
	string macro_name;
	struct paragraph *defining_paragraph; /* as printed in small type after the name in any usage */
	struct source_line *defn_start; /* it ends at the end of its defining paragraph */
	struct cweb_macro *next_macro; /* within the owning section's linked list */
	struct macro_usage *macro_usages; /* only computed for weaves, since unnecessary for tangles */
	MEMORY_MANAGEMENT
} cweb_macro;
#line 318 "inwebc/Chapter 3/The Parser.w"
typedef struct paragraph {
	int above_bar; /* placed above the dividing bar in its section */
	int placed_early; /* should appear early in the tangled code */
	char *ornament; /* a "P" for a pilcrow or "S" for section-marker */
	string paragraph_number; /* used in combination with the ornament */
	int next_child_number; /* used when working out paragraph numbers */
	struct paragraph *parent_paragraph; /* ditto */
	int starts_on_new_page; /* relevant for weaving to |TeX| only, of course */
	int weight; /* typographic prominence: one of the |*_WEIGHT| values */
	struct cweb_macro *defines_macro; /* there can only be one */
	struct function *first_defined_in_paragraph; /* there can be several */
	struct c_structure *first_c_structure_in_para; /* similarly */
	struct c_structure *last_c_structure_in_para; /* similarly */
	struct paragraph_tag *tags; /* a linked list */

	struct source_line *first_line_in_paragraph; /* a linked list */

	struct section *under_section;
	struct paragraph *next_paragraph_in_section; /* within the owning section's linked list */
	MEMORY_MANAGEMENT
} paragraph;
#line 416 "inwebc/Chapter 3/The Parser.w"
typedef struct theme_tag {
	string tag_name;
	string title_when_woven;
	string leafname_when_woven;
	string cover_sheet_when_woven;
	MEMORY_MANAGEMENT
} theme_tag;
#line 440 "inwebc/Chapter 3/The Parser.w"
typedef struct paragraph_tag {
	struct theme_tag *the_tag;
	struct paragraph_tag *next_tag;
	string caption;
	MEMORY_MANAGEMENT
} paragraph_tag;
#line 51 "inwebc/Chapter 3/Paragraph Numbering.w"
typedef struct macro_usage {
	struct paragraph *used_in_paragraph;
	int multiplicity; /* for example, 2 if it's used twice in this paragraph */
	struct macro_usage *next_macro_usage; /* within the list of uses of the macro */
	MEMORY_MANAGEMENT
} macro_usage;
#line 195 "inwebc/Chapter 4/The Analyser.w"
typedef struct hash_table_entry {
	char *hash_key;
	struct hash_table_entry *next_in_hash; /* i.e., in list of identifiers sharing this hash code */
	int reserved_word; /* in the language currently being woven, that is */
	struct hash_table_entry_usage *first_usage; /* a linked list of all known usages */
	struct hash_table_entry_usage *last_usage;
	MEMORY_MANAGEMENT
} hash_table_entry;
#line 255 "inwebc/Chapter 4/The Analyser.w"
typedef struct hash_table_entry_usage {
	struct paragraph *usage_recorded_at;
	int form_of_usage; /* bitmap of the |*_USAGE| constants defined above */
	struct hash_table_entry_usage *next_usage; /* i.e., in the list of usages of this identifier */
	MEMORY_MANAGEMENT
} hash_table_entry_usage;
#line 67 "inwebc/Chapter 4/The Swarm.w"
typedef struct weave_target {
	struct web *weave_web; /* which web we weave */
	string weave_sigil; /* which parts of the web in this weave */
	struct theme_tag *theme_match; /* pick out only paragraphs with this theme */
	string booklet_title;
	string weave_to; /* where to put it */
	struct weave_format *format; /* plain text, say, or HTML */
	string cover_sheet_to_use; /* leafname of the copy, or |""| for no cover */
	void *post_processing_results; /* optional typesetting diagnostics after running through */
	MEMORY_MANAGEMENT
} weave_target;
#line 232 "inwebc/Chapter 4/The Swarm.w"
typedef struct contents_processor {
	char *tlines[MAX_TEMPLATE_LINES];
	int no_tlines;
	int repeat_stack_level[CI_STACK_CAPACITY];
	void *repeat_stack_variable[CI_STACK_CAPACITY];
	void *repeat_stack_threshold[CI_STACK_CAPACITY];
	int repeat_stack_startpos[CI_STACK_CAPACITY];
	int stack_pointer;
	char *restrict_to_subweb;
} contents_processor;
#line 62 "inwebc/Chapter 4/The Weaver.w"
typedef struct weaver_state {
	int kind_of_material; /* one of the defined |*_MATERIAL| constants above */
	int line_break_pending;
	int weaving_suspended; /* because of ...and so on... markers? */
	int next_heading_without_vertical_skip;
	int show_section_toc_soon; /* is a table of contents for the section imminent? */
	int horizontal_rule_just_drawn;
	struct section *last_extract_from;
	struct paragraph *last_endnoted_para;
	int substantive_comment;
	string chaptermark;
	string sectionmark;
} weaver_state;
#line 25 "inwebc/Chapter 5/Programming Languages.w"
typedef struct programming_language {
	char *language_name;
	char *file_extension; /* by default output to a file whose name has this extension */
	char *source_file_extension; /* by default input from a file whose name has this extension */
	char *shebang; /* compulsory content on line 1 */
	int c_like; /* does this belong to the C family of languages? */
	MEMORY_MANAGEMENT
} programming_language;
#line 28 "inwebc/Chapter 5/C-Like Languages.w"
typedef struct c_structure {
	string structure_name;
	int tangled; /* whether the structure definition has been tangled out */
	struct source_line *typedef_begins; /* opening line of |typedef| */
	struct source_line *typedef_ends; /* closing line, where |}| appears */
	struct section *declared_owner;
	int declared_private;
	struct structure_dependence *first_dependence; /* double-ended linked list */
	struct structure_dependence *last_dependence;
	struct structure_element *first_element; /* double-ended linked list */
	struct structure_element *last_element;
	struct structure_permission *first_permission; /* double-ended linked list */
	struct structure_permission *last_permission;
	struct c_structure *next_c_structure; /* in the linked list for its web */
	struct c_structure *next_c_structure_in_para; /* and for its paragraph */
	struct c_structure *next_cst_alphabetically;
	MEMORY_MANAGEMENT
} c_structure;
#line 52 "inwebc/Chapter 5/C-Like Languages.w"
typedef struct structure_element {
	string element_name;
	struct structure_element *next_element;
	struct source_line *element_created_at;
	int allow_sharing;
	MEMORY_MANAGEMENT
} structure_element;
#line 63 "inwebc/Chapter 5/C-Like Languages.w"
typedef struct structure_permission {
	struct section *shared_with;
	struct source_line *granted_at;
	struct structure_permission *next_permission;
	MEMORY_MANAGEMENT
} structure_permission;
#line 75 "inwebc/Chapter 5/C-Like Languages.w"
typedef struct structure_dependence {
	struct c_structure *incorporates; /* the structure being embedded */
	struct structure_dependence *next_dependence; /* in the linked list for its structure */
	MEMORY_MANAGEMENT
} structure_dependence;
#line 89 "inwebc/Chapter 5/C-Like Languages.w"
typedef struct function {
	string function_name; /* e.g., |"cultivate"| */
	string function_type; /* e.g., |"tree *"| */
	string function_arguments; /* e.g., |"int rainfall)"|: note |)| */
	struct source_line *function_header_at; /* where the first line of the header begins */
	struct function *next_defined_in_paragraph;
	int within_namespace; /* written using C-for-Inform namespace dividers */
	int called_from_other_sections;
	int call_freely;
	MEMORY_MANAGEMENT
} function;
#line 47 "inwebc/Chapter 5/C for Inform.w"
typedef struct preform_nonterminal {
	string nt_name; /* e.g., |"<action-clause>"| */
	string unangled_name; /* e.g., |"action-clause"| */
	string as_C_identifier; /* e.g., |"action_clause_NTM"| */
	int as_function; /* defined internally, that is, parsed by a C function */
	int voracious; /* a voracious nonterminal: see {\it The English Syntax of Inform} */
	int min_word_count; /* for internals only */
	int max_word_count;
	int takes_pointer_result; /* right-hand formula defines |*XP|, not |*X| */
	struct source_line *where_defined;
	struct preform_nonterminal *next_pnt_alphabetically;
	MEMORY_MANAGEMENT
} preform_nonterminal;
#line 61 "inwebc/Chapter 5/C for Inform.w"
typedef struct nonterminal_variable {
	string ntv_name; /* e.g., |"num"| */
	string ntv_type; /* e.g., |"int"| */
	string ntv_identifier; /* e.g., |"num_NTMV"| */
	struct source_line *first_mention; /* first usage */
	MEMORY_MANAGEMENT
} nonterminal_variable;
#line 32 "inwebc/Chapter 6/Weave Formats.w"
typedef struct weave_format {
	char *format_name;
	char *woven_extension;
	struct weave_format *intermediate;
	MEMORY_MANAGEMENT
} weave_format;
#line 22 "inwebc/Chapter 6/Running Through TeX.w"
typedef struct tex_results {
	int overfull_hbox_count;
	int tex_error_count;
	int page_count;
	int pdf_size;
	string PDF_filename;
	MEMORY_MANAGEMENT
} tex_results;
#line 66 "inwebc/Chapter 1/Basics.w"
int  check_len(int n) ;
#line 75 "inwebc/Chapter 1/Basics.w"
int  in_strlen(char *str) ;
#line 85 "inwebc/Chapter 1/Basics.w"
void  in_set(char *str, int i, int to) ;
#line 94 "inwebc/Chapter 1/Basics.w"
void  in_truncate(char *str, int len) ;
#line 103 "inwebc/Chapter 1/Basics.w"
void  in_strcpy(char *to, char *from) ;
#line 113 "inwebc/Chapter 1/Basics.w"
void  in_strcat(char *to, char *from) ;
#line 139 "inwebc/Chapter 1/Basics.w"
int  in_string_eq(char *A, char *B) ;
#line 143 "inwebc/Chapter 1/Basics.w"
int  in_string_ne(char *A, char *B) ;
#line 150 "inwebc/Chapter 1/Basics.w"
int  in_string_cmp(char *A, char *B) ;
#line 162 "inwebc/Chapter 1/Basics.w"
int  in_string_eq_insensitive(char *A, char *B) ;
#line 178 "inwebc/Chapter 1/Basics.w"
void  issue_os_command_0(char *command) ;
#line 182 "inwebc/Chapter 1/Basics.w"
void  issue_os_command_1(char *command, char *fn1) ;
#line 188 "inwebc/Chapter 1/Basics.w"
void  issue_os_command_2(char *command, char *fn1, char *fn2) ;
#line 93 "inwebc/Chapter 1/Memory.w"
void  start_memory(void) ;
#line 173 "inwebc/Chapter 1/Memory.w"
void  allocate_another_block(void) ;
#line 218 "inwebc/Chapter 1/Memory.w"
void  free_memory(void) ;
#line 263 "inwebc/Chapter 1/Memory.w"
void  check_memory_integrity(void) ;
#line 274 "inwebc/Chapter 1/Memory.w"
void  debug_memory_frames(int from, int to) ;
#line 291 "inwebc/Chapter 1/Memory.w"
void * allocate_mem(int mem_type, int extent) ;
#line 533 "inwebc/Chapter 1/Memory.w"
char * new_string(char *from) ;
#line 550 "inwebc/Chapter 1/Memory.w"
void  free_ssas(void) ;
#line 21 "inwebc/Chapter 1/Text Files.w"
text_file_position  nowhere_position(void) ;
#line 36 "inwebc/Chapter 1/Text Files.w"
int  file_read(char *filename, char *message, int serious, 	void (iterator)(char *, text_file_position *, void *), text_file_position *start_at, 	void *state) ;
#line 10 "inwebc/Chapter 1/Pattern Matching.w"
int  white_space(int c) ;
#line 20 "inwebc/Chapter 1/Pattern Matching.w"
int  identifier_char(int c) ;
#line 35 "inwebc/Chapter 1/Pattern Matching.w"
int  find_expansion(char *original, char on1, char on2, char off1, char off2, int *len) ;
#line 50 "inwebc/Chapter 1/Pattern Matching.w"
int  find_open_brace(char *p) ;
#line 61 "inwebc/Chapter 1/Pattern Matching.w"
int  string_is_white_space(char *p) ;
#line 109 "inwebc/Chapter 1/Pattern Matching.w"
int  pattern_match(char *text, char *pattern) ;
#line 113 "inwebc/Chapter 1/Pattern Matching.w"
int  pattern_match_r(char *text, char *pattern, match_position *scan_from) ;
#line 254 "inwebc/Chapter 1/Pattern Matching.w"
int  get_cclass(char *pattern, int ppos, int *len, int *from, int *to, int *reverse) ;
#line 283 "inwebc/Chapter 1/Pattern Matching.w"
int  test_cclass(char *text, int chcl, int range_from, int range_to, char *drawn_from, int reverse) ;
#line 59 "inwebc/Chapter 2/Program Control.w"
int  main(int argc, char **argv) ;
#line 91 "inwebc/Chapter 2/Program Control.w"
void  follow_instructions(inweb_instructions *ins) ;
#line 33 "inwebc/Chapter 2/Command Line Arguments.w"
inweb_instructions  read_instructions_from_command_line(int argc, char **argv) ;
#line 191 "inwebc/Chapter 2/Command Line Arguments.w"
void  enter_main_mode(inweb_instructions *args, int new_mode) ;
#line 203 "inwebc/Chapter 2/Command Line Arguments.w"
void  read_configuration_file(void) ;
#line 215 "inwebc/Chapter 2/Command Line Arguments.w"
void  scan_config_line(char *line, text_file_position *tfp, void *unused_state) ;
#line 11 "inwebc/Chapter 2/Error Messages.w"
void  fatal_error(char *message) ;
#line 15 "inwebc/Chapter 2/Error Messages.w"
void  fatal_error_with_parameter(char *message, char *parameter) ;
#line 27 "inwebc/Chapter 2/Error Messages.w"
void  error_in_web(char *message, source_line *sl) ;
#line 36 "inwebc/Chapter 2/Error Messages.w"
void  error_in_text_file(char *message, text_file_position *here) ;
#line 43 "inwebc/Chapter 2/Error Messages.w"
void  error_at_position(char *message, char *file, int line) ;
#line 53 "inwebc/Chapter 2/Error Messages.w"
void  fatal_filing_system_error(char *erm, char *fn) ;
#line 59 "inwebc/Chapter 2/Error Messages.w"
void  nonfatal_filing_system_error(char *erm, char *fn) ;
#line 30 "inwebc/Chapter 3/Bibliographic Data.w"
int  bibliographic_datum_can_be_declared(web *W, char *key) ;
#line 36 "inwebc/Chapter 3/Bibliographic Data.w"
int  bibliographic_datum_on_or_off(web *W, char *key) ;
#line 46 "inwebc/Chapter 3/Bibliographic Data.w"
void  initialise_bibliographic_data(web *W) ;
#line 74 "inwebc/Chapter 3/Bibliographic Data.w"
void  check_required_bibliographic_data(web *W) ;
#line 87 "inwebc/Chapter 3/Bibliographic Data.w"
char * get_bibliographic_data(web *W, char *key) ;
#line 93 "inwebc/Chapter 3/Bibliographic Data.w"
int  bibliographic_data_exists(web *W, char *key) ;
#line 99 "inwebc/Chapter 3/Bibliographic Data.w"
bibliographic_datum * look_up_bibliographic_datum(web *W, char *key) ;
#line 114 "inwebc/Chapter 3/Bibliographic Data.w"
bibliographic_datum * set_bibliographic_data(web *W, char *key, char *val) ;
#line 39 "inwebc/Chapter 3/Line Categories.w"
source_line * new_source_line(char *line, text_file_position *tfp) ;
#line 96 "inwebc/Chapter 3/Line Categories.w"
char * category_name(int cat) ;
#line 52 "inwebc/Chapter 3/Reading Sections.w"
web * load_web(char *path, int verbosely) ;
#line 72 "inwebc/Chapter 3/Reading Sections.w"
void  print_web_statistics(web *W) ;
#line 168 "inwebc/Chapter 3/Reading Sections.w"
void  read_contents_page(web *W, int verbosely) ;
#line 193 "inwebc/Chapter 3/Reading Sections.w"
void  scan_biblio_line(char *line, text_file_position *tfp, void *X) ;
#line 451 "inwebc/Chapter 3/Reading Sections.w"
void  read_file(web *W, char *path_relative_to_web, char *titling_line, section *sect, 	int verbosely) ;
#line 476 "inwebc/Chapter 3/Reading Sections.w"
void  scan_source_line(char *line, text_file_position *tfp, void *state) ;
#line 508 "inwebc/Chapter 3/Reading Sections.w"
void  scan_line_categories(web *W, char *sigil) ;
#line 538 "inwebc/Chapter 3/Reading Sections.w"
chapter * get_chapter_for_sigil(web *W, char *sigil) ;
#line 546 "inwebc/Chapter 3/Reading Sections.w"
section * get_section_for_sigil(web *W, char *sigil) ;
#line 555 "inwebc/Chapter 3/Reading Sections.w"
section * section_by_filename(web *W, char *filename) ;
#line 570 "inwebc/Chapter 3/Reading Sections.w"
int  sigil_within(char *sig1, char *sig2) ;
#line 601 "inwebc/Chapter 3/Reading Sections.w"
tangle_target * add_tangle_target(web *W, programming_language *language) ;
#line 9 "inwebc/Chapter 3/The Parser.w"
void  parse_literate_source(web *W) ;
#line 402 "inwebc/Chapter 3/The Parser.w"
cweb_macro * get_cweb_macro_by_name(char *name, section *scope) ;
#line 427 "inwebc/Chapter 3/The Parser.w"
theme_tag * tag_by_name(char *p) ;
#line 455 "inwebc/Chapter 3/The Parser.w"
theme_tag * declare_tag_from_contents(web *W, char *name, char *title, char *leaf, char *cover) ;
#line 467 "inwebc/Chapter 3/The Parser.w"
theme_tag * add_tag_by_name(source_line *L, char *p) ;
#line 492 "inwebc/Chapter 3/The Parser.w"
void  add_tag_to_para(paragraph *P, theme_tag *tag, char *caption) ;
#line 505 "inwebc/Chapter 3/The Parser.w"
int  is_tagged_with(source_line *L, theme_tag *tag) ;
#line 16 "inwebc/Chapter 3/Paragraph Numbering.w"
void  number_web(web *W) ;
#line 134 "inwebc/Chapter 3/Paragraph Numbering.w"
void  settle_paragraph_number(paragraph *P) ;
#line 13 "inwebc/Chapter 4/The Analyser.w"
void  catalogue_the_sections(web *W, char *sigil, int functions_too) ;
#line 51 "inwebc/Chapter 4/The Analyser.w"
void  analyse_code(web *W) ;
#line 126 "inwebc/Chapter 4/The Analyser.w"
void  analyse_as_code(web *W, source_line *L, char *text, int mask, int transf) ;
#line 168 "inwebc/Chapter 4/The Analyser.w"
int  hash_code_from_word(char *text) ;
#line 210 "inwebc/Chapter 4/The Analyser.w"
hash_table_entry * find_hash_entry(section *S, char *text, int create) ;
#line 236 "inwebc/Chapter 4/The Analyser.w"
void  mark_reserved_word(section *S, char *p, int e) ;
#line 241 "inwebc/Chapter 4/The Analyser.w"
int  is_reserved_word(section *S, char *p, int e) ;
#line 265 "inwebc/Chapter 4/The Analyser.w"
void  analyse_find(web *W, source_line *L, char *identifier, int u) ;
#line 21 "inwebc/Chapter 4/The Swarm.w"
void  weave_swarm(web *W, char *subweb, int swarm_mode, theme_tag *tag, char *format) ;
#line 51 "inwebc/Chapter 4/The Swarm.w"
weave_target * weave_subset_of_web(web *W, char *subweb, int open_afterwards, theme_tag *tag, char *format) ;
#line 142 "inwebc/Chapter 4/The Swarm.w"
void  weave_index_templates(web *W, char *subweb, char *format) ;
#line 204 "inwebc/Chapter 4/The Swarm.w"
void  copy_files_into_weave(web *W, char *copy_list) ;
#line 248 "inwebc/Chapter 4/The Swarm.w"
void  run_contents_interpreter(web *W, char *subset, 	char *path_to_template, char *contents_page_leafname) ;
#line 291 "inwebc/Chapter 4/The Swarm.w"
void  save_template_line(char *line, text_file_position *tfp, void *unused_state) ;
#line 422 "inwebc/Chapter 4/The Swarm.w"
void * heading_topmost_on_stack(int level) ;
#line 436 "inwebc/Chapter 4/The Swarm.w"
void  start_CI_loop(int level, void *from, void *to, int pos) ;
#line 445 "inwebc/Chapter 4/The Swarm.w"
void  end_CI_loop(void) ;
#line 16 "inwebc/Chapter 4/The Weaver.w"
int  weave_source(web *W, weave_target *wv) ;
#line 579 "inwebc/Chapter 4/The Weaver.w"
void  show_endnotes_on_previous_paragraph(FILE *F, weave_target *wv, paragraph *P) ;
#line 702 "inwebc/Chapter 4/The Weaver.w"
int  weave_table_of_contents(FILE *F, weave_target *wv, section *S) ;
#line 753 "inwebc/Chapter 4/The Weaver.w"
int  weave_cover_from(FILE *F, web *W, char *cs_filename, weave_target *wv, int halves) ;
#line 765 "inwebc/Chapter 4/The Weaver.w"
void  scan_cover_line(char *line, text_file_position *tfp, void *state) ;
#line 803 "inwebc/Chapter 4/The Weaver.w"
source_line * weave_interface_table_for_section(FILE *F, weave_target *wv, source_line *L) ;
#line 16 "inwebc/Chapter 4/The Tangler.w"
void  tangle_source(web *W, tangle_target *target, char *dest_file) ;
#line 86 "inwebc/Chapter 4/The Tangler.w"
void  tangle_paragraph(FILE *F, paragraph *P) ;
#line 119 "inwebc/Chapter 4/The Tangler.w"
void  tangle_code(FILE *F, char *original, section *S, source_line *L) ;
#line 53 "inwebc/Chapter 5/Programming Languages.w"
void  create_programming_languages(void) ;
#line 73 "inwebc/Chapter 5/Programming Languages.w"
programming_language * new_language(char *name, char *ext) ;
#line 84 "inwebc/Chapter 5/Programming Languages.w"
programming_language * language_with_name(char *lname) ;
#line 96 "inwebc/Chapter 5/Programming Languages.w"
int  language_special_data(FILE *F, programming_language *pl, char *data) ;
#line 107 "inwebc/Chapter 5/Programming Languages.w"
void  language_further_parsing(web *W, programming_language *pl) ;
#line 112 "inwebc/Chapter 5/Programming Languages.w"
void  language_subcategorise_code(programming_language *pl, source_line *L) ;
#line 120 "inwebc/Chapter 5/Programming Languages.w"
int  language_tangles(programming_language *pl) ;
#line 128 "inwebc/Chapter 5/Programming Languages.w"
void  language_shebang(FILE *F, programming_language *pl, web *W, tangle_target *target) ;
#line 143 "inwebc/Chapter 5/Programming Languages.w"
void  language_start_definition(FILE *F, programming_language *pl, 	char *term, char *start, section *S, source_line *L) ;
#line 154 "inwebc/Chapter 5/Programming Languages.w"
void  language_prolong_definition(FILE *F, programming_language *pl, 	char *more, section *S, source_line *L) ;
#line 162 "inwebc/Chapter 5/Programming Languages.w"
void  language_end_definition(FILE *F, programming_language *pl, 	section *S, source_line *L) ;
#line 172 "inwebc/Chapter 5/Programming Languages.w"
void  language_additional_predeclarations(FILE *F, programming_language *pl, web *W) ;
#line 183 "inwebc/Chapter 5/Programming Languages.w"
int  language_will_insert_in_tangle(programming_language *pl, source_line *L) ;
#line 188 "inwebc/Chapter 5/Programming Languages.w"
void  language_insert_in_tangle(FILE *F, programming_language *pl, source_line *L) ;
#line 200 "inwebc/Chapter 5/Programming Languages.w"
void  language_insert_line_marker(FILE *F, programming_language *pl, source_line *L) ;
#line 209 "inwebc/Chapter 5/Programming Languages.w"
void  language_before_macro_expansion(FILE *F, programming_language *pl, cweb_macro *cwm) ;
#line 213 "inwebc/Chapter 5/Programming Languages.w"
void  language_after_macro_expansion(FILE *F, programming_language *pl, cweb_macro *cwm) ;
#line 220 "inwebc/Chapter 5/Programming Languages.w"
void  language_comment(FILE *F, programming_language *pl, char *comm) ;
#line 230 "inwebc/Chapter 5/Programming Languages.w"
int  language_parse_comment(programming_language *pl, 	char *line, char *part_before_comment, char *part_within_comment) ;
#line 254 "inwebc/Chapter 5/Programming Languages.w"
void  language_tangle_code(FILE *F, programming_language *pl, char *original) ;
#line 262 "inwebc/Chapter 5/Programming Languages.w"
void  language_gnabehs(FILE *F, programming_language *pl, web *W) ;
#line 271 "inwebc/Chapter 5/Programming Languages.w"
void  language_additional_tangling(programming_language *pl, web *W, tangle_target *target) ;
#line 279 "inwebc/Chapter 5/Programming Languages.w"
void  language_begin_weave(section *S, weave_target *wv) ;
#line 287 "inwebc/Chapter 5/Programming Languages.w"
void  language_new_tag_declared(theme_tag *tag) ;
#line 291 "inwebc/Chapter 5/Programming Languages.w"
int  language_skip_in_weaving(programming_language *pl, weave_target *wv, source_line *L) ;
#line 296 "inwebc/Chapter 5/Programming Languages.w"
int  language_syntax_colour(programming_language *pl, FILE *WEAVEOUT, weave_target *wv, 	web *W, chapter *C, section *S, source_line *L, char *matter, char *colouring) ;
#line 309 "inwebc/Chapter 5/Programming Languages.w"
int  language_weave_code_line(programming_language *pl, FILE *WEAVEOUT, weave_target *wv, 	web *W, chapter *C, section *S, source_line *L, char *matter, char *concluding_comment) ;
#line 323 "inwebc/Chapter 5/Programming Languages.w"
void  language_analysis(programming_language *pl, section *S, int functions_too) ;
#line 327 "inwebc/Chapter 5/Programming Languages.w"
void  language_analyse_code(programming_language *pl, web *W) ;
#line 332 "inwebc/Chapter 5/Programming Languages.w"
void  language_post_analysis(programming_language *pl, web *W) ;
#line 108 "inwebc/Chapter 5/C-Like Languages.w"
void  c_like_further_parsing(web *W) ;
#line 216 "inwebc/Chapter 5/C-Like Languages.w"
c_structure * find_c_structure(web *W, char *name) ;
#line 223 "inwebc/Chapter 5/C-Like Languages.w"
function * get_function_with_name(char *name) ;
#line 234 "inwebc/Chapter 5/C-Like Languages.w"
c_structure * attach_c_structure(web *W, char *name, source_line *L) ;
#line 383 "inwebc/Chapter 5/C-Like Languages.w"
void  c_like_subcategorise_code(programming_language *pl, source_line *L) ;
#line 407 "inwebc/Chapter 5/C-Like Languages.w"
void  c_like_shebang(FILE *F, programming_language *pl, web *W, tangle_target *target) ;
#line 419 "inwebc/Chapter 5/C-Like Languages.w"
void  c_like_additional_predeclarations(FILE *F, programming_language *pl, web *W) ;
#line 463 "inwebc/Chapter 5/C-Like Languages.w"
void  tangle_structure(FILE *F, programming_language *pl, c_structure *str) ;
#line 485 "inwebc/Chapter 5/C-Like Languages.w"
void  c_like_insert_line_marker(FILE *F, programming_language *pl, source_line *L) ;
#line 494 "inwebc/Chapter 5/C-Like Languages.w"
void  c_like_comment(FILE *F, programming_language *pl, char *comm) ;
#line 501 "inwebc/Chapter 5/C-Like Languages.w"
int  c_like_parse_comment(programming_language *pl, 	char *line, char *part_before_comment, char *part_within_comment) ;
#line 529 "inwebc/Chapter 5/C-Like Languages.w"
void  c_like_before_macro_expansion(FILE *F, programming_language *pl, cweb_macro *cwm) ;
#line 533 "inwebc/Chapter 5/C-Like Languages.w"
void  c_like_after_macro_expansion(FILE *F, programming_language *pl, cweb_macro *cwm) ;
#line 541 "inwebc/Chapter 5/C-Like Languages.w"
void  c_like_begin_weave(section *S, weave_target *wv) ;
#line 582 "inwebc/Chapter 5/C-Like Languages.w"
int  c_like_syntax_colour(programming_language *pl, FILE *WEAVEOUT, weave_target *wv, 	web *W, chapter *C, section *S, source_line *L, char *matter, char *colouring) ;
#line 637 "inwebc/Chapter 5/C-Like Languages.w"
void  c_like_colour_ident(section *S, char *matter, char *colouring, int from, int to) ;
#line 657 "inwebc/Chapter 5/C-Like Languages.w"
int  c_like_weave_code_line(programming_language *pl, FILE *WEAVEOUT, weave_target *wv, 	web *W, chapter *C, section *S, source_line *L, char *matter, char *concluding_comment) ;
#line 665 "inwebc/Chapter 5/C-Like Languages.w"
void  c_like_analysis(programming_language *pl, section *S, int functions_too) ;
#line 678 "inwebc/Chapter 5/C-Like Languages.w"
void  c_like_analyse_code(programming_language *pl, web *W) ;
#line 734 "inwebc/Chapter 5/C-Like Languages.w"
void  c_like_post_analysis(programming_language *pl, web *W) ;
#line 812 "inwebc/Chapter 5/C-Like Languages.w"
int  section_subset(c_structure *str, int report) ;
#line 84 "inwebc/Chapter 5/C for Inform.w"
int  c_for_inform_special_data(FILE *F, char *data) ;
#line 101 "inwebc/Chapter 5/C for Inform.w"
void  c_for_inform_further_parsing(web *W) ;
#line 283 "inwebc/Chapter 5/C for Inform.w"
void  c_for_inform_additional_predeclarations(FILE *F, web *W) ;
#line 304 "inwebc/Chapter 5/C for Inform.w"
void  c_for_inform_gnabehs(FILE *F, web *W) ;
#line 332 "inwebc/Chapter 5/C for Inform.w"
int  c_for_inform_will_insert_in_tangle(source_line *L) ;
#line 354 "inwebc/Chapter 5/C for Inform.w"
void  c_for_inform_insert_in_tangle(FILE *F, source_line *L) ;
#line 492 "inwebc/Chapter 5/C for Inform.w"
void  c_for_inform_tangle_code(FILE *F, char *original) ;
#line 595 "inwebc/Chapter 5/C for Inform.w"
preform_nonterminal * nonterminal_by_name(char *name) ;
#line 609 "inwebc/Chapter 5/C for Inform.w"
char * nonterminal_variable_identifier(char *name) ;
#line 631 "inwebc/Chapter 5/C for Inform.w"
void  c_for_inform_additional_tangling(programming_language *pl, web *W, tangle_target *target) ;
#line 679 "inwebc/Chapter 5/C for Inform.w"
void  weave_grammar_index(FILE *F) ;
#line 754 "inwebc/Chapter 5/C for Inform.w"
void  c_for_inform_new_tag_declared(theme_tag *tag) ;
#line 760 "inwebc/Chapter 5/C for Inform.w"
int  c_for_inform_skip_in_weaving(weave_target *wv, source_line *L) ;
#line 769 "inwebc/Chapter 5/C for Inform.w"
void  c_for_inform_begin_weave(section *S, weave_target *wv) ;
#line 775 "inwebc/Chapter 5/C for Inform.w"
int  c_for_inform_syntax_colour(FILE *WEAVEOUT, weave_target *wv, 	web *W, chapter *C, section *S, source_line *L, char *matter, char *colouring) ;
#line 780 "inwebc/Chapter 5/C for Inform.w"
int  c_for_inform_weave_code_line(FILE *WEAVEOUT, weave_target *wv, 	web *W, chapter *C, section *S, source_line *L, char *matter, char *concluding_comment) ;
#line 843 "inwebc/Chapter 5/C for Inform.w"
void  c_for_inform_analyse_code(programming_language *pl, web *W) ;
#line 20 "inwebc/Chapter 6/Weave Formats.w"
void  create_weave_formats(void) ;
#line 42 "inwebc/Chapter 6/Weave Formats.w"
weave_format * create_weave_format(char *name, char *ext, weave_format *intermediate) ;
#line 53 "inwebc/Chapter 6/Weave Formats.w"
weave_format * parse_format(char *name) ;
#line 61 "inwebc/Chapter 6/Weave Formats.w"
int  html_like(weave_format *wf) ;
#line 67 "inwebc/Chapter 6/Weave Formats.w"
char * weave_file_extension(weave_format *wf) ;
#line 75 "inwebc/Chapter 6/Weave Formats.w"
void  format_top(FILE *F, weave_target *wv, char *comment) ;
#line 83 "inwebc/Chapter 6/Weave Formats.w"
void  format_subheading(FILE *F, weave_target *wv, int level, char *comment, char *head) ;
#line 91 "inwebc/Chapter 6/Weave Formats.w"
void  format_toc(FILE *F, weave_target *wv, int stage, char *text1, char *text2, paragraph *P) ;
#line 99 "inwebc/Chapter 6/Weave Formats.w"
void  format_chapter_tp(FILE *F, weave_target *wv, chapter *C) ;
#line 107 "inwebc/Chapter 6/Weave Formats.w"
void  format_paragraph_heading(FILE *F, weave_target *wv, char *TeX_macro, 	section *S, paragraph *P, char *heading_text, char *chaptermark, char *sectionmark, 	int weight) ;
#line 120 "inwebc/Chapter 6/Weave Formats.w"
void  format_source_code(FILE *F, weave_target *wv, 	int tab_stops_of_indentation, 	char *prefatory, char *matter, char *colouring, char *concluding_comment, 	int starts, int finishes, int code_mode) ;
#line 134 "inwebc/Chapter 6/Weave Formats.w"
void  format_source_fragment(FILE *F, weave_target *wv, char *fragment) ;
#line 149 "inwebc/Chapter 6/Weave Formats.w"
void  format_comment_lines(FILE *F, weave_target *wv, source_line *from, source_line *to) ;
#line 157 "inwebc/Chapter 6/Weave Formats.w"
void  format_display_line(FILE *F, weave_target *wv, char *from) ;
#line 165 "inwebc/Chapter 6/Weave Formats.w"
void  format_item(FILE *F, weave_target *wv, int depth, char *label) ;
#line 173 "inwebc/Chapter 6/Weave Formats.w"
void  format_bar(FILE *F, weave_target *wv) ;
#line 181 "inwebc/Chapter 6/Weave Formats.w"
void  format_figure(FILE *F, weave_target *wv, char *figname, int cm) ;
#line 189 "inwebc/Chapter 6/Weave Formats.w"
void  format_cweb_macro(char *matter, weave_target *wv, cweb_macro *cwm, int defn) ;
#line 197 "inwebc/Chapter 6/Weave Formats.w"
void  format_pagebreak(FILE *F, weave_target *wv) ;
#line 205 "inwebc/Chapter 6/Weave Formats.w"
void  format_blank_line(FILE *F, weave_target *wv, int in_comment) ;
#line 213 "inwebc/Chapter 6/Weave Formats.w"
void  format_code_note(FILE *F, weave_target *wv, char *comment) ;
#line 221 "inwebc/Chapter 6/Weave Formats.w"
void  format_change_mode(FILE *F, weave_target *wv, int old_mode, int new_mode, int content) ;
#line 242 "inwebc/Chapter 6/Weave Formats.w"
void  format_change_colour(weave_target *wv, char *slot, int col, int in_code) ;
#line 251 "inwebc/Chapter 6/Weave Formats.w"
void  format_endnote(FILE *F, weave_target *wv, int end) ;
#line 259 "inwebc/Chapter 6/Weave Formats.w"
void  format_identifier(FILE *F, weave_target *wv, char *id) ;
#line 263 "inwebc/Chapter 6/Weave Formats.w"
void  format_identifier_r(FILE *F, weave_target *wv, char *id, int within) ;
#line 285 "inwebc/Chapter 6/Weave Formats.w"
void  format_locale(FILE *F, weave_target *wv, paragraph *par1, paragraph *par2) ;
#line 293 "inwebc/Chapter 6/Weave Formats.w"
void  format_tail(FILE *F, weave_target *wv, char *comment) ;
#line 304 "inwebc/Chapter 6/Weave Formats.w"
void  post_process_weave(weave_target *wv, int open_afterwards) ;
#line 309 "inwebc/Chapter 6/Weave Formats.w"
void  report_on_post_processing(weave_target *wv) ;
#line 314 "inwebc/Chapter 6/Weave Formats.w"
int  substitute_post_processing_data(char *to, weave_target *wv, char *detail) ;
#line 320 "inwebc/Chapter 6/Weave Formats.w"
int  index_pdfs(char *format) ;
#line 9 "inwebc/Chapter 6/Plain Text Format.w"
void  plain_top(FILE *F, weave_target *wv, char *comment) ;
#line 16 "inwebc/Chapter 6/Plain Text Format.w"
void  plain_subheading(FILE *F, weave_target *wv, int level, char *comment, char *head) ;
#line 24 "inwebc/Chapter 6/Plain Text Format.w"
void  plain_toc(FILE *F, weave_target *wv, int stage, char *text1, char *text2, paragraph *P) ;
#line 36 "inwebc/Chapter 6/Plain Text Format.w"
void  plain_chapter_tp(FILE *F, weave_target *wv, chapter *C) ;
#line 46 "inwebc/Chapter 6/Plain Text Format.w"
void  plain_paragraph_heading(FILE *F, weave_target *wv, char *TeX_macro, 	section *S, paragraph *P, char *heading_text, char *chaptermark, char *sectionmark, 	int weight) ;
#line 61 "inwebc/Chapter 6/Plain Text Format.w"
void  plain_source_code(FILE *WEAVEOUT, weave_target *wv, 	int tab_stops_of_indentation, 	char *prefatory, char *matter, char *colouring, char *concluding_comment, 	int starts, int finishes, int code_mode) ;
#line 80 "inwebc/Chapter 6/Plain Text Format.w"
void  plain_inline_code(FILE *F, weave_target *wv, int enter) ;
#line 86 "inwebc/Chapter 6/Plain Text Format.w"
void  plain_comment_lines(FILE *F, weave_target *wv, source_line *from, source_line *to) ;
#line 92 "inwebc/Chapter 6/Plain Text Format.w"
void  plain_display_line(FILE *F, weave_target *wv, char *from) ;
#line 99 "inwebc/Chapter 6/Plain Text Format.w"
void  plain_item(FILE *F, weave_target *wv, int depth, char *label) ;
#line 107 "inwebc/Chapter 6/Plain Text Format.w"
void  plain_bar(FILE *F, weave_target *wv) ;
#line 114 "inwebc/Chapter 6/Plain Text Format.w"
void  plain_figure(FILE *F, weave_target *wv, char *figname, int cm) ;
#line 120 "inwebc/Chapter 6/Plain Text Format.w"
void  plain_cweb_macro(char *matter, weave_target *wv, cweb_macro *cwm, int defn) ;
#line 129 "inwebc/Chapter 6/Plain Text Format.w"
void  plain_pagebreak(FILE *F, weave_target *wv) ;
#line 135 "inwebc/Chapter 6/Plain Text Format.w"
void  plain_blank_line(FILE *F, weave_target *wv, int in_comment) ;
#line 142 "inwebc/Chapter 6/Plain Text Format.w"
void  plain_code_note(FILE *F, weave_target *wv, char *comment) ;
#line 149 "inwebc/Chapter 6/Plain Text Format.w"
void  plain_change_mode(FILE *F, weave_target *wv, int old_mode, int new_mode, int content) ;
#line 155 "inwebc/Chapter 6/Plain Text Format.w"
void  plain_change_colour(weave_target *wv, char *slot, int col, int in_code) ;
#line 161 "inwebc/Chapter 6/Plain Text Format.w"
void  plain_endnote(FILE *F, weave_target *wv, int end) ;
#line 168 "inwebc/Chapter 6/Plain Text Format.w"
void  plain_identifier(FILE *F, weave_target *wv, char *id) ;
#line 175 "inwebc/Chapter 6/Plain Text Format.w"
void  plain_locale(FILE *F, weave_target *wv, paragraph *par1, paragraph *par2) ;
#line 183 "inwebc/Chapter 6/Plain Text Format.w"
void  plain_tail(FILE *F, weave_target *wv, char *comment) ;
#line 9 "inwebc/Chapter 6/TeX Format.w"
void  tex_top(FILE *F, weave_target *wv, char *comment) ;
#line 36 "inwebc/Chapter 6/TeX Format.w"
void  tex_subheading(FILE *F, weave_target *wv, int level, char *comment, char *head) ;
#line 53 "inwebc/Chapter 6/TeX Format.w"
void  tex_toc(FILE *F, weave_target *wv, int stage, char *text1, char *text2, paragraph *P) ;
#line 74 "inwebc/Chapter 6/TeX Format.w"
void  tex_chapter_tp(FILE *F, weave_target *wv, chapter *C) ;
#line 84 "inwebc/Chapter 6/TeX Format.w"
void  tex_paragraph_heading(FILE *F, weave_target *wv, char *TeX_macro, 	section *S, paragraph *P, char *heading_text, char *chaptermark, char *sectionmark, 	int weight) ;
#line 104 "inwebc/Chapter 6/TeX Format.w"
void  tex_source_code(FILE *WEAVEOUT, weave_target *wv, 	int tab_stops_of_indentation, 	char *prefatory, char *matter, char *colouring, char *concluding_comment, 	int starts, int finishes, int code_mode) ;
#line 152 "inwebc/Chapter 6/TeX Format.w"
void  tex_inline_code(FILE *F, weave_target *wv, int enter) ;
#line 159 "inwebc/Chapter 6/TeX Format.w"
void  tex_change_colour(weave_target *wv, char *slot, int col, int in_code) ;
#line 174 "inwebc/Chapter 6/TeX Format.w"
void  tex_comment_lines(FILE *F, weave_target *wv, source_line *from, source_line *to) ;
#line 180 "inwebc/Chapter 6/TeX Format.w"
void  tex_display_line(FILE *F, weave_target *wv, char *text) ;
#line 187 "inwebc/Chapter 6/TeX Format.w"
void  tex_item(FILE *F, weave_target *wv, int depth, char *label) ;
#line 200 "inwebc/Chapter 6/TeX Format.w"
void  tex_bar(FILE *F, weave_target *wv) ;
#line 212 "inwebc/Chapter 6/TeX Format.w"
void  tex_figure(FILE *F, weave_target *wv, char *figname, int cm) ;
#line 230 "inwebc/Chapter 6/TeX Format.w"
void  tex_cweb_macro(char *matter, weave_target *wv, cweb_macro *cwm, int defn) ;
#line 263 "inwebc/Chapter 6/TeX Format.w"
void  tex_pagebreak(FILE *F, weave_target *wv) ;
#line 270 "inwebc/Chapter 6/TeX Format.w"
void  tex_blank_line(FILE *F, weave_target *wv, int in_comment) ;
#line 278 "inwebc/Chapter 6/TeX Format.w"
void  tex_endnote(FILE *F, weave_target *wv, int end) ;
#line 290 "inwebc/Chapter 6/TeX Format.w"
void  tex_identifier(FILE *F, weave_target *wv, char *id) ;
#line 308 "inwebc/Chapter 6/TeX Format.w"
void  tex_locale(FILE *F, weave_target *wv, paragraph *par1, paragraph *par2) ;
#line 316 "inwebc/Chapter 6/TeX Format.w"
void  tex_code_note(FILE *F, weave_target *wv, char *comment) ;
#line 324 "inwebc/Chapter 6/TeX Format.w"
void  tex_change_mode(FILE *F, weave_target *wv, int old_mode, int new_mode, int content) ;
#line 351 "inwebc/Chapter 6/TeX Format.w"
void  tex_tail(FILE *F, weave_target *wv, char *comment) ;
#line 17 "inwebc/Chapter 6/HTML Formats.w"
void  html_top(FILE *F, weave_target *wv, char *comment) ;
#line 45 "inwebc/Chapter 6/HTML Formats.w"
void  html_subheading(FILE *F, weave_target *wv, int level, char *comment, char *head) ;
#line 58 "inwebc/Chapter 6/HTML Formats.w"
void  html_toc(FILE *F, weave_target *wv, int stage, char *text1, char *text2, paragraph *P) ;
#line 77 "inwebc/Chapter 6/HTML Formats.w"
void  html_chapter_tp(FILE *F, weave_target *wv, chapter *C) ;
#line 86 "inwebc/Chapter 6/HTML Formats.w"
void  html_paragraph_heading(FILE *F, weave_target *wv, char *TeX_macro, 	section *S, paragraph *P, char *heading_text, char *chaptermark, char *sectionmark, 	int weight) ;
#line 117 "inwebc/Chapter 6/HTML Formats.w"
void  breadcrumb(FILE *F, char *text, char *link) ;
#line 125 "inwebc/Chapter 6/HTML Formats.w"
void  html_source_code(FILE *WEAVEOUT, weave_target *wv, int tab_stops_of_indentation, 	char *prefatory, char *matter, char *colouring, char *concluding_comment, 	int starts, int finishes, int code_mode) ;
#line 167 "inwebc/Chapter 6/HTML Formats.w"
void  html_inline_code(FILE *F, weave_target *wv, int enter) ;
#line 175 "inwebc/Chapter 6/HTML Formats.w"
void  html_comment_lines(FILE *F, weave_target *wv, source_line *from, source_line *to) ;
#line 181 "inwebc/Chapter 6/HTML Formats.w"
void  html_display_line(FILE *F, weave_target *wv, char *from) ;
#line 190 "inwebc/Chapter 6/HTML Formats.w"
void  html_item(FILE *F, weave_target *wv, int depth, char *label) ;
#line 202 "inwebc/Chapter 6/HTML Formats.w"
void  exit_items(FILE *F, int depth) ;
#line 219 "inwebc/Chapter 6/HTML Formats.w"
void  html_bar(FILE *F, weave_target *wv) ;
#line 227 "inwebc/Chapter 6/HTML Formats.w"
void  html_figure(FILE *F, weave_target *wv, char *figname, int cm) ;
#line 235 "inwebc/Chapter 6/HTML Formats.w"
void  html_cweb_macro(char *matter, weave_target *wv, cweb_macro *cwm, int defn) ;
#line 249 "inwebc/Chapter 6/HTML Formats.w"
void  html_pagebreak(FILE *F, weave_target *wv) ;
#line 256 "inwebc/Chapter 6/HTML Formats.w"
void  html_blank_line(FILE *F, weave_target *wv, int in_comment) ;
#line 266 "inwebc/Chapter 6/HTML Formats.w"
void  html_code_note(FILE *F, weave_target *wv, char *comment) ;
#line 274 "inwebc/Chapter 6/HTML Formats.w"
void  html_change_mode(FILE *F, weave_target *wv, int old_mode, int new_mode, int content) ;
#line 324 "inwebc/Chapter 6/HTML Formats.w"
void  html_change_colour(weave_target *wv, char *slot, int col, int in_code) ;
#line 342 "inwebc/Chapter 6/HTML Formats.w"
void  html_endnote(FILE *F, weave_target *wv, int end) ;
#line 354 "inwebc/Chapter 6/HTML Formats.w"
void  html_identifier(FILE *F, weave_target *wv, char *id) ;
#line 368 "inwebc/Chapter 6/HTML Formats.w"
void  html_locale(FILE *F, weave_target *wv, paragraph *par1, paragraph *par2) ;
#line 382 "inwebc/Chapter 6/HTML Formats.w"
void  html_xref(FILE *F, weave_target *wv, paragraph *P, section *from, int a_link) ;
#line 402 "inwebc/Chapter 6/HTML Formats.w"
void  html_tail(FILE *F, weave_target *wv, char *comment) ;
#line 37 "inwebc/Chapter 6/Running Through TeX.w"
void  tex_post_process_weave(weave_target *wv, int open_afterwards) ;
#line 125 "inwebc/Chapter 6/Running Through TeX.w"
void  scan_console_line(char *line, text_file_position *tfp, void *unused_state) ;
#line 141 "inwebc/Chapter 6/Running Through TeX.w"
void  tex_report_on_post_processing(weave_target *wv) ;
#line 155 "inwebc/Chapter 6/Running Through TeX.w"
void  copy_with_changed_extension(char *to, char *from, char *old_ext, char *new_ext) ;
#line 165 "inwebc/Chapter 6/Running Through TeX.w"
int  tex_substitute_post_processing_data(char *to, weave_target *wv, char *detail) ;
#line 33 "inwebc/Chapter 5/Programming Languages.w"

#line 37 "inwebc/Chapter 5/Programming Languages.w"
programming_language *C_FOR_INFORM_LANGUAGE = NULL;
programming_language *C_LANGUAGE = NULL;
programming_language *CPP_LANGUAGE = NULL; /* never actually tested */
programming_language *I6_LANGUAGE = NULL;
programming_language *I7_LANGUAGE = NULL;
programming_language *PERL_LANGUAGE = NULL; /* Perl 5, that is, though 6 may also work */
programming_language *PLAIN_LANGUAGE = NULL;

programming_language *NO_LANGUAGE = NULL; /* a dummy language for error recovery */

#line 46 "inwebc/Chapter 5/C-Like Languages.w"

c_structure *first_cst_alphabetically = NULL;

#line 59 "inwebc/Chapter 5/C-Like Languages.w"

#line 69 "inwebc/Chapter 5/C-Like Languages.w"

#line 80 "inwebc/Chapter 5/C-Like Languages.w"

#line 100 "inwebc/Chapter 5/C-Like Languages.w"

#line 60 "inwebc/Chapter 5/C for Inform.w"

#line 68 "inwebc/Chapter 5/C for Inform.w"

#line 72 "inwebc/Chapter 5/C for Inform.w"
preform_nonterminal *first_pnt_alphabetically = NULL;

theme_tag *Preform_theme = NULL;

#line 26 "inwebc/Chapter 1/Basics.w"

#line 59 "inwebc/Chapter 1/Basics.w"

#line 66 "inwebc/Chapter 1/Basics.w"
int check_len(int n) {
	if ((n > MAX_STRING_LENGTH) || (n < 0)) fatal_error("String overflow\n");
	return n;
}

#line 75 "inwebc/Chapter 1/Basics.w"
int in_strlen(char *str) {
	for (int i=0; i<=MAX_STRING_LENGTH; i++)
		if (str[i] == 0) return i;
	str[MAX_STRING_LENGTH] = 0;
	return MAX_STRING_LENGTH;
}

#line 85 "inwebc/Chapter 1/Basics.w"
void in_set(char *str, int i, int to) {
	if ((i < 0) || (i > MAX_STRING_LENGTH)) check_len(i);
	else str[i] = to;
}

#line 94 "inwebc/Chapter 1/Basics.w"
void in_truncate(char *str, int len) {
	if ((len < 0) || (len > MAX_STRING_LENGTH)) { check_len(len); str[0] = 0; }
	else str[len] = 0;
}

#line 103 "inwebc/Chapter 1/Basics.w"
void in_strcpy(char *to, char *from) {
	check_len(in_strlen(from));
	int i;
	for (i=0; ((from[i]) && (i < MAX_STRING_LENGTH)); i++) to[i] = from[i];
	to[i] = 0;
}

#line 113 "inwebc/Chapter 1/Basics.w"
void in_strcat(char *to, char *from) {
	int i, L = in_strlen(to);
	check_len(L + in_strlen(from));
	for (i=0; ((from[i]) && (L+i < MAX_STRING_LENGTH)); i++) to[L+i] = from[i];
	to[L+i] = 0;
}

#line 131 "inwebc/Chapter 1/Basics.w"
#define in_sprintf(to, args...) \
	check_len(snprintf(to, MAX_STRING_LENGTH, args))
#define in_sprcat(to, args...) \
	check_len(snprintf(to+in_strlen(to), MAX_STRING_LENGTH-in_strlen(to), args))

#line 139 "inwebc/Chapter 1/Basics.w"
int in_string_eq(char *A, char *B) {
	return (in_string_cmp(A, B) == 0)?TRUE:FALSE;
}

int in_string_ne(char *A, char *B) {
	return (in_string_cmp(A, B) == 0)?FALSE:TRUE;
}

#line 150 "inwebc/Chapter 1/Basics.w"
int in_string_cmp(char *A, char *B) {
	if ((A == NULL) || (A[0] == 0)) {
		if ((B == NULL) || (B[0] == 0)) return 0;
		return -1;
	}
	if ((B == NULL) || (B[0] == 0)) return 1;
	return strcmp(A, B);
}

#line 162 "inwebc/Chapter 1/Basics.w"
int in_string_eq_insensitive(char *A, char *B) {
	int i;
	for (i=0; ((A[i]) && (B[i])); i++)
		if (tolower(A[i]) != tolower(B[i])) return FALSE;
	if ((A[i] == 0) && (B[i] == 0)) return TRUE;
	return FALSE;
}

#line 178 "inwebc/Chapter 1/Basics.w"
void issue_os_command_0(char *command) {
	system(command);
}

void issue_os_command_1(char *command, char *fn1) {
	string osc;
	in_sprintf(osc, command, fn1);
	issue_os_command_0(osc);
}

void issue_os_command_2(char *command, char *fn1, char *fn2) {
	string osc;
	in_sprintf(osc, command, fn1, fn2);
	issue_os_command_0(osc);
}

#line 85 "inwebc/Chapter 1/Memory.w"

#line 91 "inwebc/Chapter 1/Memory.w"
allocation_status_structure alloc_status[NO_MEMORY_TYPES];

void start_memory(void) {
	int i;
	for (i=0; i<NO_MEMORY_TYPES; i++) {
		alloc_status[i].first_in_memory = NULL;
		alloc_status[i].last_in_memory = NULL;
		alloc_status[i].objects_allocated = 0;
		alloc_status[i].objects_count = 0;
		alloc_status[i].bytes_allocated = 0;
		alloc_status[i].no_allocated_together = 1;
		alloc_status[i].name_of_type = "unused";
	}
}

#line 146 "inwebc/Chapter 1/Memory.w"
int no_blocks_allocated = 0;
int total_objects_allocated = 0; /* a much larger number, used only for the debugging log */

#line 160 "inwebc/Chapter 1/Memory.w"

#line 164 "inwebc/Chapter 1/Memory.w"
memblock_header *first_memblock_header = NULL; /* head of list of memory blocks */
memblock_header *current_memblock_header = NULL; /* tail of list of memory blocks */

int used_in_current_memblock = 0; /* number of bytes so far used in the tail memory block */

#line 173 "inwebc/Chapter 1/Memory.w"
void allocate_another_block(void) {
	unsigned char *cp;
	memblock_header *mh;

	
{
#line 190 "inwebc/Chapter 1/Memory.w"
	int i;
	if (no_blocks_allocated++ >= MAX_BLOCKS_ALLOWED)
		fatal_error(
			"the memory manager has halted inweb, which seems to be generating "
			"endless structures. Presumably it is trapped in a loop");
	check_memory_integrity();
	cp = (unsigned char *) (malloc(MEMORY_GRANULARITY));
	if (cp == NULL) fatal_error("Run out of memory: malloc failed");
	for (i=0; i<MEMORY_GRANULARITY; i++) cp[i] = 0;

}
#line 177 "inwebc/Chapter 1/Memory.w"
;

	mh = (memblock_header *) cp;
	used_in_current_memblock = sizeof(memblock_header) + SAFETY_MARGIN;
	mh->the_memory = (void *) (cp + used_in_current_memblock);

	
{
#line 204 "inwebc/Chapter 1/Memory.w"
	if (current_memblock_header == NULL) {
		mh->block_number = 0;
		first_memblock_header = mh;
	} else {
		mh->block_number = current_memblock_header->block_number + 1;
		current_memblock_header->next = mh;
	}
	current_memblock_header = mh;

}
#line 183 "inwebc/Chapter 1/Memory.w"
;
}

#line 218 "inwebc/Chapter 1/Memory.w"
void free_memory(void) {
	free_ssas();
	memblock_header *mh = first_memblock_header;
	while (mh != NULL) {
		memblock_header *next_mh = mh->next;
		void *p = (void *) mh;
		free(p);
		mh = next_mh;
	}
}

#line 245 "inwebc/Chapter 1/Memory.w"

#line 251 "inwebc/Chapter 1/Memory.w"
memory_frame *first_memory_frame = NULL; /* earliest memory frame ever allocated */
memory_frame *last_memory_frame = NULL;  /* most recent memory frame allocated */

#line 262 "inwebc/Chapter 1/Memory.w"
int calls_to_cmi = 0;
void check_memory_integrity(void) {
	int c;
	memory_frame *mf;
	c = calls_to_cmi++;
	if (!((c<10) || (c == 100) || (c == 1000) || (c == 10000))) return;

	for (c = 0, mf = first_memory_frame; mf; c++, mf = mf->next_frame)
		if (mf->integrity_check != INTEGRITY_NUMBER)
			fatal_error("Memory manager failed integrity check");
}

void debug_memory_frames(int from, int to) {
	int c;
	memory_frame *mf;
	for (c = 0, mf = first_memory_frame; (mf) && (c <= to); c++, mf = mf->next_frame)
		if (c >= from) {
			char *desc = "corrupt";
			if (mf->integrity_check == INTEGRITY_NUMBER)
				desc = alloc_status[mf->mem_type].name_of_type;
		}
}

#line 291 "inwebc/Chapter 1/Memory.w"
void *allocate_mem(int mem_type, int extent) {
	unsigned char *cp;
	memory_frame *mf;
	int bytes_free_in_current_memblock, extent_without_overheads = extent;

	extent += sizeof(memory_frame); /* each allocation is preceded by a memory frame */
	extent += SAFETY_MARGIN; /* each allocation is followed by |SAFETY_MARGIN| null bytes */

	
{
#line 324 "inwebc/Chapter 1/Memory.w"
	if (current_memblock_header == NULL) allocate_another_block();
	bytes_free_in_current_memblock = MEMORY_GRANULARITY - (used_in_current_memblock + extent);
	if (bytes_free_in_current_memblock < BLANK_END_SIZE) {
		allocate_another_block();
		if (extent+BLANK_END_SIZE >= MEMORY_GRANULARITY)
			fatal_error("Memory manager failed because granularity too low");
	}

}
#line 299 "inwebc/Chapter 1/Memory.w"
;

	cp = ((unsigned char *) (current_memblock_header->the_memory)) + used_in_current_memblock;
	used_in_current_memblock += extent;

	mf = (memory_frame *) cp; /* the new memory frame, */
	cp = cp + sizeof(memory_frame); /* following which is the actual allocated data */

	mf->integrity_check = INTEGRITY_NUMBER;
	mf->allocation_id = alloc_status[mem_type].objects_allocated;
	mf->mem_type = mem_type;

	
{
#line 335 "inwebc/Chapter 1/Memory.w"
	mf->next_frame = NULL;
	if (first_memory_frame == NULL) first_memory_frame = mf;
	else last_memory_frame->next_frame = mf;
	last_memory_frame = mf;

}
#line 311 "inwebc/Chapter 1/Memory.w"
;
	
{
#line 343 "inwebc/Chapter 1/Memory.w"
	if (alloc_status[mem_type].first_in_memory == NULL)
		alloc_status[mem_type].first_in_memory = (void *) cp;
	alloc_status[mem_type].last_in_memory = (void *) cp;
	alloc_status[mem_type].objects_allocated++;
	alloc_status[mem_type].bytes_allocated += extent_without_overheads;

}
#line 312 "inwebc/Chapter 1/Memory.w"
;

	total_objects_allocated++;

	return (void *) cp;
}

#line 488 "inwebc/Chapter 1/Memory.w"
ALLOCATE_IN_ARRAYS(source_line, 1000)
ALLOCATE_INDIVIDUALLY(bibliographic_datum)
ALLOCATE_INDIVIDUALLY(c_structure)
ALLOCATE_INDIVIDUALLY(chapter)
ALLOCATE_INDIVIDUALLY(cweb_macro)
ALLOCATE_INDIVIDUALLY(function)
ALLOCATE_INDIVIDUALLY(hash_table_entry_usage)
ALLOCATE_INDIVIDUALLY(hash_table_entry)
ALLOCATE_INDIVIDUALLY(macro_usage)
ALLOCATE_INDIVIDUALLY(nonterminal_variable)
ALLOCATE_INDIVIDUALLY(paragraph_tag)
ALLOCATE_INDIVIDUALLY(paragraph)
ALLOCATE_INDIVIDUALLY(preform_nonterminal)
ALLOCATE_INDIVIDUALLY(programming_language)
ALLOCATE_INDIVIDUALLY(tex_results)
ALLOCATE_INDIVIDUALLY(section)
ALLOCATE_INDIVIDUALLY(string_storage_area)
ALLOCATE_INDIVIDUALLY(structure_dependence)
ALLOCATE_INDIVIDUALLY(structure_element)
ALLOCATE_INDIVIDUALLY(structure_permission)
ALLOCATE_INDIVIDUALLY(tangle_target)
ALLOCATE_INDIVIDUALLY(theme_tag)
ALLOCATE_INDIVIDUALLY(weave_format)
ALLOCATE_INDIVIDUALLY(weave_target)
ALLOCATE_INDIVIDUALLY(web)

#line 525 "inwebc/Chapter 1/Memory.w"

string_storage_area *current_ssa = NULL;

#line 533 "inwebc/Chapter 1/Memory.w"
char *new_string(char *from) {
	int length_needed = in_strlen(from) + 1;
	if (!((current_ssa) &&
		(current_ssa->first_free_byte + length_needed < SSA_CAPACITY))) {
		current_ssa = CREATE(string_storage_area);
		current_ssa->storage_at = malloc(SSA_CAPACITY);
		current_ssa->first_free_byte = 0;
	}
	char *rp = current_ssa->storage_at + current_ssa->first_free_byte;
	current_ssa->first_free_byte += length_needed;
	in_strcpy(rp, from);
	return rp;
}

#line 550 "inwebc/Chapter 1/Memory.w"
void free_ssas(void) {
	string_storage_area *ssa;
	LOOP_OVER(ssa, string_storage_area)
		free(ssa->storage_at);
}

#line 17 "inwebc/Chapter 1/Text Files.w"

#line 21 "inwebc/Chapter 1/Text Files.w"
text_file_position nowhere_position(void) {
	text_file_position tfp;
	tfp.text_file_filename = "<no file>";
	tfp.line_count = 0;
	tfp.line_position = 0;
	tfp.skip_terminator = FALSE;
	tfp.actively_scanning = FALSE;
	return tfp;
}

#line 36 "inwebc/Chapter 1/Text Files.w"
int file_read(char *filename, char *message, int serious,
	void (iterator)(char *, text_file_position *, void *), text_file_position *start_at,
	void *state) {
	char *stored_filename = new_string(filename);
	FILE *HANDLE;
	text_file_position tfp;
	
{
#line 52 "inwebc/Chapter 1/Text Files.w"
	HANDLE = fopen(filename, "rb");
	if (HANDLE == NULL) {
		if (message == NULL) return 0;
		if (serious) fatal_filing_system_error(message, filename);
		else { nonfatal_filing_system_error(message, filename); return 0; }
	}

}
#line 42 "inwebc/Chapter 1/Text Files.w"
;
	
{
#line 65 "inwebc/Chapter 1/Text Files.w"
	if (start_at == NULL) {
		tfp.line_count = 1;
		tfp.line_position = 0;
		tfp.skip_terminator = 'X';
	} else {
		tfp = *start_at;
		if (fseek(HANDLE, (long int) (tfp.line_position), SEEK_SET)) {
			if (serious) fatal_filing_system_error("unable to seek position in file", filename);
			nonfatal_filing_system_error("unable to seek position in file", filename);
			return 0;
		}
	}
	tfp.actively_scanning = TRUE;
	tfp.text_file_filename = stored_filename;

}
#line 43 "inwebc/Chapter 1/Text Files.w"
;
	
{
#line 84 "inwebc/Chapter 1/Text Files.w"
	string line; in_strcpy(line, "");
	int i = 0, c = ' ';
	int warned = FALSE;
	while ((c != EOF) && (tfp.actively_scanning)) {
		c = fgetc(HANDLE);
		if ((c == EOF) || (c == '\x0a') || (c == '\x0d')) {
			in_set(line, i, 0);
			if ((i > 0) || (c != tfp.skip_terminator)) {
				
{
#line 116 "inwebc/Chapter 1/Text Files.w"
	iterator(line, &tfp, state);
	tfp.line_count++;

}
#line 92 "inwebc/Chapter 1/Text Files.w"
;
				if (c == '\x0a') tfp.skip_terminator = '\x0d';
				if (c == '\x0d') tfp.skip_terminator = '\x0a';
			} else tfp.skip_terminator = 'X';
			
{
#line 130 "inwebc/Chapter 1/Text Files.w"
	tfp.line_position = (int) (ftell(HANDLE));
	if (tfp.line_position == -1) {
		if (serious)
			fatal_filing_system_error("unable to determine position in file", filename);
		else
			nonfatal_filing_system_error("unable to determine position in file", filename);
	}

}
#line 96 "inwebc/Chapter 1/Text Files.w"
;
			i = 0;
		} else {
			if (i < MAX_STRING_LENGTH) in_set(line, i++, (char) c);
			else {
				if (serious) fatal_filing_system_error("line too long", filename);
				if (warned == FALSE) {
					error_in_text_file("line too long (truncating it)", &tfp);
					warned = TRUE;
				}
			}
		}
	}
	if ((i > 0) && (tfp.actively_scanning))
		
{
#line 116 "inwebc/Chapter 1/Text Files.w"
	iterator(line, &tfp, state);
	tfp.line_count++;

}
#line 110 "inwebc/Chapter 1/Text Files.w"
;


}
#line 44 "inwebc/Chapter 1/Text Files.w"
;
	fclose(HANDLE);
	return tfp.line_count;
}

#line 10 "inwebc/Chapter 1/Pattern Matching.w"
int white_space(int c) {
	if ((c == ' ') || (c == '\t')) return TRUE;
	return FALSE;
}

#line 20 "inwebc/Chapter 1/Pattern Matching.w"
int identifier_char(int c) {
	if ((c == '_') || (c == ':') ||
		((c >= 'A') && (c <= 'Z')) ||
		((c >= 'a') && (c <= 'z')) ||
		((c >= '0') && (c <= '9'))) return TRUE;
	return FALSE;
}

#line 35 "inwebc/Chapter 1/Pattern Matching.w"
int find_expansion(char *original, char on1, char on2, char off1, char off2, int *len) {
	for (int i = 0; original[i]; i++)
		if ((original[i] == on1) && (original[i+1] == on2)) {
			for (int j=i+2; original[j]; j++)
				if ((original[j] == off1) && (original[j+1] == off2)) {
					*len = j+2-i;
					return i;
				}
		}
	return -1;
}

#line 50 "inwebc/Chapter 1/Pattern Matching.w"
int find_open_brace(char *p) {
	for (int i=0; p[i]; i++)
		if (p[i] == '{')
			return i;
	return -1;
}

#line 61 "inwebc/Chapter 1/Pattern Matching.w"
int string_is_white_space(char *p) {
	for (int i=0; p[i]; i++)
		if (white_space(p[i]) == FALSE)
			return FALSE;
	return TRUE;
}

#line 89 "inwebc/Chapter 1/Pattern Matching.w"
string found_text1;
string found_text2;
string found_text3;
string found_text4;

#line 105 "inwebc/Chapter 1/Pattern Matching.w"

#line 109 "inwebc/Chapter 1/Pattern Matching.w"
int pattern_match(char *text, char *pattern) {
	return pattern_match_r(text, pattern, NULL);
}

int pattern_match_r(char *text, char *pattern, match_position *scan_from) {
	match_position at;
	if (scan_from) at = *scan_from;
	else { at.tpos = 0; at.ppos = 0; at.bc = 0; at.bl = 0; }

	while ((text[at.tpos]) || (pattern[at.ppos])) {
		
{
#line 148 "inwebc/Chapter 1/Pattern Matching.w"
	if (pattern[at.ppos] == '(') {
		if (at.bl < 4) at.bracket_nesting[at.bl] = -1;
		if (at.bc < 4) {
			at.bracket_nesting[at.bl] = at.bc;
			at.brackets_start[at.bc] = at.tpos; at.brackets_end[at.bc] = -1;
		}
		at.bl++; at.bc++; at.ppos++;
		continue;
	}
	if (pattern[at.ppos] == ')') {
		at.bl--;
		if ((at.bl >= 0) && (at.bl < 4) && (at.bracket_nesting[at.bl] >= 0))
			at.brackets_end[at.bracket_nesting[at.bl]] = at.tpos-1;
		at.ppos++;
		continue;
	}

}
#line 119 "inwebc/Chapter 1/Pattern Matching.w"
;

		int chcl, /* what class of characters to match: a |*_CLASS| value */
			range_from, range_to, /* for |LITERAL_CLASS| only */
			reverse = FALSE; /* require a non-match rather than a match */
		
{
#line 168 "inwebc/Chapter 1/Pattern Matching.w"
	int len;
	chcl = get_cclass(pattern, at.ppos, &len, &range_from, &range_to, &reverse);
	at.ppos += len;

}
#line 124 "inwebc/Chapter 1/Pattern Matching.w"
;

		int rep_from = 1, rep_to = 1; /* minimum and maximum number of repetitions */
		int greedy = TRUE; /* go for a maximal-length match if possible */
		
{
#line 176 "inwebc/Chapter 1/Pattern Matching.w"
	if (chcl == WHITESPACE_CLASS) {
		rep_from = 1; rep_to = in_strlen(text)-at.tpos;
	}
	if (pattern[at.ppos] == '+') {
		rep_from = 1; rep_to = in_strlen(text)-at.tpos; at.ppos++;
	} else if (pattern[at.ppos] == '*') {
		rep_from = 0; rep_to = in_strlen(text)-at.tpos; at.ppos++;
	}
	if (pattern[at.ppos] == '?') { greedy = FALSE; at.ppos++; }

}
#line 128 "inwebc/Chapter 1/Pattern Matching.w"
;

		int reps = 0;
		
{
#line 189 "inwebc/Chapter 1/Pattern Matching.w"
	for (reps = 0; ((text[at.tpos+reps]) && (reps <= rep_to)); reps++)
		if (test_cclass(text+at.tpos+reps, chcl,
			range_from, range_to, pattern, reverse) == FALSE)
			break;

}
#line 131 "inwebc/Chapter 1/Pattern Matching.w"
;
		if (reps < rep_from) return FALSE;

		/* we can now accept anything from |rep_from| to |reps| repetitions */
		if (rep_from == reps) { at.tpos += reps; continue; }
		
{
#line 197 "inwebc/Chapter 1/Pattern Matching.w"
	int from = rep_from, to = reps, dj = 1, from_tpos = at.tpos;
	if (greedy) { from = reps; to = rep_from; dj = -1; }
	for (int j = from; j != to+dj; j += dj) {
		at.tpos = from_tpos + j;
		if (pattern_match_r(text, pattern, &at))
			return TRUE;
	}

}
#line 136 "inwebc/Chapter 1/Pattern Matching.w"
;

		/* no match length worked, so no match */
		return FALSE;
	}
	
{
#line 208 "inwebc/Chapter 1/Pattern Matching.w"
	if (at.bc > 0) {
		in_strcpy(found_text1, text + at.brackets_start[0]);
		found_text1[at.brackets_end[0]-at.brackets_start[0]+1] = 0;
	}
	if (at.bc > 1) {
		in_strcpy(found_text2, text + at.brackets_start[1]);
		found_text2[at.brackets_end[1]-at.brackets_start[1]+1] = 0;
	}
	if (at.bc > 2) {
		in_strcpy(found_text3, text + at.brackets_start[2]);
		found_text3[at.brackets_end[2]-at.brackets_start[2]+1] = 0;
	}
	if (at.bc > 3) {
		in_strcpy(found_text4, text + at.brackets_start[3]);
		found_text4[at.brackets_end[3]-at.brackets_start[3]+1] = 0;
	}

}
#line 141 "inwebc/Chapter 1/Pattern Matching.w"
;
	return TRUE;
}

#line 254 "inwebc/Chapter 1/Pattern Matching.w"
int get_cclass(char *pattern, int ppos, int *len, int *from, int *to, int *reverse) {
	if (pattern[ppos] == '^') { ppos++; *reverse = TRUE; } else { *reverse = FALSE; }
	switch (pattern[ppos]) {
		case '%':
			ppos++;
			*len = 2;
			switch (pattern[ppos]) {
				case 'd': return DIGIT_CLASS;
				case 'c': return ANY_CLASS;
				case 'C': return NONWHITESPACE_CLASS;
				case 'i': return IDENTIFIER_CLASS;
				case 'p': return PREFORM_CLASS;
				case 'P': return PREFORMC_CLASS;
			}
			*from = ppos; *to = ppos; return LITERAL_CLASS;
		case '[':
			*from = ppos+2;
			while ((pattern[ppos]) && (pattern[ppos] != ']')) ppos++;
			*to = ppos - 1; *len = ppos - *from + 1;
			return LITERAL_CLASS;
		case ' ':
			*len = 1; return WHITESPACE_CLASS;
	}
	*len = 1; *from = ppos; *to = ppos; return LITERAL_CLASS;
}

#line 283 "inwebc/Chapter 1/Pattern Matching.w"
int test_cclass(char *text, int chcl, int range_from, int range_to, char *drawn_from, int reverse) {
	int match = FALSE;
	switch (chcl) {
		case ANY_CLASS: if (text[0]) match = TRUE; break;
		case DIGIT_CLASS: if (isdigit(text[0])) match = TRUE; break;
		case WHITESPACE_CLASS: if (white_space(text[0])) match = TRUE; break;
		case NONWHITESPACE_CLASS: if (!(white_space(text[0]))) match = TRUE; break;
		case IDENTIFIER_CLASS: if (identifier_char(text[0])) match = TRUE; break;
		case PREFORM_CLASS: if ((text[0] == '-') || (text[0] == '_') ||
			((text[0] >= 'a') && (text[0] <= 'z')) ||
			((text[0] >= '0') && (text[0] <= '9'))) match = TRUE; break;
		case PREFORMC_CLASS: if ((text[0] == '-') || (text[0] == '_') || (text[0] == ':') ||
			((text[0] >= 'a') && (text[0] <= 'z')) ||
			((text[0] >= '0') && (text[0] <= '9'))) match = TRUE; break;
		case LITERAL_CLASS:
			for (int j = range_from; j <= range_to; j++) {
				int c1 = drawn_from[j], c2 = c1;
				if ((j+1 < range_to) && (drawn_from[j+1] == '-')) { c2 = drawn_from[j+2]; j += 2; }
				int c = *text;
				if ((c >= c1) && (c <= c2)) {
					match = TRUE; break;
				}
			}
			break;
	}
	if (reverse) match = (match)?FALSE:TRUE;
	return match;
}

#line 42 "inwebc/Chapter 2/Program Control.w"
string path_to_inweb_materials; /* the materials pathname, including final separator */

string tex_configuration; /* read from configuration file, not command line */
string pdftex_configuration;
string open_configuration;

#line 51 "inwebc/Chapter 2/Program Control.w"
int no_inweb_errors = 0;

#line 59 "inwebc/Chapter 2/Program Control.w"
int main(int argc, char **argv) {
	printf("%s\n", INWEB_BUILD);

	
{
#line 76 "inwebc/Chapter 2/Program Control.w"
	start_memory();
	create_programming_languages();
	create_weave_formats();

}
#line 62 "inwebc/Chapter 2/Program Control.w"
;

	inweb_instructions args = read_instructions_from_command_line(argc, argv);
	in_sprintf(path_to_inweb_materials, "%sinwebc%cMaterials%c",
		args.location_setting, SEP_CHAR, SEP_CHAR);
	read_configuration_file();
	follow_instructions(&args);

	
{
#line 83 "inwebc/Chapter 2/Program Control.w"
	free_memory();
	return (no_inweb_errors == 0)?0:1;

}
#line 70 "inwebc/Chapter 2/Program Control.w"
;
}

#line 91 "inwebc/Chapter 2/Program Control.w"
void follow_instructions(inweb_instructions *ins) {
	if (ins->inweb_mode == NO_MODE) 
{
#line 101 "inwebc/Chapter 2/Program Control.w"
	printf("A simple literate programming tool intended for medium-sized and large programs.\n");
	printf("Usage: inweb webname -action [-options] [target]\n");
	printf("  where 'webname' is a folder containing a web (an inweb project),\n");
	printf("  The most useful -action commands are:\n");
	printf("    -create: make a new web, creating its folder and contents\n");
	printf("    -tangle: make the program described in the web\n");
	printf("    -weave: make a human-readable booklet of the web\n");
	printf("  For options and less commonly used actions, see the inweb manual.\n");
	exit(0);

}
#line 92 "inwebc/Chapter 2/Program Control.w"
;
	if (ins->inweb_mode == CREATE_MODE) 
{
#line 115 "inwebc/Chapter 2/Program Control.w"
	issue_os_command_1("mkdir -pv '%s'", ins->chosen_web);
	issue_os_command_1("mkdir -pv '%sFigures'", ins->chosen_web);
	issue_os_command_1("mkdir -pv '%sMaterials'", ins->chosen_web);
	issue_os_command_1("mkdir -pv '%sSections'", ins->chosen_web);
	issue_os_command_1("mkdir -pv '%sTangled'", ins->chosen_web);
	issue_os_command_1("mkdir -pv '%sWoven'", ins->chosen_web);
	string default_conts;
	in_sprintf(default_conts, "%sContents.w", path_to_inweb_materials);
	issue_os_command_2("cp -nv '%s' '%s'", default_conts, ins->chosen_web);
	string default_main;
	in_sprintf(default_main, "%sMain.w", path_to_inweb_materials);
	string new_sections;
	in_sprintf(new_sections, "%s%cSections", ins->chosen_web, SEP_CHAR);
	issue_os_command_2("cp -nv '%s' '%s'", default_main, new_sections);

}
#line 93 "inwebc/Chapter 2/Program Control.w"

	else 
{
#line 133 "inwebc/Chapter 2/Program Control.w"
	web *W = load_web(ins->chosen_web, ins->verbose_switch);
	print_web_statistics(W);
	if (ins->inweb_mode == ANALYSE_MODE) 
{
#line 142 "inwebc/Chapter 2/Program Control.w"
	if (ins->swarm_mode != SWARM_OFF)
		fatal_error("only specific parts of the web can be analysed");
	if (ins->catalogue_switch) catalogue_the_sections(W, ins->chosen_subweb, FALSE);
	if (ins->functions_switch) catalogue_the_sections(W, ins->chosen_subweb, TRUE);
	if (ins->scan_switch) scan_line_categories(W, ins->chosen_subweb);

}
#line 135 "inwebc/Chapter 2/Program Control.w"
;
	if (ins->inweb_mode == TANGLE_MODE) 
{
#line 164 "inwebc/Chapter 2/Program Control.w"
	string tangle_to; in_strcpy(tangle_to, "");
	tangle_target *tn = NULL;
	if (in_string_eq(ins->chosen_subweb, "0")) {
		
{
#line 185 "inwebc/Chapter 2/Program Control.w"
	tn = NULL;
	if (bibliographic_data_exists(W, "Short Title"))
		in_strcpy(tangle_to, get_bibliographic_data(W, "Short Title"));
	else
		in_strcpy(tangle_to, get_bibliographic_data(W, "Title"));
	in_strcat(tangle_to, W->main_language->file_extension);

}
#line 167 "inwebc/Chapter 2/Program Control.w"
;
	} else if (get_section_for_sigil(W, ins->chosen_subweb)) {
		
{
#line 195 "inwebc/Chapter 2/Program Control.w"
	section *S = get_section_for_sigil(W, ins->chosen_subweb);
	tn = S->sect_target;
	if (tn == NULL) fatal_error("section cannot be independently tangled");
	in_strcpy(tangle_to, S->leafname);

}
#line 169 "inwebc/Chapter 2/Program Control.w"
;
	} else {
		
{
#line 204 "inwebc/Chapter 2/Program Control.w"
	chapter *C;
	LOOP_OVER(C, chapter)
		if (in_string_eq(ins->chosen_subweb, C->ch_sigil))
			if (C->ch_target) {
				if (pattern_match(C->ch_title, "%c+?: (%c+)"))
					in_strcpy(tangle_to, found_text1);
				else
					in_strcpy(tangle_to, C->ch_title);
				tn = C->ch_target;
				break;
			}
	if (tn == NULL)
		fatal_error("only the entire web, or specific sections, can be tangled");

}
#line 171 "inwebc/Chapter 2/Program Control.w"
;
	}
	if (tangle_to[0] == 0) { fatal_error("no tangle destination known"); }
	string temp;
	in_strcpy(temp, tangle_to);
	if (ins->tangle_setting[0]) in_strcpy(tangle_to, ins->tangle_setting);
	else in_sprintf(tangle_to, "%sTangled%c%s", W->path_to_web, SEP_CHAR, temp);
	if (tn == NULL) tn = W->first_target;
	tangle_source(W, tn, tangle_to);

}
#line 136 "inwebc/Chapter 2/Program Control.w"
;
	if (ins->inweb_mode == WEAVE_MODE) 
{
#line 221 "inwebc/Chapter 2/Program Control.w"
	number_web(W);
	theme_tag *tag = tag_by_name(ins->theme_setting);
	if ((ins->theme_setting[0]) && (tag == NULL))
		fatal_error_with_parameter("no such theme as '%s'", ins->theme_setting);
	if (ins->swarm_mode == SWARM_OFF) {
		int shall_we_open = ins->open_pdf_switch;
		if (shall_we_open == UNKNOWN) { /* i.e., if it wasn't set at the command line */
			if (in_string_ne(open_configuration, "")) shall_we_open = TRUE;
			else shall_we_open = FALSE;
		}
		weave_subset_of_web(W, ins->chosen_subweb, shall_we_open, tag, ins->weave_format);
	} else {
		weave_swarm(W, ins->chosen_subweb, ins->swarm_mode, tag, ins->weave_format);
	}

}
#line 137 "inwebc/Chapter 2/Program Control.w"
;

}
#line 94 "inwebc/Chapter 2/Program Control.w"
;
}

#line 29 "inwebc/Chapter 2/Command Line Arguments.w"

#line 33 "inwebc/Chapter 2/Command Line Arguments.w"
inweb_instructions read_instructions_from_command_line(int argc, char **argv) {
	inweb_instructions args;
	args.inweb_mode = NO_MODE;
	args.swarm_mode = SWARM_OFF;
	args.catalogue_switch = FALSE;
	args.functions_switch = FALSE;
	args.open_pdf_switch = UNKNOWN;
	args.scan_switch = FALSE;
	args.verbose_switch = FALSE;
	in_strcpy(args.chosen_web, "");
	in_strcpy(args.chosen_subweb, "0"); /* by default, the entire web is the target */
	in_strcpy(args.tangle_setting, "");
	in_strcpy(args.theme_setting, "");
	in_strcpy(args.weave_format, "PDF");
	in_strcpy(args.location_setting, "");

	int i;
	int targets = 0;
	for (i=1; i<argc; i++) {
		char *opt = argv[i];
		int non_switch_follows = FALSE;
		if (i+1 < argc) {
			char *next_opt = argv[i+1];
			if (next_opt[0] != '-') non_switch_follows = TRUE;
		}
		if (opt[0] == '-') 
{
#line 71 "inwebc/Chapter 2/Command Line Arguments.w"
	if (opt[1] == '-') opt++; /* allow a doubled-dash as equivalent to a single */
	if (in_string_eq(opt, "-verbose")) {
		args.verbose_switch = TRUE; continue;
	}
	if (in_string_eq(opt, "-at")) {
		if (non_switch_follows) {
			in_strcpy(args.location_setting, argv[i+1]); i++; continue;
		}
		fatal_error("-at must be followed by the pathname where inweb lives");
	}
	
{
#line 90 "inwebc/Chapter 2/Command Line Arguments.w"
	if (in_string_eq(opt, "-catalogue")) {
		args.catalogue_switch = TRUE; enter_main_mode(&args, ANALYSE_MODE); continue;
	}
	if (in_string_eq(opt, "-functions")) {
		args.functions_switch = TRUE; enter_main_mode(&args, ANALYSE_MODE); continue;
	}
	if (in_string_eq(opt, "-scan")) {
		args.scan_switch = TRUE; enter_main_mode(&args, ANALYSE_MODE); continue;
	}

}
#line 81 "inwebc/Chapter 2/Command Line Arguments.w"
;
	
{
#line 103 "inwebc/Chapter 2/Command Line Arguments.w"
	if (in_string_eq(opt, "-weave")) {
		enter_main_mode(&args, WEAVE_MODE); continue;
	}
	if (in_string_eq(opt, "-open")) {
		args.open_pdf_switch = TRUE; enter_main_mode(&args, WEAVE_MODE); continue;
	}
	if (in_string_eq(opt, "-closed")) {
		args.open_pdf_switch = FALSE; enter_main_mode(&args, WEAVE_MODE); continue;
	}
	if (in_string_eq(opt, "-format")) {
		if (non_switch_follows) {
			in_strcpy(args.weave_format, argv[i+1]); i++;
			enter_main_mode(&args, WEAVE_MODE);
			continue;
		}
		fatal_error("-format must be followed by a format name");
	}
	if (in_string_eq(opt, "-theme")) {
		if (non_switch_follows) {
			in_strcpy(args.theme_setting, argv[i+1]); i++;
			enter_main_mode(&args, WEAVE_MODE);
			continue;
		}
		fatal_error("-theme must be followed by a chapter number or appendix letter");
	}

}
#line 82 "inwebc/Chapter 2/Command Line Arguments.w"
;
	
{
#line 132 "inwebc/Chapter 2/Command Line Arguments.w"
	if (in_string_eq(opt, "-tangle")) {
		enter_main_mode(&args, TANGLE_MODE); continue;
	}
	if (in_string_eq(opt, "-tangle-to")) {
		if (non_switch_follows) {
			in_strcpy(args.tangle_setting, argv[i+1]); i++;
			enter_main_mode(&args, TANGLE_MODE); continue;
		}
		fatal_error("-tangle-to must be followed by a filename to write");
	}

}
#line 83 "inwebc/Chapter 2/Command Line Arguments.w"
;
	
{
#line 147 "inwebc/Chapter 2/Command Line Arguments.w"
	if (in_string_eq(opt, "-create")) {
		enter_main_mode(&args, CREATE_MODE); continue;
	}

}
#line 84 "inwebc/Chapter 2/Command Line Arguments.w"
;
	fatal_error_with_parameter("unknown command line switch: %s", opt);

}
#line 58 "inwebc/Chapter 2/Command Line Arguments.w"

		else {
			if (args.chosen_web[0] == 0) in_sprintf(args.chosen_web, "%s/", opt);
			else 
{
#line 157 "inwebc/Chapter 2/Command Line Arguments.w"
	if (in_string_eq(opt, "index")) {
		args.swarm_mode = SWARM_INDEX;
	} else if (in_string_eq(opt, "chapters")) {
		args.swarm_mode = SWARM_CHAPTERS;
	} else if (in_string_eq(opt, "sections")) {
		args.swarm_mode = SWARM_SECTIONS;
	} else {
		if (++targets > 1) fatal_error("at most one target may be given");
		if (in_string_eq(opt, "all")) {
			in_strcpy(args.chosen_subweb, "0");
		} else if (((isalnum(opt[0])) && (opt[1] == 0)) || (pattern_match(opt, "%i+/%i+"))) {
			in_strcpy(args.chosen_subweb, opt);
			in_set(args.chosen_subweb, 0, toupper(args.chosen_subweb[0]));
		} else {
			string message;
			in_sprintf(message, "target not recognised: %s", opt);
			error_in_web(message, NULL);
			printf("The legal targets are:\n");
			printf("   all: complete web\n");
			printf("   P: all preliminaries\n");
			printf("   1: Chapter 1 (and so on)\n");
			printf("   A: Appendix A (and so on, up to Appendix O)\n");
			printf("   3/eg: section with abbreviated name \"3/eg\" (and so on)\n");
			printf("You can also, or instead, specify:\n");
			printf("   index: to weave an HTML page indexing the project\n");
			printf("   chapters: to weave all chapters as individual documents\n");
			printf("   sections: ditto with sections\n");
			exit(1);
		}
	}

}
#line 61 "inwebc/Chapter 2/Command Line Arguments.w"
;
		}
	}
	if (args.chosen_web[0] == 0) args.inweb_mode = NO_MODE;
	return args;
}

#line 191 "inwebc/Chapter 2/Command Line Arguments.w"
void enter_main_mode(inweb_instructions *args, int new_mode) {
	if (args->inweb_mode == NO_MODE) args->inweb_mode = new_mode;
	if (args->inweb_mode != new_mode)
		fatal_error("can only do one at a time - weaving, tangling or analysing");
}

#line 203 "inwebc/Chapter 2/Command Line Arguments.w"
void read_configuration_file(void) {
	in_strcpy(open_configuration, "");
	in_strcpy(tex_configuration, "tex");
	in_strcpy(pdftex_configuration, "pdftex");

	string config_filename;
	in_sprintf(config_filename,
		"%sinweb-configuration.txt", path_to_inweb_materials);
	file_read(config_filename, "can't open configuration file",
		TRUE, scan_config_line, NULL, NULL);
}

void scan_config_line(char *line, text_file_position *tfp, void *unused_state) {
	char *p = line;
	while (white_space(*p)) p++;
	if (p[0] == 0) return; /* skip blank lines */
	if (p[0] == '#') return; /* skip comment lines */
	int eq = 0, found = FALSE;
	for (eq = 0; p[eq]; eq++)
		if (p[eq] == '=') {
			found = TRUE;
			string setting; in_strcpy(setting, p); in_truncate(setting, eq);
			string value; in_strcpy(value, "");
			int k = eq-1;
			while ((k>=0) && (white_space(setting[k]))) in_truncate(setting, k--);
			eq++;
			while (white_space(p[eq])) eq++;
			in_strcpy(value, p+eq);
			
{
#line 243 "inwebc/Chapter 2/Command Line Arguments.w"
	if (in_string_eq(setting, "tex")) in_strcpy(tex_configuration, value);
	else if (in_string_eq(setting, "pdftex")) in_strcpy(pdftex_configuration, value);
	else if (in_string_eq(setting, "open-command")) in_strcpy(open_configuration, value);
	else {
		string message;
		in_sprintf(message, "inweb: bad configuration setting (%s)", setting);
		error_in_web(message, NULL);
	}

}
#line 231 "inwebc/Chapter 2/Command Line Arguments.w"
;
			break;
		}
	if (found == FALSE) {
		error_in_text_file("bad configuration line", tfp);
		fprintf(stderr, "  line: %s\n", line);
	}
}

#line 11 "inwebc/Chapter 2/Error Messages.w"
void fatal_error(char *message) {
	fatal_error_with_parameter("%s", message);
}

void fatal_error_with_parameter(char *message, char *parameter) {
	fprintf(stderr, "inweb: fatal error: ");
	fprintf(stderr, message, parameter);
	fprintf(stderr, "\n");
	free_memory(); /* note that this is unable to cause fatal errors */
	exit(2);
}

#line 27 "inwebc/Chapter 2/Error Messages.w"
void error_in_web(char *message, source_line *sl) {
	if (sl) {
		error_in_text_file(message, &(sl->source));
		fprintf(stderr, "%07d  %s\n", sl->source.line_count, sl->text);
	} else {
		error_in_text_file(message, NULL);
	}
}

void error_in_text_file(char *message, text_file_position *here) {
	if (here)
		error_at_position(message, here->text_file_filename, here->line_count);
	else
		error_at_position(message, NULL, 0);
}

void error_at_position(char *message, char *file, int line) {
	fprintf(stderr, "inweb: ");
	if (file) fprintf(stderr, "%s, line %d: ", file, line);
	fprintf(stderr, "%s\n", message);
	no_inweb_errors++;
}

#line 53 "inwebc/Chapter 2/Error Messages.w"
void fatal_filing_system_error(char *erm, char *fn) {
	string err;
	in_sprintf(err, "%s: file '%s'", erm, fn);
	fatal_error(err);
}

void nonfatal_filing_system_error(char *erm, char *fn) {
	string err;
	in_sprintf(err, "%s: file '%s'", erm, fn);
	error_in_text_file(err, NULL);
}

#line 21 "inwebc/Chapter 3/Bibliographic Data.w"

#line 30 "inwebc/Chapter 3/Bibliographic Data.w"
int bibliographic_datum_can_be_declared(web *W, char *key) {
	bibliographic_datum *bd = look_up_bibliographic_datum(W, key);
	if (bd == NULL) return FALSE;
	return bd->declaration_permitted;
}

int bibliographic_datum_on_or_off(web *W, char *key) {
	bibliographic_datum *bd = look_up_bibliographic_datum(W, key);
	if (bd == NULL) return FALSE;
	return bd->on_or_off;
}

#line 46 "inwebc/Chapter 3/Bibliographic Data.w"
void initialise_bibliographic_data(web *W) {
	bibliographic_datum *bd;
	bd = set_bibliographic_data(W, "Inweb Build", INWEB_BUILD); bd->declaration_permitted = FALSE;

	bd = set_bibliographic_data(W, "Author", ""); bd->declaration_mandatory = TRUE;
	bd = set_bibliographic_data(W, "Language", ""); bd->declaration_mandatory = TRUE;
	bd = set_bibliographic_data(W, "Purpose", ""); bd->declaration_mandatory = TRUE;
	bd = set_bibliographic_data(W, "Title", ""); bd->declaration_mandatory = TRUE;

	bd = set_bibliographic_data(W, "License", "");
	bd->alias = set_bibliographic_data(W, "Licence", ""); /* alias US to UK spelling */

	set_bibliographic_data(W, "Short Title", "");
	set_bibliographic_data(W, "Capitalized Title", "");
	set_bibliographic_data(W, "Build Date", "");
	set_bibliographic_data(W, "Build Number", "");
	set_bibliographic_data(W, "Index Extras", "");
	set_bibliographic_data(W, "Index Template", "");

	bd = set_bibliographic_data(W, "Declare Section Usage", "On"); bd->on_or_off = TRUE;
	bd = set_bibliographic_data(W, "Namespaces", "Off"); bd->on_or_off = TRUE;
	bd = set_bibliographic_data(W, "Strict Usage Rules", "Off"); bd->on_or_off = TRUE;
}

#line 74 "inwebc/Chapter 3/Bibliographic Data.w"
void check_required_bibliographic_data(web *W) {
	bibliographic_datum *bd;
	LOOP_OVER_BIBLIOGRAPHIC_DATA(bd, W)
		if ((bd->declaration_mandatory) &&
			(bd->value[0] == 0))
				fatal_error_with_parameter(
					"The Contents.w section does not specify '%s: ...'", bd->key);
}

#line 87 "inwebc/Chapter 3/Bibliographic Data.w"
char *get_bibliographic_data(web *W, char *key) {
	bibliographic_datum *bd = look_up_bibliographic_datum(W, key);
	if (bd) return bd->value;
	return "";
}

int bibliographic_data_exists(web *W, char *key) {
	bibliographic_datum *bd = look_up_bibliographic_datum(W, key);
	if ((bd) && (bd->value[0])) return TRUE;
	return FALSE;
}

bibliographic_datum *look_up_bibliographic_datum(web *W, char *key) {
	bibliographic_datum *bd;
	LOOP_OVER_BIBLIOGRAPHIC_DATA(bd, W)
		if (in_string_eq(key, bd->key)) {
			if (bd->alias) return bd->alias;
			return bd;
		}
	return NULL;
}

#line 114 "inwebc/Chapter 3/Bibliographic Data.w"
bibliographic_datum *set_bibliographic_data(web *W, char *key, char *val) {
	bibliographic_datum *bd = look_up_bibliographic_datum(W, key);
	if (bd == NULL) 
{
#line 126 "inwebc/Chapter 3/Bibliographic Data.w"
	bd = CREATE(bibliographic_datum);
	in_strcpy(bd->key, key);
	bd->declaration_mandatory = FALSE;
	bd->declaration_permitted = TRUE;
	bd->on_or_off = FALSE;
	bd->alias = NULL;
	bd->next_bd = W->first_bd;
	W->first_bd = bd;

}
#line 116 "inwebc/Chapter 3/Bibliographic Data.w"
;
	in_strcpy(bd->value, val);
	if (in_string_eq(key, "Title")) 
{
#line 141 "inwebc/Chapter 3/Bibliographic Data.w"
	string recapped; in_strcpy(recapped, val);
	for (int i=0; recapped[i]; i++) in_set(recapped, i, toupper(recapped[i]));
	set_bibliographic_data(W, "Capitalized Title", recapped);

}
#line 118 "inwebc/Chapter 3/Bibliographic Data.w"
;
	return bd;
}

#line 35 "inwebc/Chapter 3/Line Categories.w"

#line 39 "inwebc/Chapter 3/Line Categories.w"
source_line *new_source_line(char *line, text_file_position *tfp) {
	source_line *sl = CREATE(source_line);
	sl->text = new_string(line);
	sl->text_operand = "";
	sl->text_operand2 = "";

	sl->category = NO_LCAT; /* that is, unknown category as yet */
	sl->command_code = NO_CMD;
	sl->is_commentary = FALSE;
	sl->function_defined = NULL;
	sl->preform_nonterminal_defined = NULL;
	sl->suppress_tangling = FALSE;
	sl->interface_line_identified = FALSE;

	if (tfp) sl->source = *tfp; else sl->source = nowhere_position();

	sl->owning_section = NULL;
	sl->next_line = NULL;
	sl->owning_paragraph = NULL;
	return sl;
}

#line 96 "inwebc/Chapter 3/Line Categories.w"
char *category_name(int cat) {
	switch (cat) {
		case NO_LCAT: return "(uncategorised)";

		case BAR_LCAT: return "BAR";
		case BEGIN_DEFINITION_LCAT: return "BEGIN_DEFINITION";
		case BEGIN_VERBATIM_LCAT: return "BEGIN_CODE";
		case C_LIBRARY_INCLUDE_LCAT: return "C_LIBRARY_INCLUDE";
		case CHAPTER_HEADING_LCAT: return "CHAPTER_HEADING";
		case CODE_BODY_LCAT: return "CODE_BODY";
		case COMMAND_LCAT: return "COMMAND";
		case COMMENT_BODY_LCAT: return "COMMENT_BODY";
		case CONT_DEFINITION_LCAT: return "CONT_DEFINITION";
		case DEFINITIONS_LCAT: return "DEFINITIONS";
		case INTERFACE_BODY_LCAT: return "INTERFACE_BODY";
		case INTERFACE_LCAT: return "INTERFACE";
		case MACRO_DEFINITION_LCAT: return "MACRO_DEFINITION";
		case PARAGRAPH_START_LCAT: return "PARAGRAPH_START";
		case PB_PARAGRAPH_START_LCAT: return "PB_PARAGRAPH_START";
		case PREFORM_LCAT: return "PREFORM";
		case PREFORM_GRAMMAR_LCAT: return "PREFORM_GRAMMAR";
		case PURPOSE_LCAT: return "PURPOSE";
		case SECTION_HEADING_LCAT: return "SECTION_HEADING";
		case SOURCE_DISPLAY_LCAT: return "SOURCE_DISPLAY";
		case TEXT_EXTRACT_LCAT: return "TEXT_EXTRACT";
		case TOGGLE_WEAVING_LCAT: return "TOGGLE_WEAVING";
		case TYPEDEF_LCAT: return "TYPEDEF";
	}
	return "(?unknown)";
}

#line 48 "inwebc/Chapter 3/Reading Sections.w"

#line 52 "inwebc/Chapter 3/Reading Sections.w"
web *load_web(char *path, int verbosely) {
	web *W = CREATE(web);
	in_strcpy(W->path_to_web, path);
	W->chaptered = FALSE;
	W->first_chapter = NULL; W->last_chapter = NULL;
	W->first_c_structure = NULL; W->last_c_structure = NULL;
	W->first_bd = NULL;
	W->first_target = NULL;
	W->no_lines = 0; W->no_sections = 0; W->no_chapters = 0; W->no_paragraphs = 0;
	W->analysed = FALSE;
	initialise_bibliographic_data(W);
	add_tangle_target(W, C_LANGUAGE); /* the bulk of the web is automatically a target */
	read_contents_page(W, verbosely);
	parse_literate_source(W);
	return W;
}

#line 72 "inwebc/Chapter 3/Reading Sections.w"
void print_web_statistics(web *W) {
	printf("web \"%s\": ", get_bibliographic_data(W, "Title"));
	if (W->chaptered) printf("%d chapter(s) : ", W->no_chapters);
	printf("%d section(s) : %d paragraph(s) : %d line(s)\n",
		W->no_sections, W->no_paragraphs, W->no_lines);
}

#line 103 "inwebc/Chapter 3/Reading Sections.w"

#line 140 "inwebc/Chapter 3/Reading Sections.w"

#line 164 "inwebc/Chapter 3/Reading Sections.w"

#line 168 "inwebc/Chapter 3/Reading Sections.w"
void read_contents_page(web *W, int verbosely) {
	string pathname_of_contents;
	in_sprintf(pathname_of_contents, "%s%s", W->path_to_web, "Contents.w");

	reader_state RS;
	RS.current_web = W;
	RS.in_biblio = TRUE;
	RS.in_purpose = FALSE;
	RS.chapter_being_scanned = NULL;
	in_strcpy(RS.path_to_chapter_being_read, "");
	in_strcpy(RS.titling_line_to_insert, "");
	RS.scan_verbosely = verbosely;

	int cl = file_read(pathname_of_contents, "can't open contents file",
		TRUE, scan_biblio_line, NULL, &RS);
	if (verbosely) printf("Read contents section: '%s' (%d lines)\n", "Contents.w", cl);

	check_required_bibliographic_data(W);
}

#line 193 "inwebc/Chapter 3/Reading Sections.w"
void scan_biblio_line(char *line, text_file_position *tfp, void *X) {
	reader_state *RS = (reader_state *) X;
	int begins_with_white_space = FALSE;
	while (white_space(*line)) { begins_with_white_space = TRUE; line++; }
	int l = in_strlen(line) - 1;
	while ((l>=0) && (white_space(line[l]))) in_truncate(line, l--);

	if (line[0] == 0) 
{
#line 210 "inwebc/Chapter 3/Reading Sections.w"
	programming_language *pl =
		language_with_name(get_bibliographic_data(RS->current_web, "Language"));
	RS->current_web->main_language = pl;
	RS->current_web->first_target->tangle_language = pl;
	RS->in_biblio = FALSE;

}
#line 200 "inwebc/Chapter 3/Reading Sections.w"

	else if (RS->in_biblio) 
{
#line 220 "inwebc/Chapter 3/Reading Sections.w"
	if (pattern_match(line, "(%c+?): (%c+?) *")) {
		string key; in_strcpy(key, found_text1);
		string value; in_strcpy(value, found_text2);
		
{
#line 232 "inwebc/Chapter 3/Reading Sections.w"
	if (in_string_eq(key, "Weave")) {
		if (pattern_match(value, "(%c+?): (%c+?), (%c+?), (%c+?)")) {
			declare_tag_from_contents(RS->current_web,
				found_text1, found_text2, found_text3, found_text4);
		} else {
			string err; in_sprintf(err,
				"expected 'Weave: Tag: title, leafname, cover' but found '%s'", line);
			error_in_text_file(err, tfp);
		}
	} else if (bibliographic_datum_can_be_declared(RS->current_web, key)) {
		if (bibliographic_datum_on_or_off(RS->current_web, key)) {
			if ((in_string_ne(value, "On")) && (in_string_ne(value, "Off"))) {
				string err;
				in_sprintf(err, "this setting must be 'On' or 'Off': %s", key);
				error_in_text_file(err, tfp);
				in_strcpy(value, "Off");
			}
		}
		set_bibliographic_data(RS->current_web, key, value);
	} else {
		string err; in_sprintf(err, "no such bibliographic datum: %s", key);
		error_in_text_file(err, tfp);
	}

}
#line 223 "inwebc/Chapter 3/Reading Sections.w"
;
	} else {
		string err; in_sprintf(err, "expected 'Setting: Value' but found '%s'", line);
		error_in_text_file(err, tfp);
	}

}
#line 201 "inwebc/Chapter 3/Reading Sections.w"

	else 
{
#line 260 "inwebc/Chapter 3/Reading Sections.w"
	if (begins_with_white_space == FALSE) {
		if (*line == '"') { RS->in_purpose = TRUE; line++; }
		if (RS->in_purpose == TRUE) 
{
#line 271 "inwebc/Chapter 3/Reading Sections.w"
	if ((in_strlen(line) > 0) && (line[in_strlen(line)-1] == '"')) {
		in_truncate(line, in_strlen(line)-1); RS->in_purpose = FALSE;
	}
	if (RS->chapter_being_scanned) {
		char *r = RS->chapter_being_scanned->rubric;
		if (r[0]) in_strcat(r, " ");
		in_strcat(r, line);
	}

}
#line 262 "inwebc/Chapter 3/Reading Sections.w"

		else 
{
#line 283 "inwebc/Chapter 3/Reading Sections.w"
	string new_chapter_sigil; in_strcpy(new_chapter_sigil, ""); /* e.g., P, 1, 2, 3, A, B, ... */
	string pdf_leafname; in_strcpy(pdf_leafname, "");
	tangle_target *ind_target = RS->current_web->first_target;
	programming_language *ind_language = RS->current_web->main_language;

	if (pattern_match(line, "(%c*%C) %(Independent(%c*)%)")) {
		string title_alone; in_strcpy(title_alone, found_text1);
		string language_name; in_strcpy(language_name, found_text2);
		
{
#line 336 "inwebc/Chapter 3/Reading Sections.w"
	char *p = language_name;
	while (white_space(*p)) p++;
	if (*p == 0) p = get_bibliographic_data(RS->current_web, "Language");
	ind_language = language_with_name(p);
	ind_target = add_tangle_target(RS->current_web, ind_language);

}
#line 291 "inwebc/Chapter 3/Reading Sections.w"
;
		in_strcpy(line, title_alone);
	}

	if (in_string_eq(line, "Sections")) {
		in_strcpy(new_chapter_sigil, "S");
		in_sprintf(RS->path_to_chapter_being_read, "Sections%c", SEP_CHAR);
		in_strcpy(RS->titling_line_to_insert, "");
		in_strcpy(pdf_leafname, "Sections.pdf");
		RS->current_web->chaptered = FALSE;
	} else if (in_string_eq(line, "Preliminaries")) {
		in_strcpy(new_chapter_sigil, "P");
		in_sprintf(RS->path_to_chapter_being_read, "Preliminaries%c", SEP_CHAR);
		in_strcpy(RS->titling_line_to_insert, "");
		in_strcpy(pdf_leafname, "Preliminaries.pdf");
		RS->current_web->chaptered = TRUE;
	} else if (pattern_match(line, "Chapter (%d+): %c+")) {
		int n = atoi(found_text1);
		in_sprintf(new_chapter_sigil, "%d", n);
		in_sprintf(RS->path_to_chapter_being_read, "Chapter %d%c", n, SEP_CHAR);
		in_sprintf(RS->titling_line_to_insert, "%s.", line);
		in_sprintf(pdf_leafname, "Chapter-%d.pdf", n);
		RS->current_web->chaptered = TRUE;
	} else if (pattern_match(line, "Appendix (%c): %c+")) {
		string letter; in_strcpy(letter, "");
		in_strcpy(letter, found_text1);
		in_strcpy(new_chapter_sigil, letter);
		in_sprintf(RS->path_to_chapter_being_read, "Appendix %s%c", letter, SEP_CHAR);
		in_sprintf(RS->titling_line_to_insert, "%s.", line);
		in_sprintf(pdf_leafname, "Appendix-%s.pdf", letter);
		RS->current_web->chaptered = TRUE;
	} else {
		string err; in_sprintf(err, "segment not understood: %s", line);
		error_in_text_file(err, tfp);
		fprintf(stderr, "(Must be 'Chapter <number>: Title', "
			"'Appendix <letter A to O>: Title',\n");
		fprintf(stderr, "'Preliminaries' or 'Sections')\n");
	}

	
{
#line 345 "inwebc/Chapter 3/Reading Sections.w"
	chapter *C = CREATE(chapter);
	in_strcpy(C->ch_sigil, new_chapter_sigil);
	in_strcpy(C->ch_title, line);
	in_strcpy(C->rubric, "");
	C->ch_target = ind_target;
	C->ch_weave = NULL;
	C->ch_language = ind_language;
	C->ch_extent = 0;
	C->titling_line_inserted = FALSE;
	C->owning_web = RS->current_web;
	C->next_chapter = NULL;
	C->first_section = NULL; C->last_section = NULL;
	in_strcpy(C->woven_pdf_leafname, pdf_leafname);

	if (RS->current_web->first_chapter == NULL) {
		RS->current_web->first_chapter = C;
		RS->current_web->last_chapter = C;
	} else {
		RS->current_web->last_chapter->next_chapter = C;
		RS->current_web->last_chapter = C;
	}
	C->owning_web->no_chapters++;
	RS->chapter_being_scanned = C;

}
#line 330 "inwebc/Chapter 3/Reading Sections.w"
;

}
#line 263 "inwebc/Chapter 3/Reading Sections.w"
;
	} else 
{
#line 374 "inwebc/Chapter 3/Reading Sections.w"
	section *sect = CREATE(section);
	sect->owning_chapter = RS->chapter_being_scanned;
	sect->owning_chapter->owning_web->no_sections++;
	sect->next_section = NULL;

	sect->sect_extent = 0;
	sect->first_line = NULL; sect->last_line = NULL;
	sect->sect_paragraphs = 0;
	sect->first_paragraph = NULL; sect->last_paragraph = NULL;

	sect->scratch_flag = FALSE;
	sect->erroneous_interface = FALSE;
	sect->barred = FALSE;

	if (RS->chapter_being_scanned->first_section == NULL)
		RS->chapter_being_scanned->first_section = sect;
	else
		RS->chapter_being_scanned->last_section->next_section = sect;
	RS->chapter_being_scanned->last_section = sect;

	
{
#line 426 "inwebc/Chapter 3/Reading Sections.w"
	sect->sect_language = RS->chapter_being_scanned->ch_language; /* by default */
	if (pattern_match(line, "(%c*%C) %(Independent(%c*)%)")) {
		string title_alone; in_strcpy(title_alone, found_text1);
		string language_name; in_strcpy(language_name, found_text2);
		
{
#line 439 "inwebc/Chapter 3/Reading Sections.w"
	char *p = language_name;
	while (white_space(*p)) p++;
	if (*p == 0) p = get_bibliographic_data(RS->current_web, "Language");
	programming_language *pl = language_with_name(p);
	sect->sect_language = pl;
	sect->sect_target = add_tangle_target(RS->current_web, pl);

}
#line 430 "inwebc/Chapter 3/Reading Sections.w"
;
		in_strcpy(line, title_alone);
	} else {
		sect->sect_target = RS->chapter_being_scanned->ch_target;
	}

}
#line 394 "inwebc/Chapter 3/Reading Sections.w"
;
	sect->sect_weave = NULL;

	if (pattern_match(line, "(%c+) %[%[Tag: (%c+)%]%] *")) {
		in_strcpy(sect->sect_title, found_text1);
		sect->tag_with = add_tag_by_name(NULL, found_text2);
	} else {
		sect->tag_with = NULL;
		in_strcpy(sect->sect_title, line);
	}

	in_strcpy(sect->sect_namespace, "");

	in_sprintf(sect->leafname,
		"%s%s", sect->sect_title, sect->sect_language->source_file_extension);

	char *templ = strstr(sect->leafname, " Template.i6t");
	if (templ) in_strcpy(templ, ".i6t");

	in_sprintf(sect->pathname_relative_to_web,
		"%s%s", RS->path_to_chapter_being_read, sect->leafname);

	read_file(RS->current_web, sect->pathname_relative_to_web,
		RS->titling_line_to_insert, sect, RS->scan_verbosely);

}
#line 264 "inwebc/Chapter 3/Reading Sections.w"
;

}
#line 202 "inwebc/Chapter 3/Reading Sections.w"
;
}

#line 451 "inwebc/Chapter 3/Reading Sections.w"
void read_file(web *W, char *path_relative_to_web, char *titling_line, section *sect,
	int verbosely) {
	section *current_section = sect;

	string pathname; in_strcpy(pathname, "");
	in_sprintf(pathname, "%s%s", W->path_to_web, path_relative_to_web);

	if ((titling_line) && (titling_line[0]) &&
		(sect->owning_chapter->titling_line_inserted == FALSE)) {
		sect->owning_chapter->titling_line_inserted = TRUE;
		string line; in_strcpy(line, "");
		text_file_position *tfp = NULL;
		in_sprintf(line, "Chapter Heading");
		
{
#line 487 "inwebc/Chapter 3/Reading Sections.w"
	source_line *sl = new_source_line(line, tfp);

	/* enter this in its section's linked list of lines: */
	sl->owning_section = current_section;
	if (current_section->first_line == NULL) current_section->first_line = sl;
	else current_section->last_line->next_line = sl;
	current_section->last_line = sl;

	/* we haven't detected paragraph boundaries yet, so: */
	sl->owning_paragraph = NULL;

	/* and keep count: */
	sl->owning_section->sect_extent++;
	sl->owning_section->owning_chapter->ch_extent++;
	sl->owning_section->owning_chapter->owning_web->no_lines++;

}
#line 464 "inwebc/Chapter 3/Reading Sections.w"
;
	}

	int cl = file_read(pathname, "can't open section file", TRUE,
		scan_source_line, NULL, (void *) current_section);
	if (verbosely)
		printf("Read section: '%s' (%d lines)\n", sect->sect_title, cl);
}

#line 476 "inwebc/Chapter 3/Reading Sections.w"
void scan_source_line(char *line, text_file_position *tfp, void *state) {
	section *current_section = (section *) state;
	int l = in_strlen(line) - 1;
	while ((l>=0) && (white_space(line[l]))) in_truncate(line, l--);

	
{
#line 487 "inwebc/Chapter 3/Reading Sections.w"
	source_line *sl = new_source_line(line, tfp);

	/* enter this in its section's linked list of lines: */
	sl->owning_section = current_section;
	if (current_section->first_line == NULL) current_section->first_line = sl;
	else current_section->last_line->next_line = sl;
	current_section->last_line = sl;

	/* we haven't detected paragraph boundaries yet, so: */
	sl->owning_paragraph = NULL;

	/* and keep count: */
	sl->owning_section->sect_extent++;
	sl->owning_section->owning_chapter->ch_extent++;
	sl->owning_section->owning_chapter->owning_web->no_lines++;

}
#line 481 "inwebc/Chapter 3/Reading Sections.w"
;
}

#line 508 "inwebc/Chapter 3/Reading Sections.w"
void scan_line_categories(web *W, char *sigil) {
	printf("Scan of source lines for '%s'\n", sigil);
	int count = 1;
	chapter *C = get_chapter_for_sigil(W, sigil);
	if (C) {
		for (section *S = C->first_section; S; S = S->next_section)
			for (source_line *L = S->first_line; L; L = L->next_line)
				
{
#line 533 "inwebc/Chapter 3/Reading Sections.w"
	printf("%07d  %16s  %s\n", count++, category_name(L->category), L->text);

}
#line 515 "inwebc/Chapter 3/Reading Sections.w"
;
	} else {
		section *S = get_section_for_sigil(W, sigil);
		if (S) {
			for (source_line *L = S->first_line; L; L = L->next_line)
				
{
#line 533 "inwebc/Chapter 3/Reading Sections.w"
	printf("%07d  %16s  %s\n", count++, category_name(L->category), L->text);

}
#line 520 "inwebc/Chapter 3/Reading Sections.w"

		} else {
			for (chapter *C = W->first_chapter; C; C = C->next_chapter)
				for (section *S = C->first_section; S; S = S->next_section)
					for (source_line *L = S->first_line; L; L = L->next_line)
						
{
#line 533 "inwebc/Chapter 3/Reading Sections.w"
	printf("%07d  %16s  %s\n", count++, category_name(L->category), L->text);

}
#line 525 "inwebc/Chapter 3/Reading Sections.w"
;
		}
	}
}

#line 538 "inwebc/Chapter 3/Reading Sections.w"
chapter *get_chapter_for_sigil(web *W, char *sigil) {
	if (W)
		for (chapter *C = W->first_chapter; C; C = C->next_chapter)
			if (in_string_eq(C->ch_sigil, sigil))
				return C;
	return NULL;
}

section *get_section_for_sigil(web *W, char *sigil) {
	if (W)
		for (chapter *C = W->first_chapter; C; C = C->next_chapter)
			for (section *S = C->first_section; S; S = S->next_section)
				if (in_string_eq(S->sigil, sigil))
					return S;
	return NULL;
}

section *section_by_filename(web *W, char *filename) {
	if (W)
		for (chapter *C = W->first_chapter; C; C = C->next_chapter)
			for (section *S = C->first_section; S; S = S->next_section)
				if (in_string_eq(S->pathname_relative_to_web, filename))
					return S;
	return NULL;
}

#line 570 "inwebc/Chapter 3/Reading Sections.w"
int sigil_within(char *sig1, char *sig2) {
	if (in_string_eq(sig2, "0")) return TRUE;
	if (in_string_eq(sig1, sig2)) return TRUE;
	if (pattern_match(sig2, "%c+/%c+")) return FALSE;
	if (pattern_match(sig1, "(%c+)/%c+")) {
		if (in_string_eq(found_text1, sig2)) return TRUE;
	}
	return FALSE;
}

#line 597 "inwebc/Chapter 3/Reading Sections.w"

#line 601 "inwebc/Chapter 3/Reading Sections.w"
tangle_target *add_tangle_target(web *W, programming_language *language) {
	tangle_target *tt = CREATE(tangle_target);
	tt->tangle_language = language;
	tt->next_target = NULL;
	if (W->first_target == NULL) W->first_target = tt;
	else {
		tangle_target *tto = W->first_target;
		while ((tto) && (tto->next_target)) tto = tto->next_target;
		tto->next_target = tt;
	}
	return tt;
}

#line 9 "inwebc/Chapter 3/The Parser.w"
void parse_literate_source(web *W) {
	for (chapter *C = W->first_chapter; C; C = C->next_chapter)
		for (section *S = C->first_section; S; S = S->next_section) {
			int comment_mode = TRUE;
			int code_lcat_for_body = NO_LCAT;
			int before_bar = TRUE;
			int next_par_number = 1;
			paragraph *current_paragraph = NULL;
			for (source_line *L = S->first_line; L; L = L->next_line)
				
{
#line 35 "inwebc/Chapter 3/The Parser.w"
	L->is_commentary = comment_mode;
	L->category = COMMENT_BODY_LCAT; /* until set otherwise down below */
	L->owning_paragraph = current_paragraph;

	if (L->source.line_count == 0) 
{
#line 52 "inwebc/Chapter 3/The Parser.w"
	if (in_string_eq(L->text, "Chapter Heading")) {
		comment_mode = TRUE;
		L->is_commentary = TRUE;
		L->category = CHAPTER_HEADING_LCAT;
	}

}
#line 39 "inwebc/Chapter 3/The Parser.w"
;
	if (L->source.line_count == 1) 
{
#line 62 "inwebc/Chapter 3/The Parser.w"
	string rewritten; in_strcpy(rewritten, "");
	if ((S->sect_language == C_FOR_INFORM_LANGUAGE) &&
		(pattern_match(L->text, "(%C+) (%C+/%C+): (%c+)."))) {
		in_strcpy(S->sect_namespace, found_text1);
		in_strcpy(S->sigil, found_text2);
		in_strcpy(S->sect_title, found_text3);
		L->text_operand = new_string(found_text3);
		L->category = SECTION_HEADING_LCAT;
	} else if (pattern_match(L->text, "(%C+/%C+): (%c+).")) {
		in_strcpy(S->sigil, found_text1);
		in_strcpy(S->sect_title, found_text2);
		L->text_operand = new_string(found_text2);
		L->category = SECTION_HEADING_LCAT;
	}

}
#line 40 "inwebc/Chapter 3/The Parser.w"
;
	
{
#line 85 "inwebc/Chapter 3/The Parser.w"
	if (pattern_match(L->text, "%[%[(%c+)%]%]")) {
		string command_text; in_strcpy(command_text, found_text1);
		L->category = COMMAND_LCAT;
		if (pattern_match(command_text, "(%c+?): *(%c+)")) {
			in_strcpy(command_text, found_text1);
			L->text_operand = new_string(found_text2);
		}
		if (in_string_eq(command_text, "Page Break"))
			L->command_code = PAGEBREAK_CMD;
		else if ((S->sect_language == C_FOR_INFORM_LANGUAGE) &&
			(in_string_eq(command_text, "Grammar Index")))
			L->command_code = GRAMMAR_INDEX_CMD;
		else if (in_string_eq(command_text, "Tag")) {
			add_tag_by_name(L, L->text_operand);
			L->command_code = TAG_CMD;
		} else if (in_string_eq(command_text, "Figure")) {
			add_tag_by_name(L, "Figures");
			L->command_code = FIGURE_CMD;
		} else error_in_web("unknown [[command]]", L);
		L->is_commentary = TRUE;
	}

}
#line 41 "inwebc/Chapter 3/The Parser.w"
;
	
{
#line 112 "inwebc/Chapter 3/The Parser.w"
	if ((L->text[0] == '@') && (L->text[1] == '<') &&
		(pattern_match(L->text+2, "(%c+)@> *= *"))) {
		string cweb_macro_name; in_strcpy(cweb_macro_name, found_text1);
		L->category = MACRO_DEFINITION_LCAT;
		if (current_paragraph == NULL)
			error_in_web("<...> definition begins outside of a paragraph", L);
		else 
{
#line 141 "inwebc/Chapter 3/The Parser.w"
	cweb_macro *cwm = CREATE(cweb_macro);
	in_strcpy(cwm->macro_name, cweb_macro_name);
	cwm->defining_paragraph = current_paragraph;
	current_paragraph->defines_macro = cwm;
	cwm->defn_start = L->next_line;
	cwm->next_macro = NULL;
	cwm->macro_usages = NULL;

	if (S->first_macro == NULL) S->first_macro = cwm;
	else S->last_macro->next_macro = cwm;
	S->last_macro = cwm;

}
#line 118 "inwebc/Chapter 3/The Parser.w"
;
		comment_mode = FALSE;
		L->is_commentary = FALSE;
		code_lcat_for_body = CODE_BODY_LCAT; /* code follows on subsequent lines */
		continue;
	}

}
#line 42 "inwebc/Chapter 3/The Parser.w"
;
	if ((L->text[0] == '@') && (L->category != MACRO_DEFINITION_LCAT))
		
{
#line 157 "inwebc/Chapter 3/The Parser.w"
	string command_text;
	in_strcpy(command_text, L->text + 1); /* i.e., strip the at-sign from the front */
	char *remainder = "";
	for (int i = 0; command_text[i]; i++)
		if (white_space(command_text[i])) {
			in_truncate(command_text, i);
			remainder = command_text+i+1;
			while (white_space(*remainder)) remainder++;
			break;
		}
	
{
#line 174 "inwebc/Chapter 3/The Parser.w"
	if (in_string_eq(command_text, "Purpose:")) 
{
#line 194 "inwebc/Chapter 3/The Parser.w"
	if (before_bar == FALSE) error_in_web("Purpose used after bar", L);
	L->category = PURPOSE_LCAT;
	L->is_commentary = TRUE;
	L->text_operand = new_string(remainder);
	in_strcpy(S->sect_purpose, remainder);
	source_line *XL = L->next_line;
	while ((XL) && (XL->next_line) && (XL->owning_section == L->owning_section) &&
		(isalnum(XL->text[0]))) {
		in_strcat(S->sect_purpose, " ");
		in_strcat(S->sect_purpose, XL->text);
		XL->category = PURPOSE_BODY_LCAT;
		XL->is_commentary = TRUE;
		L = XL;
		XL = XL->next_line;
	}

}
#line 174 "inwebc/Chapter 3/The Parser.w"

	else if (in_string_eq(command_text, "Interface:")) 
{
#line 213 "inwebc/Chapter 3/The Parser.w"
	if (before_bar == FALSE) error_in_web("Interface used after bar", L);
	L->category = INTERFACE_LCAT;
	L->is_commentary = TRUE;
	source_line *XL = L->next_line;
	while ((XL) && (XL->next_line) && (XL->owning_section == L->owning_section)) {
		if (XL->text[0] == '@') break;
		XL->category = INTERFACE_BODY_LCAT;
		L = XL;
		XL = XL->next_line;
	}

}
#line 175 "inwebc/Chapter 3/The Parser.w"

	else if (in_string_eq(command_text, "Definitions:")) 
{
#line 227 "inwebc/Chapter 3/The Parser.w"
	if (before_bar == FALSE) error_in_web("Definitions used after bar", L);
	L->category = DEFINITIONS_LCAT;
	L->is_commentary = TRUE;
	before_bar = TRUE;
	next_par_number = 1;

}
#line 176 "inwebc/Chapter 3/The Parser.w"

	else if (pattern_match(command_text, "----+")) 
{
#line 237 "inwebc/Chapter 3/The Parser.w"
	if (before_bar == FALSE) error_in_web("second bar in the same section", L);
	L->category = BAR_LCAT;
	L->is_commentary = TRUE;
	comment_mode = TRUE;
	S->barred = TRUE;
	before_bar = FALSE;
	next_par_number = 1;

}
#line 177 "inwebc/Chapter 3/The Parser.w"

	else if ((in_string_eq(command_text, "c")) ||
			(in_string_eq(command_text, "e")) ||
			(in_string_eq(command_text, "x"))) 
{
#line 250 "inwebc/Chapter 3/The Parser.w"
	L->category = BEGIN_VERBATIM_LCAT;
	if ((in_string_eq(command_text, "e")) && (current_paragraph))
		current_paragraph->placed_early = TRUE;
	if (in_string_eq(command_text, "x")) code_lcat_for_body = TEXT_EXTRACT_LCAT;
	else code_lcat_for_body = CODE_BODY_LCAT;
	comment_mode = FALSE;

}
#line 180 "inwebc/Chapter 3/The Parser.w"

	else if (in_string_eq(command_text, "d")) 
{
#line 261 "inwebc/Chapter 3/The Parser.w"
	L->category = BEGIN_DEFINITION_LCAT;
	code_lcat_for_body = CONT_DEFINITION_LCAT;
	if (pattern_match(remainder, "(%C+) (%c+)")) {
		L->text_operand = new_string(found_text1); /* name of term defined */
		L->text_operand2 = new_string(found_text2); /* Value */
	} else {
		L->text_operand = new_string(remainder); /* name of term defined */
		L->text_operand2 = ""; /* no value given */
	}
	mark_reserved_word(S, L->text_operand, CONSTANT_CODE);
	comment_mode = FALSE;
	L->is_commentary = FALSE;

}
#line 181 "inwebc/Chapter 3/The Parser.w"

	else {
		int weight = -1, new_page = FALSE;
		if (in_string_eq(command_text, "")) weight = ORDINARY_WEIGHT;
		if (in_string_eq(command_text, "p")) weight = SUBHEADING_WEIGHT;
		if (in_string_eq(command_text, "pp")) { weight = SUBHEADING_WEIGHT; new_page = TRUE; }
		if (weight >= 0) 
{
#line 290 "inwebc/Chapter 3/The Parser.w"
	comment_mode = TRUE;
	L->is_commentary = TRUE;
	L->category = PARAGRAPH_START_LCAT;
	if (weight == 1) L->category = PB_PARAGRAPH_START_LCAT;
	L->text_operand = ""; /* title */
	if ((weight == SUBHEADING_WEIGHT) && (pattern_match(remainder, "(%c+). (%c+)"))) {
		L->text_operand = new_string(found_text1);
		L->text_operand2 = new_string(found_text2);
	} else if ((weight == SUBHEADING_WEIGHT) && (pattern_match(remainder, "(%c+). *"))) {
		L->text_operand = new_string(found_text1);
		L->text_operand2 = new_string("");
	} else {
		L->text_operand = new_string("");
		L->text_operand2 = new_string(remainder);
	}
	
{
#line 343 "inwebc/Chapter 3/The Parser.w"
	paragraph *P = CREATE(paragraph);
	P->above_bar = before_bar;
	P->placed_early = before_bar;
	if (before_bar) P->ornament = "P"; else P->ornament = "S";
	in_sprintf(P->paragraph_number, "%d", next_par_number++);
	P->parent_paragraph = NULL;
	P->next_child_number = 1;
	P->starts_on_new_page = FALSE;
	P->weight = weight;
	P->first_line_in_paragraph = L;
	P->next_paragraph_in_section = NULL;
	P->defines_macro = NULL;
	P->first_defined_in_paragraph = NULL;
	P->first_c_structure_in_para = NULL; P->last_c_structure_in_para = NULL;
	P->tags = NULL;

	P->under_section = S;
	S->sect_paragraphs++;
	if (S->first_paragraph) S->last_paragraph->next_paragraph_in_section = P;
	else S->first_paragraph = P;
	S->last_paragraph = P;

	current_paragraph = P;

}
#line 305 "inwebc/Chapter 3/The Parser.w"
;

	L->owning_paragraph = current_paragraph;
	W->no_paragraphs++;

}
#line 187 "inwebc/Chapter 3/The Parser.w"

		else error_in_web("don't understand @command", L);
	}

}
#line 167 "inwebc/Chapter 3/The Parser.w"
;
	continue;

}
#line 44 "inwebc/Chapter 3/The Parser.w"
;
	if (comment_mode) 
{
#line 373 "inwebc/Chapter 3/The Parser.w"
	if (pattern_match(L->text, ">> (%c+)")) {
		L->category = SOURCE_DISPLAY_LCAT;
		L->text_operand = new_string(found_text1);
	}

}
#line 45 "inwebc/Chapter 3/The Parser.w"
;
	if (comment_mode == FALSE) 
{
#line 383 "inwebc/Chapter 3/The Parser.w"
	if ((L->category != BEGIN_DEFINITION_LCAT) && (L->category != COMMAND_LCAT))
		L->category = code_lcat_for_body;

	if ((L->category == CONT_DEFINITION_LCAT) && (string_is_white_space(L->text))) {
		L->category = COMMENT_BODY_LCAT;
		L->is_commentary = TRUE;
		code_lcat_for_body = COMMENT_BODY_LCAT;
		comment_mode = TRUE;
	}

	language_subcategorise_code(S->sect_language, L);

}
#line 46 "inwebc/Chapter 3/The Parser.w"
;

}
#line 18 "inwebc/Chapter 3/The Parser.w"
;
		}
	for (chapter *C = W->first_chapter; C; C = C->next_chapter)
		for (section *S = C->first_section; S; S = S->next_section) {
			if (S->tag_with)
				for (paragraph *P = S->first_paragraph; P; P = P->next_paragraph_in_section)
					add_tag_to_para(P, S->tag_with, NULL);
			if (S->barred == FALSE)
				for (paragraph *P = S->first_paragraph; P; P = P->next_paragraph_in_section)
					P->ornament = "S";
		}
	language_further_parsing(W, W->main_language);
}

#line 136 "inwebc/Chapter 3/The Parser.w"

#line 339 "inwebc/Chapter 3/The Parser.w"

#line 402 "inwebc/Chapter 3/The Parser.w"
cweb_macro *get_cweb_macro_by_name(char *name, section *scope) {
	cweb_macro *cwm;
	for (cwm = scope->first_macro; cwm; cwm = cwm->next_macro)
		if (in_string_eq(name, cwm->macro_name))
			return cwm;
	return NULL;
}

#line 423 "inwebc/Chapter 3/The Parser.w"

#line 427 "inwebc/Chapter 3/The Parser.w"
theme_tag *tag_by_name(char *p) {
	theme_tag *tag;
	LOOP_OVER(tag, theme_tag)
		if (in_string_eq(p, tag->tag_name))
			return tag;
	return NULL;
}

#line 446 "inwebc/Chapter 3/The Parser.w"

#line 455 "inwebc/Chapter 3/The Parser.w"
theme_tag *declare_tag_from_contents(web *W, char *name, char *title, char *leaf, char *cover) {
	theme_tag *tag = add_tag_by_name(NULL, name);
	in_strcpy(tag->title_when_woven, title);
	in_strcpy(tag->leafname_when_woven, leaf);
	in_strcpy(tag->cover_sheet_when_woven, cover);
	language_new_tag_declared(tag);
	return tag;
}

#line 467 "inwebc/Chapter 3/The Parser.w"
theme_tag *add_tag_by_name(source_line *L, char *p) {
	string name; in_strcpy(name, p);
	string caption; in_strcpy(caption, "");
	if (pattern_match(name, "(%c+?): (%c+)")) {
		in_strcpy(name, found_text1);
		in_strcpy(caption, found_text2);
	}
	theme_tag *tag = tag_by_name(name);
	if (tag == NULL) 
{
#line 483 "inwebc/Chapter 3/The Parser.w"
	tag = CREATE(theme_tag);
	in_strcpy(tag->tag_name, name);
	in_strcpy(tag->title_when_woven, name);
	in_strcpy(tag->leafname_when_woven, name);
	in_strcpy(tag->cover_sheet_when_woven, "");

}
#line 475 "inwebc/Chapter 3/The Parser.w"
;
	if ((L) && (L->owning_paragraph)) add_tag_to_para(L->owning_paragraph, tag, caption);
	return tag;
}

#line 492 "inwebc/Chapter 3/The Parser.w"
void add_tag_to_para(paragraph *P, theme_tag *tag, char *caption) {
	if (P) {
		paragraph_tag *pt = CREATE(paragraph_tag);
		pt->the_tag = tag;
		if (caption) in_strcpy(pt->caption, caption);
		else in_strcpy(pt->caption, "");
		pt->next_tag = P->tags; P->tags = pt; /* insert at front of linked list */
	}
}

#line 505 "inwebc/Chapter 3/The Parser.w"
int is_tagged_with(source_line *L, theme_tag *tag) {
	if (tag == NULL) return TRUE;
	if (L)
		if (L->owning_paragraph)
			for (paragraph_tag *pt = L->owning_paragraph->tags; pt; pt = pt->next_tag)
				if (tag == pt->the_tag)
					return TRUE;
	return FALSE;
}

#line 16 "inwebc/Chapter 3/Paragraph Numbering.w"
void number_web(web *W) {
	for (chapter *C = W->first_chapter; C; C = C->next_chapter) {
		for (section *S = C->first_section; S; S = S->next_section) {
			
{
#line 28 "inwebc/Chapter 3/Paragraph Numbering.w"
	for (source_line *L = S->first_line; L; L = L->next_line) {
		char *p = L->text;
		int mlen, mpos;
		while ((mpos = find_expansion(p, '@', '<', '@', '>', &mlen)) != -1) {
			string found_macro;
			in_strcpy(found_macro, p+mpos+2); in_truncate(found_macro, mlen-4);
			p = p + mpos + mlen;
			cweb_macro *cwm = get_cweb_macro_by_name(found_macro, S);
			if (cwm) 
{
#line 61 "inwebc/Chapter 3/Paragraph Numbering.w"
	macro_usage *mu, *last = NULL;
	for (mu = cwm->macro_usages; mu; mu = mu->next_macro_usage) {
		last = mu;
		if (mu->used_in_paragraph == L->owning_paragraph)
			break;
	}
	if (mu == NULL) {
		mu = CREATE(macro_usage);
		mu->used_in_paragraph = L->owning_paragraph;
		mu->next_macro_usage = NULL;
		mu->multiplicity = 0;
		if (last) last->next_macro_usage = mu;
		else cwm->macro_usages = mu;
	}
	mu->multiplicity++;

}
#line 36 "inwebc/Chapter 3/Paragraph Numbering.w"
;
		}
	}

}
#line 19 "inwebc/Chapter 3/Paragraph Numbering.w"
;
			
{
#line 83 "inwebc/Chapter 3/Paragraph Numbering.w"
	
{
#line 91 "inwebc/Chapter 3/Paragraph Numbering.w"
	for (paragraph *P = S->first_paragraph; P; P = P->next_paragraph_in_section) {
		macro_usage *mu = (P->defines_macro)?(P->defines_macro->macro_usages):NULL;
		if (mu) P->parent_paragraph = mu->used_in_paragraph;
	}

}
#line 83 "inwebc/Chapter 3/Paragraph Numbering.w"
;
	
{
#line 99 "inwebc/Chapter 3/Paragraph Numbering.w"
	for (paragraph *P = S->first_paragraph; P; P = P->next_paragraph_in_section)
		if (P->parent_paragraph == NULL)
			for (paragraph *P2 = P; P2; P2 = P2->next_paragraph_in_section)
				if (P2->parent_paragraph) {
					if (P2->parent_paragraph->allocation_id < P->allocation_id)
						P->parent_paragraph = P2->parent_paragraph;
					break;
				}

}
#line 84 "inwebc/Chapter 3/Paragraph Numbering.w"
;
	
{
#line 113 "inwebc/Chapter 3/Paragraph Numbering.w"
	int top_level = 1;
	for (paragraph *P = S->first_paragraph; P; P = P->next_paragraph_in_section)
		if (P->parent_paragraph == NULL) {
			in_sprintf(P->paragraph_number, "%d", top_level++);
			P->next_child_number = 1;
		} else
			in_strcpy(P->paragraph_number, "");

}
#line 85 "inwebc/Chapter 3/Paragraph Numbering.w"
;
	
{
#line 124 "inwebc/Chapter 3/Paragraph Numbering.w"
	for (paragraph *P = S->first_paragraph; P; P = P->next_paragraph_in_section)
		settle_paragraph_number(P);

}
#line 86 "inwebc/Chapter 3/Paragraph Numbering.w"
;

}
#line 20 "inwebc/Chapter 3/Paragraph Numbering.w"
;
		}
	}
}

#line 57 "inwebc/Chapter 3/Paragraph Numbering.w"

#line 134 "inwebc/Chapter 3/Paragraph Numbering.w"
void settle_paragraph_number(paragraph *P) {
	if (P->paragraph_number[0]) return;
	in_strcpy(P->paragraph_number, "X"); /* to prevent malformed sections hanging this */
	if (P->parent_paragraph) settle_paragraph_number(P->parent_paragraph);
	in_sprintf(P->paragraph_number, "%s.%d", P->parent_paragraph->paragraph_number,
			P->parent_paragraph->next_child_number++);
	P->next_child_number = 1;
}

#line 13 "inwebc/Chapter 4/The Analyser.w"
void catalogue_the_sections(web *W, char *sigil, int functions_too) {
	for (chapter *C = W->first_chapter; C; C = C->next_chapter)
		if ((in_string_eq(sigil, "0")) || (in_string_eq(sigil, C->ch_sigil))) {
			printf("      %-9s  %-50s  \n", "--------", "--------");
			for (section *S = C->first_section; S; S = S->next_section) {
				string main_title;
				in_sprintf(main_title, "Chapter %s/%s", C->ch_sigil, S->sect_title);
				printf("%4d  %-9s  %-50s  ", S->sect_extent, S->sigil, main_title);
				language_analysis(S->sect_language, S, functions_too);
				printf("\n");
			}
		}
}

#line 51 "inwebc/Chapter 4/The Analyser.w"
void analyse_code(web *W) {
	if (W->analysed) return;

	
{
#line 81 "inwebc/Chapter 4/The Analyser.w"
	language_analyse_code(W->main_language, W);

	LOOP_WITHIN_TANGLE(W->first_target)
		if ((L->category == INTERFACE_BODY_LCAT) &&
			(L->interface_line_identified == FALSE) &&
			(string_is_white_space(L->text) == FALSE))
			error_in_web("unrecognised interface line", L);

}
#line 54 "inwebc/Chapter 4/The Analyser.w"
;

	LOOP_WITHIN_TANGLE(W->first_target)
		switch (L->category) {
			case BEGIN_DEFINITION_LCAT:
				
{
#line 97 "inwebc/Chapter 4/The Analyser.w"
	analyse_as_code(W, L, L->text_operand2, ANY_USAGE, 0);
	while ((L->next_line) && (L->next_line->category == CONT_DEFINITION_LCAT)) {
		L = L->next_line;
		analyse_as_code(W, L, L->text, ANY_USAGE, 0);
	}

}
#line 59 "inwebc/Chapter 4/The Analyser.w"
;
				break;
			case CODE_BODY_LCAT:
				
{
#line 92 "inwebc/Chapter 4/The Analyser.w"
	analyse_as_code(W, L, L->text, ANY_USAGE, 0);

}
#line 62 "inwebc/Chapter 4/The Analyser.w"
;
				break;
			case PREFORM_GRAMMAR_LCAT:
				
{
#line 110 "inwebc/Chapter 4/The Analyser.w"
	analyse_as_code(W, L, L->text_operand2, ANY_USAGE, 0);
	analyse_as_code(W, L, L->text_operand, PREFORM_IN_CODE_USAGE, PREFORM_IN_GRAMMAR_USAGE);

}
#line 65 "inwebc/Chapter 4/The Analyser.w"
;
				break;
		}

	language_post_analysis(W->main_language, W);
	W->analysed = TRUE;
}

#line 126 "inwebc/Chapter 4/The Analyser.w"
void analyse_as_code(web *W, source_line *L, char *text, int mask, int transf) {
	int start_at = -1, element_follows = FALSE;
	for (int i = 0; text[i]; i++) {
		if ((identifier_char(text[i])) || ((text[i] == '-') && (text[i+1] != '>'))) {
			if (start_at == -1) start_at = i;
		} else {
			if (start_at != -1) {
				int u = MISC_USAGE;
				if (element_follows) u = ELEMENT_ACCESS_USAGE;
				else if (text[i] == '(') u = FCALL_USAGE;
				else if ((text[i] == '>') && (start_at > 0) && (text[start_at-1] == '<'))
					u = PREFORM_IN_CODE_USAGE;
				if (u & mask) {
					if (transf) u = transf;
					string identifier_found; in_strcpy(identifier_found, "");
					int j;
					for (j = 0; start_at + j < i; j++)
						in_set(identifier_found, j, text[start_at + j]);
					in_truncate(identifier_found, j);
					analyse_find(W, L, identifier_found, u);
				}
				start_at = -1; element_follows = FALSE;
			}
			if (text[i] == '.') element_follows = TRUE;
			else if ((text[i] == '-') && (text[i+1] == '>')) {
				element_follows = TRUE; i++;
			} else element_follows = FALSE;
		}
	}
}

#line 168 "inwebc/Chapter 4/The Analyser.w"
int hash_code_from_word(char *text) {
    unsigned int hash_code = 0;
    char *p = text;
    switch(*p) {
    	case '-': if (p[1] == 0) break; /* an isolated minus sign is an ordinary word */
    		/* and otherwise fall into... */
    	case '0': case '1': case '2': case '3': case '4':
    	case '5': case '6': case '7': case '8': case '9':
    		/* the first character may prove to be the start of a number: is this true? */
			for (p++; *p; p++) if (isdigit(*p) == FALSE) break;
			return NUMBER_HASH;
    }
    for (p=text; *p; p++) hash_code = hash_code*30011 + (*p);
    return (int) (1+(hash_code % (HASH_TAB_SIZE-1))); /* result of X 30011, plus 1 */
}

#line 191 "inwebc/Chapter 4/The Analyser.w"

#line 203 "inwebc/Chapter 4/The Analyser.w"

#line 210 "inwebc/Chapter 4/The Analyser.w"
hash_table_entry *find_hash_entry(section *S, char *text, int create) {
	hash_table *HT = &(S->sect_target->symbols);
	int h = hash_code_from_word(text);
	if (h == NUMBER_HASH) return NULL;
	if (HT->analysis_hash_initialised == FALSE) {
		for (int i=0; i<HASH_TAB_SIZE; i++) HT->analysis_hash[i] = NULL;
		HT->analysis_hash_initialised = TRUE;
	}
	hash_table_entry *hte = NULL;
	for (hte = HT->analysis_hash[h]; hte; hte = hte->next_in_hash)
		if (in_string_eq(hte->hash_key, text))
			break;
	if ((hte == NULL) && (create)) {
		hte = CREATE(hash_table_entry);
		hte->hash_key = new_string(text);
		hte->next_in_hash = HT->analysis_hash[h];
		hte->first_usage = NULL;
		hte->last_usage = NULL;
		HT->analysis_hash[h] = hte;
	}
	return hte;
}

#line 236 "inwebc/Chapter 4/The Analyser.w"
void mark_reserved_word(section *S, char *p, int e) {
	hash_table_entry *hte = find_hash_entry(S, p, TRUE);
	hte->reserved_word |= (1 << e);
}

int is_reserved_word(section *S, char *p, int e) {
	hash_table_entry *hte = find_hash_entry(S, p, FALSE);
	if ((hte) && (hte->reserved_word & (1 << e))) return TRUE;
	return FALSE;
}

#line 261 "inwebc/Chapter 4/The Analyser.w"

#line 265 "inwebc/Chapter 4/The Analyser.w"
void analyse_find(web *W, source_line *L, char *identifier, int u) {
	hash_table_entry *hte = find_hash_entry(L->owning_section, identifier, FALSE);
	if (hte == NULL) return;
	hash_table_entry_usage *hteu = NULL;
	for (hteu = hte->first_usage; hteu; hteu = hteu->next_usage)
		if (L->owning_paragraph == hteu->usage_recorded_at)
			break;
	if (hteu == NULL) {
		hteu = CREATE(hash_table_entry_usage);
		hteu->form_of_usage = 0;
		hteu->next_usage = NULL;
		hteu->usage_recorded_at = L->owning_paragraph;
		if (hte->first_usage == NULL) hte->first_usage = hteu;
		else hte->last_usage->next_usage = hteu;
		hte->last_usage = hteu;
	}
	hteu->form_of_usage |= u;
}

#line 19 "inwebc/Chapter 4/The Swarm.w"
weave_target *swarm_leader = NULL; /* the most inclusive one we weave */

void weave_swarm(web *W, char *subweb, int swarm_mode, theme_tag *tag, char *format) {
	swarm_leader = NULL;

	if ((swarm_mode == SWARM_CHAPTERS) || (swarm_mode == SWARM_SECTIONS)) {
		/* weave Complete web */
		if (in_string_eq(subweb, "0"))
			swarm_leader = weave_subset_of_web(W, "0", FALSE, tag, format);

		for (chapter *C = W->first_chapter; C; C = C->next_chapter) {
			/* weave single chapter */
			if ((W->chaptered == TRUE) && (sigil_within(C->ch_sigil, subweb))) {
				C->ch_weave = weave_subset_of_web(W, C->ch_sigil, FALSE, tag, format);
				if (in_string_ne(subweb, "")) swarm_leader = C->ch_weave;
			}

			/* weave individual sections */
			for (section *S = C->first_section; S; S = S->next_section)
				if (sigil_within(S->sigil, subweb))
					S->sect_weave = weave_subset_of_web(W, S->sigil, FALSE, tag, format);
		}
	}

	weave_index_templates(W, subweb, format);
}

#line 51 "inwebc/Chapter 4/The Swarm.w"
weave_target *weave_subset_of_web(web *W, char *subweb, int open_afterwards, theme_tag *tag, char *format) {
	weave_target *wv = NULL;
	if (no_inweb_errors == 0) {
		analyse_code(W);
		
{
#line 82 "inwebc/Chapter 4/The Swarm.w"
	wv = CREATE(weave_target);
	wv->weave_web = W;
	in_strcpy(wv->weave_sigil, subweb);
	wv->theme_match = tag;
	in_strcpy(wv->booklet_title, "");
	wv->format = parse_format(format);
	wv->post_processing_results = NULL;
	if ((tag) && (tag->cover_sheet_when_woven[0]))
		in_sprintf(wv->cover_sheet_to_use, "%sMaterials%c%s",
			W->path_to_web, SEP_CHAR, wv->theme_match->cover_sheet_when_woven);
	else
		in_sprintf(wv->cover_sheet_to_use, "%scover-sheet", path_to_inweb_materials);

	string path_to_loom; in_sprintf(path_to_loom, "%sWoven%c", W->path_to_web, SEP_CHAR);

	string leafname; in_strcpy(leafname, "");
	
{
#line 105 "inwebc/Chapter 4/The Swarm.w"
	if (in_string_eq(subweb, "0")) {
		in_strcpy(wv->booklet_title, "Complete Program");
		in_strcpy(leafname, "Complete");
		if ((wv->theme_match) && (wv->theme_match->title_when_woven[0]))
			in_strcpy(wv->booklet_title, wv->theme_match->title_when_woven);
		if ((wv->theme_match) && (wv->theme_match->leafname_when_woven[0]))
			in_sprintf(leafname, "%s", wv->theme_match->leafname_when_woven);
	} else if (pattern_match(subweb, "%d+")) {
		in_sprintf(wv->booklet_title, "Chapter %s", subweb);
		in_strcpy(leafname, wv->booklet_title);
	} else if (pattern_match(subweb, "%[A-O]")) {
		in_sprintf(wv->booklet_title, "Appendix %s", subweb);
		in_strcpy(leafname, wv->booklet_title);
	} else if (in_string_eq(subweb, "P")) {
		in_strcpy(wv->booklet_title, "Preliminaries");
		in_strcpy(leafname, wv->booklet_title);
	} else {
		in_sprintf(wv->booklet_title, "%s", subweb);
		in_strcpy(leafname, wv->booklet_title);
		in_strcpy(wv->cover_sheet_to_use, "");
	}
	for (int i=0; leafname[i]; i++)
		if ((leafname[i] == '/') || (leafname[i] == ' '))
			in_set(leafname, i, '-');
	in_strcat(leafname, weave_file_extension(wv->format));

}
#line 98 "inwebc/Chapter 4/The Swarm.w"
;
	in_sprintf(wv->weave_to, "%s%s", path_to_loom, leafname);

}
#line 55 "inwebc/Chapter 4/The Swarm.w"
;
		if (weave_source(W, wv) == 0) /* i.e., the number of lines woven was zero */
			fatal_error("empty weave request");
		post_process_weave(wv, open_afterwards); /* e.g., run through |TeX| */
		
{
#line 134 "inwebc/Chapter 4/The Swarm.w"
	printf("[%s: %s", wv->booklet_title, wv->format->format_name);
	report_on_post_processing(wv);
	printf("]\n");

}
#line 59 "inwebc/Chapter 4/The Swarm.w"
;
	}
	return wv;
}

#line 78 "inwebc/Chapter 4/The Swarm.w"

#line 142 "inwebc/Chapter 4/The Swarm.w"
void weave_index_templates(web *W, char *subweb, char *format) {
	
{
#line 150 "inwebc/Chapter 4/The Swarm.w"
	string temp_list; in_strcpy(temp_list, "");
	string leaf; in_strcpy(leaf, "");
	if (bibliographic_data_exists(W, "Index Template"))
		in_strcpy(temp_list, get_bibliographic_data(W, "Index Template"));
	else {
		in_sprintf(temp_list, "%s", path_to_inweb_materials);
		if (index_pdfs(format)) {
			if (W->chaptered) in_sprcat(temp_list, "chaptered-tex-index.html");
			else in_sprcat(temp_list, "unchaptered-tex-index.html");
		} else {
			if (W->chaptered) in_sprcat(temp_list, "chaptered-index.html");
			else in_sprcat(temp_list, "unchaptered-index.html");
		}
		in_strcpy(leaf, "index.html");
	}
	while (temp_list[0]) {
		string index_to_make; in_strcpy(index_to_make, "");
		if (pattern_match(temp_list, "(%c+?), (%c+)")) {
			in_strcpy(index_to_make, found_text1);
			in_strcpy(temp_list, found_text2);
		} else {
			in_strcpy(index_to_make, temp_list);
			in_strcpy(temp_list, "");
		}
		if (leaf[0] == 0) {
			if (pattern_match(index_to_make, "%c+/(%c+?)"))
				in_strcpy(leaf, found_text1);
			else
				in_strcpy(leaf, index_to_make);
		}
		printf("Weaving index file: Woven/%s\n", leaf);
		run_contents_interpreter(W, subweb, index_to_make, leaf);
		in_strcpy(leaf, "");
	}

}
#line 143 "inwebc/Chapter 4/The Swarm.w"
;
	
{
#line 189 "inwebc/Chapter 4/The Swarm.w"
	string copy_list; in_strcpy(copy_list, "");
	if (bibliographic_data_exists(W, "Index Extras"))
		in_strcpy(copy_list, get_bibliographic_data(W, "Index Extras"));
	else
		in_sprintf(copy_list,
			"%sdownload.gif, %slemons.jpg, %scrumbs.gif, %sinweb.css",
			path_to_inweb_materials,
			path_to_inweb_materials,
			path_to_inweb_materials,
			path_to_inweb_materials);
	copy_files_into_weave(W, copy_list);

}
#line 144 "inwebc/Chapter 4/The Swarm.w"
;
}

#line 204 "inwebc/Chapter 4/The Swarm.w"
void copy_files_into_weave(web *W, char *copy_list) {
	while (in_string_ne(copy_list, "")) {
		string file_to_copy; in_strcpy(file_to_copy, "");
		if (pattern_match(copy_list, "(%c+?), (%c+)")) {
			in_strcpy(file_to_copy, found_text1);
			in_strcpy(copy_list, found_text2);
		} else {
			in_strcpy(file_to_copy, copy_list);
			in_strcpy(copy_list, "");
		}
		printf("Copying additional index file: %s\n", file_to_copy);
		issue_os_command_2("cp '%s' '%sWoven'", file_to_copy, W->path_to_web);
	}
}

#line 242 "inwebc/Chapter 4/The Swarm.w"

#line 246 "inwebc/Chapter 4/The Swarm.w"
contents_processor *cp = NULL;

void run_contents_interpreter(web *W, char *subset,
	char *path_to_template, char *contents_page_leafname) {
	contents_processor actual_cp; cp = &actual_cp;
	FILE *CONTS = NULL;
	cp->no_tlines = 0;
	cp->restrict_to_subweb = subset;
	
{
#line 283 "inwebc/Chapter 4/The Swarm.w"
	file_read(path_to_template, "can't find contents template", TRUE, save_template_line, NULL, NULL);
	if (TRACE_CI_EXECUTION)
		printf("Read template <%s>: %d line(s)\n",
			path_to_template, cp->no_tlines);

}
#line 254 "inwebc/Chapter 4/The Swarm.w"
;
	
{
#line 299 "inwebc/Chapter 4/The Swarm.w"
	string path_to_contents;
	in_sprintf(path_to_contents, "%sWoven%c%s", W->path_to_web, SEP_CHAR,
		contents_page_leafname);
	CONTS = fopen(path_to_contents, "w");
	if (CONTS == NULL) {
		fprintf(stderr, "inweb: warning: unable to generate index because can't "
			"open to write %s\n", path_to_contents);
		return;
	}

}
#line 255 "inwebc/Chapter 4/The Swarm.w"
;

	int lpos = 0; /* This is our program counter: a line number in the template */
	cp->stack_pointer = 0; /* And this is our stack pointer for tracking of loops */
	while (lpos < cp->no_tlines) {
		string tl;
		in_strcpy(tl, cp->tlines[lpos++]); /* Fetch the line at the program counter and advance */
		if (pattern_match(tl, "(%c*?) ")) in_strcpy(tl, found_text1); /* Strip trailing spaces */
		if (TRACE_CI_EXECUTION)
			
{
#line 312 "inwebc/Chapter 4/The Swarm.w"
	printf("%04d: %s\nStack:", lpos-1, tl);
	for (int j=0; j<cp->stack_pointer; j++) {
		if (cp->repeat_stack_level[j] == CHAPTER_LEVEL)
			printf(" %d: %s/%s",
				j, ((chapter *) cp->repeat_stack_variable[j])->ch_sigil,
				((chapter *) cp->repeat_stack_threshold[j])->ch_sigil);
		else if (cp->repeat_stack_level[j] == SECTION_LEVEL)
			printf(" %d: %s/%s",
				j, ((section *) cp->repeat_stack_variable[j])->sigil,
				((section *) cp->repeat_stack_threshold[j])->sigil);
	}
	printf("\n");

}
#line 264 "inwebc/Chapter 4/The Swarm.w"
;
		if ((pattern_match(tl, "%[%[(%c+)%]%]")) || (pattern_match(tl, " %[%[(%c+)%]%]"))) {
			string command; in_strcpy(command, found_text1);
			
{
#line 330 "inwebc/Chapter 4/The Swarm.w"
	if (pattern_match(command, "Select (%c*)")) {
		string sigil; in_strcpy(sigil, found_text1);
		section *S;
		LOOP_OVER(S, section)
			if (in_string_eq(S->sigil, sigil)) {
				start_CI_loop(SECTION_LEVEL, S, S, lpos);
				goto CYCLE;
			}
		chapter *C;
		LOOP_OVER(C, chapter)
			if (in_string_eq(C->ch_sigil, sigil)) {
				start_CI_loop(CHAPTER_LEVEL, C, C, lpos);
				goto CYCLE;
			}
		error_at_position("don't recognise the chapter or section abbreviation sigil",
			path_to_template, lpos);
		goto CYCLE;
	}

}
#line 267 "inwebc/Chapter 4/The Swarm.w"
;
			
{
#line 352 "inwebc/Chapter 4/The Swarm.w"
	int loop_level = 0;
	if (pattern_match(command, "Repeat Chapter")) loop_level = CHAPTER_LEVEL;
	if (pattern_match(command, "Repeat Section")) loop_level = SECTION_LEVEL;
	if (loop_level != 0) {
		void *from = NULL, *to = NULL;
		if (loop_level == CHAPTER_LEVEL) {
			from = FIRST_OBJECT(chapter);
			to = LAST_OBJECT(chapter);
			if (in_string_ne(cp->restrict_to_subweb, "0")) {
				chapter *C;
				LOOP_OVER(C, chapter)
					if (in_string_eq(C->ch_sigil, cp->restrict_to_subweb)) {
						from = C; to = C;
						break;
					}
			}
		}
		if (loop_level == SECTION_LEVEL) {
			chapter *within_chapter = heading_topmost_on_stack(CHAPTER_LEVEL);
			if (within_chapter == NULL) {
				from = FIRST_OBJECT(section);
				to = LAST_OBJECT(section);
			} else {
				from = within_chapter->first_section;
				to = within_chapter->last_section;
			}
		}
		if (from) start_CI_loop(loop_level, from, to, lpos);
		goto CYCLE;
	}

}
#line 268 "inwebc/Chapter 4/The Swarm.w"
;
			
{
#line 386 "inwebc/Chapter 4/The Swarm.w"
	if ((pattern_match(command, "End Repeat")) || (pattern_match(command, "End Select"))) {
		if (cp->stack_pointer <= 0)
			error_at_position("stack underflow on contents template", path_to_template, lpos);
		if (cp->repeat_stack_level[cp->stack_pointer-1] == SECTION_LEVEL) {
			section *S = cp->repeat_stack_variable[cp->stack_pointer-1];
			if (S == cp->repeat_stack_threshold[cp->stack_pointer-1])
				end_CI_loop();
			else {
				cp->repeat_stack_variable[cp->stack_pointer-1] = S->next_section;
				lpos = cp->repeat_stack_startpos[cp->stack_pointer-1]; /* Back round loop */
			}
		} else {
			chapter *C = cp->repeat_stack_variable[cp->stack_pointer-1];
			if (C == cp->repeat_stack_threshold[cp->stack_pointer-1])
				end_CI_loop();
			else {
				cp->repeat_stack_variable[cp->stack_pointer-1] = C->next_chapter;
				lpos = cp->repeat_stack_startpos[cp->stack_pointer-1]; /* Back round loop */
			}
		}
		goto CYCLE;
	}

}
#line 269 "inwebc/Chapter 4/The Swarm.w"
;
		}
		
{
#line 412 "inwebc/Chapter 4/The Swarm.w"
	for (int rstl = cp->stack_pointer-1; rstl >= 0; rstl--)
		if ((cp->repeat_stack_level[cp->stack_pointer-1] == SECTION_LEVEL) &&
			(((section *) cp->repeat_stack_threshold[cp->stack_pointer-1])->next_section ==
			cp->repeat_stack_variable[cp->stack_pointer-1]))
				goto CYCLE;

}
#line 271 "inwebc/Chapter 4/The Swarm.w"
;
		
{
#line 455 "inwebc/Chapter 4/The Swarm.w"
	int slen, spos;
	while ((spos = find_expansion(tl, '[', '[', ']', ']', &slen)) >= 0) {
		string left_part; in_strcpy(left_part, tl); in_truncate(left_part, spos);
		string varname; in_strcpy(varname, tl+spos+2); in_truncate(varname, slen-4);
		string substituted; in_strcpy(substituted, varname);
		string right_part; in_strcpy(right_part, tl+spos+slen);
		if (bibliographic_data_exists(W, varname)) {
			
{
#line 489 "inwebc/Chapter 4/The Swarm.w"
	in_strcpy(substituted, get_bibliographic_data(W, varname));

}
#line 462 "inwebc/Chapter 4/The Swarm.w"
;
		} else if (pattern_match(varname, "Chapter (%c+)")) {
			string detail; in_strcpy(detail, found_text1);
			chapter *C = heading_topmost_on_stack(CHAPTER_LEVEL);
			if (C == NULL)
				error_at_position("no chapter is currently selected",
					path_to_template, lpos);
			else 
{
#line 501 "inwebc/Chapter 4/The Swarm.w"
	if (in_string_eq(detail, "Title")) {
		in_strcpy(substituted, C->ch_title);
	} else if (in_string_eq(detail, "Code")) {
		in_strcpy(substituted, C->ch_sigil);
	} else if (in_string_eq(detail, "Purpose")) {
		in_strcpy(substituted, C->rubric);
	} else if (substitute_post_processing_data(substituted, C->ch_weave, detail)) {
		;
	} else {
		in_sprintf(substituted, "%s for %s", varname, C->ch_title);
	}

}
#line 469 "inwebc/Chapter 4/The Swarm.w"
;
		} else if (pattern_match(varname, "Section (%c+)")) {
			string detail; in_strcpy(detail, found_text1);
			section *S = heading_topmost_on_stack(SECTION_LEVEL);
			if (S == NULL)
				error_at_position("no section is currently selected",
					path_to_template, lpos);
			else 
{
#line 516 "inwebc/Chapter 4/The Swarm.w"
	if (in_string_eq(detail, "Title")) {
		in_strcpy(substituted, S->sect_title);
	} else if (in_string_eq(detail, "Purpose")) {
		in_strcpy(substituted, S->sect_purpose);
	} else if (in_string_eq(detail, "Code")) {
		in_strcpy(substituted, S->sigil);
	} else if (in_string_eq(detail, "Lines")) {
		in_sprintf(substituted, "%d", S->sect_extent);
	} else if (in_string_eq(detail, "Source")) {
		in_strcpy(substituted, S->pathname_relative_to_web);
	} else if (in_string_eq(detail, "Page")) {
		string linkto; in_strcpy(linkto, S->sigil);
		for (int i=0; linkto[i]; i++)
			if ((linkto[i] == '/') || (linkto[i] == ' '))
				in_set(linkto, i, '-');
		in_strcat(linkto, ".html");
		in_strcpy(substituted, linkto);
	} else if (in_string_eq(detail, "Paragraphs")) {
		in_sprintf(substituted, "%d", S->sect_paragraphs);
	} else if (in_string_eq(detail, "Mean")) {
		int denom = S->sect_paragraphs;
		if (denom == 0) denom = 1;
		in_sprintf(substituted, "%d", S->sect_extent/denom);
	} else if (substitute_post_processing_data(substituted, S->sect_weave, detail)) {
		;
	} else {
		in_sprintf(substituted, "%s for %s", varname, S->sect_title);
	}

}
#line 476 "inwebc/Chapter 4/The Swarm.w"
;
		} else if (pattern_match(varname, "Complete (%c+)")) {
			string detail; in_strcpy(detail, found_text1);
			
{
#line 494 "inwebc/Chapter 4/The Swarm.w"
	if (swarm_leader)
		if (substitute_post_processing_data(substituted, swarm_leader, detail) == FALSE)
			in_sprintf(substituted, "%s for complete web", detail);

}
#line 479 "inwebc/Chapter 4/The Swarm.w"
;
		} else {
			in_sprintf(substituted, "<b>%s</b>", varname);
		}
		in_sprintf(tl, "%s%s%s", left_part, substituted, right_part);
	}

}
#line 272 "inwebc/Chapter 4/The Swarm.w"
;
		fprintf(CONTS, "%s\n", tl); /* Copy the now finished line to the output */

		CYCLE: ;
	}
	fclose (CONTS);
}

#line 291 "inwebc/Chapter 4/The Swarm.w"
void save_template_line(char *line, text_file_position *tfp, void *unused_state) {
	if (cp->no_tlines < MAX_TEMPLATE_LINES)
		cp->tlines[cp->no_tlines++] = new_string(line);
}

#line 422 "inwebc/Chapter 4/The Swarm.w"
void *heading_topmost_on_stack(int level) {
	for (int rstl = cp->stack_pointer-1; rstl >= 0; rstl--)
		if (cp->repeat_stack_level[rstl] == level)
			return cp->repeat_stack_variable[rstl];
	return NULL;
}

#line 436 "inwebc/Chapter 4/The Swarm.w"
void start_CI_loop(int level, void *from, void *to, int pos) {
	if (cp->stack_pointer < CI_STACK_CAPACITY) {
		cp->repeat_stack_level[cp->stack_pointer] = level;
		cp->repeat_stack_variable[cp->stack_pointer] = from;
		cp->repeat_stack_threshold[cp->stack_pointer] = to;
		cp->repeat_stack_startpos[cp->stack_pointer++] = pos;
	}
}

void end_CI_loop(void) {
	cp->stack_pointer--;
}

#line 16 "inwebc/Chapter 4/The Weaver.w"
int weave_source(web *W, weave_target *wv) {
	FILE *F = fopen(wv->weave_to, "w");
	if (F == NULL)
		fatal_filing_system_error("can't open weave file for output", wv->weave_to);

	string banner;
	in_sprintf(banner, "Weave of '%s' generated by %s", wv->booklet_title, INWEB_BUILD);
	format_top(F, wv, banner);

	if (wv->cover_sheet_to_use[0]) 
{
#line 733 "inwebc/Chapter 4/The Weaver.w"
	set_bibliographic_data(W, "Booklet Title", wv->booklet_title);
	weave_cover_from(F, W, wv->cover_sheet_to_use, wv, WEAVE_FIRST_HALF);

}
#line 25 "inwebc/Chapter 4/The Weaver.w"
;
	int lines_woven = 0;
	
{
#line 41 "inwebc/Chapter 4/The Weaver.w"
	weaver_state state_at; weaver_state *state = &state_at;
	
{
#line 79 "inwebc/Chapter 4/The Weaver.w"
	state->kind_of_material = REGULAR_MATERIAL;
	state->line_break_pending = FALSE;
	state->weaving_suspended = FALSE;
	state->next_heading_without_vertical_skip = FALSE;
	state->show_section_toc_soon = FALSE;
	state->horizontal_rule_just_drawn = FALSE;
	state->last_extract_from = NULL;
	state->last_endnoted_para = NULL;
	state->substantive_comment = FALSE;
	in_strcpy(state->chaptermark, "");
	in_strcpy(state->sectionmark, "");

}
#line 42 "inwebc/Chapter 4/The Weaver.w"
;
	for (chapter *C = W->first_chapter; C; C = C->next_chapter) {
		in_strcpy(state->chaptermark, "");
		for (section *S = C->first_section; S; S = S->next_section)
			if (sigil_within(S->sigil, wv->weave_sigil))
				
{
#line 94 "inwebc/Chapter 4/The Weaver.w"
	language_begin_weave(S, wv);
	in_strcpy(state->sectionmark, "");
	paragraph *current_paragraph = NULL;
	for (source_line *L = S->first_line; L; L = L->next_line) {
		if ((is_tagged_with(L, wv->theme_match)) &&
			(language_skip_in_weaving(S->sect_language, wv, L) == FALSE)) {
			lines_woven++;

			/* In principle, all of these source lines should be woven, but... */
			
{
#line 131 "inwebc/Chapter 4/The Weaver.w"
	if (L->category == TOGGLE_WEAVING_LCAT) {
		if (state->weaving_suspended == FALSE) {
			format_code_note(F, wv, "...and so on...");
			state->weaving_suspended = TRUE;
			continue;
		}
		state->weaving_suspended = FALSE;
		continue;
	}
	if (state->weaving_suspended) continue;

}
#line 103 "inwebc/Chapter 4/The Weaver.w"
;
			
{
#line 145 "inwebc/Chapter 4/The Weaver.w"
	if (L->category == INTERFACE_BODY_LCAT) continue;
	if (L->category == PURPOSE_BODY_LCAT) continue;
	if (L->category == BEGIN_VERBATIM_LCAT) continue;

}
#line 104 "inwebc/Chapter 4/The Weaver.w"
;
			
{
#line 153 "inwebc/Chapter 4/The Weaver.w"
	if (L->category == COMMAND_LCAT) {
		if (L->command_code == PAGEBREAK_CMD) format_pagebreak(F, wv);
		if (L->command_code == GRAMMAR_INDEX_CMD) weave_grammar_index(F);
		if (L->command_code == FIGURE_CMD) 
{
#line 164 "inwebc/Chapter 4/The Weaver.w"
	char *figname = L->text_operand;
	if (pattern_match(figname, "(%d+)cm: (%c+)"))
		format_figure(F, wv, found_text2, atoi(found_text2));
	else
		format_figure(F, wv, figname, -1);

}
#line 156 "inwebc/Chapter 4/The Weaver.w"
;
		/* Otherwise assume it was a tangler command, and ignore it here */
		continue;
	}

}
#line 105 "inwebc/Chapter 4/The Weaver.w"
;

			/* Some of the more baroque front matter of a section... */
			
{
#line 176 "inwebc/Chapter 4/The Weaver.w"
	if (L->category == PURPOSE_LCAT) {
		format_subheading(F, wv, 2, "Purpose", S->sect_purpose);
		weave_table_of_contents(F, wv, S);
		continue;
	}

}
#line 108 "inwebc/Chapter 4/The Weaver.w"
;
			
{
#line 185 "inwebc/Chapter 4/The Weaver.w"
	if ((state->show_section_toc_soon == 1) && (string_is_white_space(L->text))) {
		state->show_section_toc_soon = FALSE;
		if (weave_table_of_contents(F, wv, S)) {
			state->horizontal_rule_just_drawn = TRUE;
		} else {
			state->horizontal_rule_just_drawn = FALSE;
		}
	}

}
#line 109 "inwebc/Chapter 4/The Weaver.w"
;
			
{
#line 200 "inwebc/Chapter 4/The Weaver.w"
	if (L->category == INTERFACE_LCAT) {
		state->horizontal_rule_just_drawn = FALSE;
		L = weave_interface_table_for_section(F, wv, L);
		continue;
	}

}
#line 110 "inwebc/Chapter 4/The Weaver.w"
;
			
{
#line 209 "inwebc/Chapter 4/The Weaver.w"
	if (L->category == DEFINITIONS_LCAT) {
		format_subheading(F, wv, 2, "Definitions", NULL);
		state->next_heading_without_vertical_skip = TRUE;
		state->horizontal_rule_just_drawn = FALSE;
		continue;
	}

}
#line 111 "inwebc/Chapter 4/The Weaver.w"
;
			
{
#line 220 "inwebc/Chapter 4/The Weaver.w"
	if (L->category == BAR_LCAT) {
		
{
#line 564 "inwebc/Chapter 4/The Weaver.w"
	int mode_now = state->kind_of_material;
	if (state->kind_of_material != REGULAR_MATERIAL) {
		state->kind_of_material = REGULAR_MATERIAL;
		format_change_mode(F, wv, mode_now, state->kind_of_material, TRUE);
	}
	if ((current_paragraph) && (current_paragraph != state->last_endnoted_para)) {
		state->last_endnoted_para = current_paragraph;
		show_endnotes_on_previous_paragraph(F, wv, current_paragraph);
	}
	if (L) current_paragraph = L->owning_paragraph;

}
#line 221 "inwebc/Chapter 4/The Weaver.w"
;
		state->kind_of_material = REGULAR_MATERIAL;
		state->next_heading_without_vertical_skip = TRUE;
		if (state->horizontal_rule_just_drawn == FALSE) format_bar(F, wv);
		continue;
	}

}
#line 112 "inwebc/Chapter 4/The Weaver.w"
;

			/* The crucial junction point between modes... */
			
{
#line 431 "inwebc/Chapter 4/The Weaver.w"
	if ((L->category == PB_PARAGRAPH_START_LCAT) ||
		(L->category == PARAGRAPH_START_LCAT) ||
		(L->category == CHAPTER_HEADING_LCAT) ||
		(L->category == SECTION_HEADING_LCAT)) {
		
{
#line 564 "inwebc/Chapter 4/The Weaver.w"
	int mode_now = state->kind_of_material;
	if (state->kind_of_material != REGULAR_MATERIAL) {
		state->kind_of_material = REGULAR_MATERIAL;
		format_change_mode(F, wv, mode_now, state->kind_of_material, TRUE);
	}
	if ((current_paragraph) && (current_paragraph != state->last_endnoted_para)) {
		state->last_endnoted_para = current_paragraph;
		show_endnotes_on_previous_paragraph(F, wv, current_paragraph);
	}
	if (L) current_paragraph = L->owning_paragraph;

}
#line 435 "inwebc/Chapter 4/The Weaver.w"
;
		if (wv->theme_match)
			
{
#line 487 "inwebc/Chapter 4/The Weaver.w"
	if ((L->owning_paragraph) &&
		(L->owning_paragraph->starts_on_new_page)) format_pagebreak(F, wv);

}
#line 437 "inwebc/Chapter 4/The Weaver.w"
;

		int weight = 0;
		if (L->category == PB_PARAGRAPH_START_LCAT) weight = 1;
		if (L->category == SECTION_HEADING_LCAT) weight = 2;
		if (L->category == CHAPTER_HEADING_LCAT) weight = 3;

		
{
#line 500 "inwebc/Chapter 4/The Weaver.w"
	if (weight == 3) {
		in_strcpy(state->chaptermark, L->text_operand);
		in_strcpy(state->sectionmark, "");
	}
	if (weight == 2) {
		in_strcpy(state->sectionmark, L->text_operand);
		if (S->sigil[0]) in_strcpy(state->chaptermark, S->sigil);
		if (in_string_ne(state->chaptermark, ""))
			in_sprintf(state->sectionmark, " - %s", L->text_operand);
	}

}
#line 444 "inwebc/Chapter 4/The Weaver.w"
;

		char *TeX_macro = "";
		
{
#line 527 "inwebc/Chapter 4/The Weaver.w"
	switch (weight) {
		case 0: TeX_macro = "weavesection"; break;
		case 1: TeX_macro = "weavesections"; break;
		case 2: TeX_macro = "weavesectionss"; break;
		default: TeX_macro = "weavesectionsss"; break;
	}
	if (wv->theme_match) 
{
#line 546 "inwebc/Chapter 4/The Weaver.w"
	switch (weight) {
		case 0: TeX_macro = "tweavesection"; break;
		case 1: TeX_macro = "tweavesections"; break;
		case 2: TeX_macro = "tweavesectionss"; break;
		default: TeX_macro = "tweavesectionsss"; break;
	}
	if (weight >= 0) { weight = 0; }
	if (state->last_extract_from != S) {
		state->last_extract_from = S;
		format_pagebreak(F, wv);
		string extr; in_sprintf(extr, "From %s: %s", C->ch_title, S->sect_title);
		format_subheading(F, wv, 1, extr, C->ch_title);
	}

}
#line 533 "inwebc/Chapter 4/The Weaver.w"
;
	if ((state->next_heading_without_vertical_skip) && (weight < 2)) {
		state->next_heading_without_vertical_skip = FALSE;
		switch (weight) {
			case 0: TeX_macro = "nsweavesection"; break;
			case 1: TeX_macro = "nsweavesections"; break;
		}
	}

}
#line 447 "inwebc/Chapter 4/The Weaver.w"
;

		string heading_text;
		if (weight == 3) {
			string brief_title; in_strcpy(brief_title, "");
			if (pattern_match(C->ch_title, "%c*?: (%c*)"))
				in_strcpy(brief_title, found_text1);
			else
				in_strcpy(brief_title, C->ch_title);
			in_sprintf(heading_text, "%s: %s", C->ch_sigil, brief_title);
		} else {
			in_strcpy(heading_text, L->text_operand);
		}

		format_paragraph_heading(F, wv, TeX_macro, S, L->owning_paragraph,
			heading_text, state->chaptermark, state->sectionmark, weight);

		if (weight == 0) state->substantive_comment = FALSE;
		else state->substantive_comment = TRUE;

		/* There's quite likely ordinary text on the line following the paragraph */
		/* start indication, too, so we need to weave this out: */

		if (in_string_ne(L->text_operand2, "")) {
			string matter;
			in_sprintf(matter, "%s\n", L->text_operand2);
			format_identifier(F, wv, matter);
			state->substantive_comment = TRUE;
		}

		/* Chapter headings get a chapter title page, or possibly pages, too: */
		if (weight == 3) format_chapter_tp(F, wv, C);

		/* And that completes the new paragraph opening. */
		continue;
	}

}
#line 115 "inwebc/Chapter 4/The Weaver.w"
;

			/* With all exotica dealt with, we now just have material to weave verbatim... */
			string matter; in_strcpy(matter, L->text);
			if (L->is_commentary) 
{
#line 235 "inwebc/Chapter 4/The Weaver.w"
	
{
#line 247 "inwebc/Chapter 4/The Weaver.w"
	if (L->category == SOURCE_DISPLAY_LCAT) {
		format_display_line(F, wv, L->text_operand);
		continue;
	}

}
#line 235 "inwebc/Chapter 4/The Weaver.w"
;
	
{
#line 256 "inwebc/Chapter 4/The Weaver.w"
	if (string_is_white_space(matter)) {
		if ((L->next_line) && (L->next_line->category == COMMENT_BODY_LCAT) &&
			(state->substantive_comment)) format_blank_line(F, wv, TRUE);
		continue;
	}

}
#line 236 "inwebc/Chapter 4/The Weaver.w"
;
	
{
#line 266 "inwebc/Chapter 4/The Weaver.w"
	if (pattern_match(matter, "%(...%) (%c*)")) { /* continue single */
		format_change_mode(F, wv, state->kind_of_material, REGULAR_MATERIAL,
			state->substantive_comment);
		state->kind_of_material = REGULAR_MATERIAL;
		format_item(F, wv, 1, "");
		in_strcpy(matter, found_text1);
	} else if (pattern_match(matter, "%(-...%) (%c*)")) { /* continue double */
		format_change_mode(F, wv, state->kind_of_material, REGULAR_MATERIAL,
			state->substantive_comment);
		state->kind_of_material = REGULAR_MATERIAL;
		format_item(F, wv, 2, "");
		in_strcpy(matter, found_text1);
	} else if (pattern_match(matter, "%((%i+)%) (%c*)")) { /* begin single */
		format_change_mode(F, wv, state->kind_of_material, REGULAR_MATERIAL,
			state->substantive_comment);
		state->kind_of_material = REGULAR_MATERIAL;
		format_item(F, wv, 1, found_text1);
		in_strcpy(matter, found_text2);
	} else if (pattern_match(matter, "%(-(%i+)%) (%c*)")) { /* begin double */
		format_change_mode(F, wv, state->kind_of_material, REGULAR_MATERIAL,
			state->substantive_comment);
		state->kind_of_material = REGULAR_MATERIAL;
		format_item(F, wv, 2, found_text1);
		in_strcpy(matter, found_text2);
	}

}
#line 237 "inwebc/Chapter 4/The Weaver.w"
;
	
{
#line 296 "inwebc/Chapter 4/The Weaver.w"
	if (pattern_match(matter, "\t|(%c*)|(%c*?)")) {
		if (state->kind_of_material != CODE_MATERIAL) {
			format_change_mode(F, wv, state->kind_of_material, CODE_MATERIAL, TRUE);
			state->kind_of_material = CODE_MATERIAL;
		}
		string original; in_strcpy(original, found_text1);
		in_strcpy(matter, found_text2);
		string colouring;
		for (int i=0; original[i]; i++) colouring[i] = PLAIN_CODE;
		colouring[in_strlen(original)] = 0;
		format_source_code(F, wv, 1, "", original, colouring, "", TRUE, TRUE, FALSE);
		format_identifier(F, wv, matter);
		continue;
	} else if (state->kind_of_material != REGULAR_MATERIAL) {
		format_change_mode(F, wv, state->kind_of_material, REGULAR_MATERIAL, TRUE);
		state->kind_of_material = REGULAR_MATERIAL;
	}

}
#line 238 "inwebc/Chapter 4/The Weaver.w"
;
	state->substantive_comment = TRUE;
	in_strcat(matter, "\n");
	format_identifier(F, wv, matter);
	continue;

}
#line 119 "inwebc/Chapter 4/The Weaver.w"

			else 
{
#line 320 "inwebc/Chapter 4/The Weaver.w"
	
{
#line 360 "inwebc/Chapter 4/The Weaver.w"
	int mode_now = state->kind_of_material;
	if (state->kind_of_material != CODE_MATERIAL) {
		if (L->category == MACRO_DEFINITION_LCAT)
			state->kind_of_material = MACRO_MATERIAL;
		else if ((L->category == BEGIN_DEFINITION_LCAT) ||
				(L->category == CONT_DEFINITION_LCAT))
			state->kind_of_material = DEFINITION_MATERIAL;
		else
			state->kind_of_material = CODE_MATERIAL;
		format_change_mode(F, wv, mode_now, state->kind_of_material,
			state->substantive_comment);
		state->line_break_pending = FALSE;
	}

}
#line 320 "inwebc/Chapter 4/The Weaver.w"
;
	
{
#line 378 "inwebc/Chapter 4/The Weaver.w"
	if (state->line_break_pending) {
		format_blank_line(F, wv, FALSE);
		state->line_break_pending = FALSE;
	}
	if (string_is_white_space(matter)) {
		state->line_break_pending = TRUE;
		continue;
	}

}
#line 321 "inwebc/Chapter 4/The Weaver.w"
;

	int tab_stops_of_indentation = 0;
	
{
#line 391 "inwebc/Chapter 4/The Weaver.w"
	int spaces_in = 0;
	while (white_space(matter[0])) {
		if (matter[0] == '\t') {
			spaces_in = 0;
			tab_stops_of_indentation++;
		} else {
			spaces_in++;
			if (spaces_in == 4) {
				tab_stops_of_indentation++;
				spaces_in = 0;
			}
		}
		in_strcpy(found_text1, matter+1);
		in_strcpy(matter, found_text1);
	}

}
#line 324 "inwebc/Chapter 4/The Weaver.w"
;

	string prefatory; in_strcpy(prefatory, "");
	string concluding_comment; in_strcpy(concluding_comment, "");
	
{
#line 412 "inwebc/Chapter 4/The Weaver.w"
	string part_before_comment; in_strcpy(part_before_comment, "");
	string part_within_comment; in_strcpy(part_within_comment, "");
	if (language_parse_comment(S->sect_language,
		matter, part_before_comment, part_within_comment)) {
		in_strcpy(matter, part_before_comment);
		in_strcpy(concluding_comment, part_within_comment);
	}

}
#line 328 "inwebc/Chapter 4/The Weaver.w"
;
	
{
#line 423 "inwebc/Chapter 4/The Weaver.w"
	if (pattern_match(matter, "@d (%c*)")) {
		in_strcpy(prefatory, "define");
		in_strcpy(matter, found_text1);
	}

}
#line 329 "inwebc/Chapter 4/The Weaver.w"
;

	if (language_weave_code_line(S->sect_language, F, wv,
		W, C, S, L, matter, concluding_comment)) continue;

	string colouring;
	language_syntax_colour(S->sect_language, F, wv, W, C, S, L, matter, colouring);

	int found = 0;
	while (pattern_match(matter, "(%c*?)%@%<(%c*?)%@%>(%c*)")) {
		in_strcpy(matter, found_text3);
		cweb_macro *cwm = get_cweb_macro_by_name(found_text2, S);
		format_source_code(F, wv, tab_stops_of_indentation, prefatory,
			found_text1, colouring, concluding_comment, (found == 0)?TRUE:FALSE, FALSE, TRUE);
		found++;
		int defn = (L->owning_paragraph == cwm->defining_paragraph)?TRUE:FALSE;
		string mac;
		format_cweb_macro(mac, wv, cwm, defn);
		fprintf(F, "%s", mac);
		if (defn) in_strcpy(matter, "");
		string temp; in_strcpy(temp, colouring);
		in_strcpy(colouring, temp+in_strlen(temp)-in_strlen(matter));
	}
	format_source_code(F, wv, tab_stops_of_indentation, prefatory,
		matter, colouring, concluding_comment, (found == 0)?TRUE:FALSE, TRUE, TRUE);

	continue;

}
#line 120 "inwebc/Chapter 4/The Weaver.w"
;
		}
	}
	source_line *L = NULL;
	
{
#line 564 "inwebc/Chapter 4/The Weaver.w"
	int mode_now = state->kind_of_material;
	if (state->kind_of_material != REGULAR_MATERIAL) {
		state->kind_of_material = REGULAR_MATERIAL;
		format_change_mode(F, wv, mode_now, state->kind_of_material, TRUE);
	}
	if ((current_paragraph) && (current_paragraph != state->last_endnoted_para)) {
		state->last_endnoted_para = current_paragraph;
		show_endnotes_on_previous_paragraph(F, wv, current_paragraph);
	}
	if (L) current_paragraph = L->owning_paragraph;

}
#line 124 "inwebc/Chapter 4/The Weaver.w"
;

}
#line 47 "inwebc/Chapter 4/The Weaver.w"
;
	}

}
#line 27 "inwebc/Chapter 4/The Weaver.w"
;
	if (wv->cover_sheet_to_use[0]) 
{
#line 739 "inwebc/Chapter 4/The Weaver.w"
	set_bibliographic_data(W, "Booklet Title", wv->booklet_title);
	weave_cover_from(F, W, wv->cover_sheet_to_use, wv, WEAVE_SECOND_HALF);

}
#line 28 "inwebc/Chapter 4/The Weaver.w"
;

	string rennab; /* which is |banner| backwards */
	in_sprintf(rennab, "End of weave: %d lines from a web of %d", lines_woven, W->no_lines);
	format_tail(F, wv, rennab);

	fclose(F);
	return lines_woven; /* number of lines woven */
}

#line 75 "inwebc/Chapter 4/The Weaver.w"

#line 579 "inwebc/Chapter 4/The Weaver.w"
void show_endnotes_on_previous_paragraph(FILE *F, weave_target *wv, paragraph *P) {
	if (P->defines_macro) {
		format_endnote(F, wv, 1);
		format_identifier(F, wv, "This code is ");
		int ct = 0;
		for (macro_usage *mu = P->defines_macro->macro_usages; mu; mu = mu->next_macro_usage)
			ct++;
		if (ct == 1) format_identifier(F, wv, "never used");
		else {
			int k = 0, used_flag = FALSE;
			for (macro_usage *mu = P->defines_macro->macro_usages; mu; mu = mu->next_macro_usage)
				if (P != mu->used_in_paragraph) {
					if (used_flag) {
						if (k < ct-1) format_identifier(F, wv, ", ");
						else format_identifier(F, wv, " and ");
					} else {
						format_identifier(F, wv, "used in ");
					}
					format_locale(F, wv, mu->used_in_paragraph, NULL);
					used_flag = TRUE; k++;
					switch (mu->multiplicity) {
						case 1: break;
						case 2: format_identifier(F, wv, " (twice)"); break;
						case 3: format_identifier(F, wv, " (three times)"); break;
						case 4: format_identifier(F, wv, " (four times)"); break;
						case 5: format_identifier(F, wv, " (five times)"); break;
						default: {
							string mt;
							in_sprcat(mt, " (%d times)", mu->multiplicity);
							format_identifier(F, wv, mt);
							break;
						}
					}
				}
		}
		format_identifier(F, wv, ".");
		format_endnote(F, wv, 2);
	}

	function *fn;
	for (fn = P->first_defined_in_paragraph; fn; fn = fn->next_defined_in_paragraph) {
		format_endnote(F, wv, 1);
		hash_table_entry *hte = find_hash_entry(fn->function_header_at->owning_section, fn->function_name, FALSE);
		format_identifier(F, wv, "The function ");
		format_identifier(F, wv, fn->function_name);
		int used_flag = FALSE;
		hash_table_entry_usage *hteu = NULL;
		section *last_cited_in = NULL;
		int count_under = 0;
		for (hteu = hte->first_usage; hteu; hteu = hteu->next_usage)
			if ((P != hteu->usage_recorded_at) &&
				(P->under_section == hteu->usage_recorded_at->under_section))
				
{
#line 683 "inwebc/Chapter 4/The Weaver.w"
	if (used_flag == FALSE) format_identifier(F, wv, " is used in ");
	used_flag = TRUE;
	section *S = hteu->usage_recorded_at->under_section;
	if ((S != last_cited_in) && (S != P->under_section)) {
		count_under = 0;
		if (last_cited_in) {
			if (last_cited_in != P->under_section) format_identifier(F, wv, "), ");
			else format_identifier(F, wv, ", ");
		}
		format_identifier(F, wv, hteu->usage_recorded_at->under_section->sigil);
		format_identifier(F, wv, " (");
	}
	if (count_under++ > 0) format_identifier(F, wv, ", ");
	format_locale(F, wv, hteu->usage_recorded_at, NULL);
	last_cited_in = hteu->usage_recorded_at->under_section;

}
#line 631 "inwebc/Chapter 4/The Weaver.w"
;
		for (hteu = hte->first_usage; hteu; hteu = hteu->next_usage)
			if (P->under_section != hteu->usage_recorded_at->under_section)
				
{
#line 683 "inwebc/Chapter 4/The Weaver.w"
	if (used_flag == FALSE) format_identifier(F, wv, " is used in ");
	used_flag = TRUE;
	section *S = hteu->usage_recorded_at->under_section;
	if ((S != last_cited_in) && (S != P->under_section)) {
		count_under = 0;
		if (last_cited_in) {
			if (last_cited_in != P->under_section) format_identifier(F, wv, "), ");
			else format_identifier(F, wv, ", ");
		}
		format_identifier(F, wv, hteu->usage_recorded_at->under_section->sigil);
		format_identifier(F, wv, " (");
	}
	if (count_under++ > 0) format_identifier(F, wv, ", ");
	format_locale(F, wv, hteu->usage_recorded_at, NULL);
	last_cited_in = hteu->usage_recorded_at->under_section;

}
#line 634 "inwebc/Chapter 4/The Weaver.w"
;
		if (used_flag == FALSE) format_identifier(F, wv, " appears nowhere else");
		if ((last_cited_in != P->under_section) && (last_cited_in))
			format_identifier(F, wv, ")");
		format_identifier(F, wv, ".");
		format_endnote(F, wv, 2);
	}

	c_structure *st;
	for (st = P->first_c_structure_in_para; st; st = st->next_c_structure_in_para) {
		format_endnote(F, wv, 1);
		format_identifier(F, wv, "The structure ");
		format_identifier(F, wv, st->structure_name);

		section *S;
		LOOP_OVER(S, section) S->scratch_flag = FALSE;
		for (structure_element *elt = st->first_element; elt; elt = elt->next_element) {
			hash_table_entry *hte = find_hash_entry(elt->element_created_at->owning_section, elt->element_name, FALSE);
			if (hte)
				for (hash_table_entry_usage *hteu = hte->first_usage; hteu; hteu = hteu->next_usage)
					if (hteu->form_of_usage & ELEMENT_ACCESS_USAGE)
						hteu->usage_recorded_at->under_section->scratch_flag = TRUE;
		}

		int usage_count = 0, external = 0;
		LOOP_OVER(S, section)
			if (S->scratch_flag) {
				usage_count++;
				if (S != P->under_section) external++;
			}
		if (external == 0) format_identifier(F, wv, " is private to this section");
		else {
			format_identifier(F, wv, " is accessed in ");
			int c = 0;
			LOOP_OVER(S, section)
				if ((S->scratch_flag) && (S != P->under_section)) {
					if (c++ > 0) format_identifier(F, wv, ", ");
					format_identifier(F, wv, S->sigil);
				}
			if (P->under_section->scratch_flag) format_identifier(F, wv, " and here");
		}
		format_identifier(F, wv, ".");
		format_endnote(F, wv, 2);
	}
}

#line 702 "inwebc/Chapter 4/The Weaver.w"
int weave_table_of_contents(FILE *F, weave_target *wv, section *S) {
	int noteworthy = 0;
	for (paragraph *P = S->first_paragraph; P; P = P->next_paragraph_in_section)
		if ((P->weight > 0) && ((S->barred == FALSE) || (P->above_bar == FALSE)))
			noteworthy++;
	if (noteworthy == 0) return FALSE;

	format_toc(F, wv, 1, S->sigil, "", NULL);
	noteworthy = 0;
	for (paragraph *P = S->first_paragraph; P; P = P->next_paragraph_in_section)
		if ((P->weight > 0) && ((S->barred == FALSE) || (P->above_bar == FALSE))) {
			if (noteworthy > 0) format_toc(F, wv, 2, "", "", NULL);
			paragraph *LP = NULL, *CP = P->next_paragraph_in_section;
			while ((CP) && (CP->weight == 0)) {
				LP = CP; CP = CP->next_paragraph_in_section;
			}
			string loc;
			in_sprintf(loc, "%s%s", P->ornament, P->paragraph_number);
			format_toc(F, wv, 3, loc, P->first_line_in_paragraph->text_operand, P);
			noteworthy++;
		}
	format_toc(F, wv, 4, "", "", NULL);
	return TRUE;
}

#line 750 "inwebc/Chapter 4/The Weaver.w"
FILE *WEAVE_COVER_TO = NULL;
int weave_cover_halves = 0;

int weave_cover_from(FILE *F, web *W, char *cs_filename, weave_target *wv, int halves) {
	int swc = weave_cover_halves;
	weave_cover_halves = halves;
	WEAVE_COVER_TO = F;
	string full_filename;
	in_sprintf(full_filename, "%s%s", cs_filename, weave_file_extension(wv->format));
	file_read(full_filename, "can't open cover sheet file", TRUE,
		scan_cover_line, NULL, (void *) wv);
	weave_cover_halves = swc;
	return 0;
}

void scan_cover_line(char *line, text_file_position *tfp, void *state) {
	int include = FALSE;
	if (((weave_cover_halves & WEAVE_FIRST_HALF) &&
			((weave_cover_halves & IN_SECOND_HALF) == 0)) ||
		((weave_cover_halves & WEAVE_SECOND_HALF) &&
			(weave_cover_halves & IN_SECOND_HALF))) include = TRUE;

	weave_target *wv = (weave_target *) state;
	string matter; in_strcpy(matter, line);
	while (pattern_match(matter, "(%c*?)%[%[(%c*?)%]%](%c*)")) {
		string left; in_strcpy(left, found_text1);
		string middle; in_strcpy(middle, found_text2);
		string right; in_strcpy(right, found_text3);
		fprintf(WEAVE_COVER_TO, "%s", left);
		if (in_string_eq(middle, "Code")) {
			weave_cover_halves |= IN_SECOND_HALF;
		} else if (in_string_eq(middle, "Cover Sheet")) {
			if ((include) && ((weave_cover_halves & IN_SECOND_HALF) == 0)) {
				string default_cs;
				in_sprintf(default_cs, "%scover-sheet", path_to_inweb_materials);
				weave_cover_from(WEAVE_COVER_TO, wv->weave_web, default_cs, wv, WEAVE_FIRST_HALF);
			}
		} else if (bibliographic_data_exists(wv->weave_web, middle)) {
			if (include)
				fprintf(WEAVE_COVER_TO, "%s", get_bibliographic_data(wv->weave_web, middle));
		} else {
			if (include) fprintf(WEAVE_COVER_TO, "%s", middle);
		}
		in_strcpy(matter, right);
	}
	if (include) fprintf(WEAVE_COVER_TO, "%s\n", matter);
}

#line 803 "inwebc/Chapter 4/The Weaver.w"
source_line *weave_interface_table_for_section(FILE *F, weave_target *wv, source_line *L) {
	if (SHOW_INTERFACES) {
		format_subheading(F, wv, 2, "Interface", NULL);
		format_change_mode(F, wv, REGULAR_MATERIAL, CODE_MATERIAL, TRUE);
	}
	source_line *CL = L->next_line, *LL = L;
	while ((CL) && (CL->next_line) &&
		(CL->owning_paragraph == L->owning_paragraph) &&
		(CL->category == COMMENT_BODY_LCAT)) {
		LL = CL;
		if ((SHOW_INTERFACES) && (string_is_white_space(CL->text) == FALSE)) {
			string colouring;
			for (int i=0; CL->text[i]; i++) colouring[i] = PLAIN_CODE;
			colouring[in_strlen(CL->text)] = 0;
			format_source_code(F, wv, 1, "", CL->text, colouring, "",
				TRUE, TRUE, TRUE);
		}
		CL = CL->next_line;
	}
	if (SHOW_INTERFACES) {
		format_change_mode(F, wv, CODE_MATERIAL, REGULAR_MATERIAL, TRUE);
	}
	return LL;
}

#line 16 "inwebc/Chapter 4/The Tangler.w"
void tangle_source(web *W, tangle_target *target, char *dest_file) {
	programming_language *lang = target->tangle_language;
	printf("  tangling <%s> (written in %s)\n", dest_file, lang->language_name);

	if (language_tangles(lang) == FALSE) /* for documentation webs, for instance */
		fatal_error_with_parameter("can't tangle material in the language", lang->language_name);

	FILE *F = fopen(dest_file, "w");
	if (F == NULL)
		fatal_filing_system_error("unable to open tangled file for output", dest_file);

	
{
#line 43 "inwebc/Chapter 4/The Tangler.w"
	/* (a) The shebang line, a header for scripting languages, and other heading matter */
	language_shebang(F, lang, W, target);

	/* (b) Results of |@d| declarations */
	
{
#line 69 "inwebc/Chapter 4/The Tangler.w"
	LOOP_WITHIN_TANGLE(target)
		if (L->category == BEGIN_DEFINITION_LCAT) {
			language_start_definition(F, lang,
				L->text_operand,
				L->text_operand2, S, L);
			while ((L->next_line) && (L->next_line->category == CONT_DEFINITION_LCAT)) {
				L = L->next_line;
				language_prolong_definition(F, lang, L->text, S, L);
			}
			language_end_definition(F, lang, S, L);
		}

}
#line 47 "inwebc/Chapter 4/The Tangler.w"
;

	/* (c) Miscellaneous automated C predeclarations */
	language_additional_predeclarations(F, lang, W);

	/* (d) Above-the-bar code from all of the sections (global variables, and such) */
	LOOP_OVER_PARAGRAPHS(target)
		if ((S->barred) && (P->placed_early) && (P->defines_macro == NULL))
			tangle_paragraph(F, P);

	/* (e) Below-the-bar code: the bulk of the program itself */
	LOOP_OVER_PARAGRAPHS(target)
		if (((S->barred == FALSE) || (P->placed_early == FALSE)) && (P->defines_macro == NULL))
			tangle_paragraph(F, P);

	/* (f) Opposite of the shebang: a footer */
	language_gnabehs(F, lang, W);

}
#line 27 "inwebc/Chapter 4/The Tangler.w"
;
	fclose(F);

	language_additional_tangling(lang, W, target);
}

#line 86 "inwebc/Chapter 4/The Tangler.w"
void tangle_paragraph(FILE *F, paragraph *P) {
	int contiguous = FALSE;
	for (source_line *L = P->first_line_in_paragraph;
		((L) && (L->owning_paragraph == P)); L = L->next_line) {
		if (language_will_insert_in_tangle(P->under_section->sect_language, L)) {
			
{
#line 109 "inwebc/Chapter 4/The Tangler.w"
	if (contiguous == FALSE) {
		contiguous = TRUE;
		language_insert_line_marker(F, P->under_section->sect_language, L);
	}

}
#line 91 "inwebc/Chapter 4/The Tangler.w"
;
			language_insert_in_tangle(F, P->under_section->sect_language, L);
		}
		if ((L->category != CODE_BODY_LCAT) || (L->suppress_tangling)) {
			contiguous = FALSE;
		} else {
			
{
#line 109 "inwebc/Chapter 4/The Tangler.w"
	if (contiguous == FALSE) {
		contiguous = TRUE;
		language_insert_line_marker(F, P->under_section->sect_language, L);
	}

}
#line 97 "inwebc/Chapter 4/The Tangler.w"
;
			tangle_code(F, L->text, P->under_section, L); fprintf(F, "\n");
		}
	}
}

#line 119 "inwebc/Chapter 4/The Tangler.w"
void tangle_code(FILE *F, char *original, section *S, source_line *L) {
	int mlen, slen;
	int mpos = find_expansion(original, '@', '<', '@', '>', &mlen);
	int spos = find_expansion(original, '[', '[', ']', ']', &slen);
	if ((mpos >= 0) && ((spos == -1) || (mpos <= spos)))
		
{
#line 150 "inwebc/Chapter 4/The Tangler.w"
	string temp; in_strcpy(temp, original); in_truncate(temp, mpos);
	language_tangle_code(F, S->sect_language, temp);

	programming_language *lang = S->sect_language;
	for (int i=0; i<mlen-4; i++) in_set(temp, i, original[mpos+2+i]); in_truncate(temp, mlen-4);
	cweb_macro *cwm = get_cweb_macro_by_name(temp, S);
	if (cwm) {
		language_before_macro_expansion(F, lang, cwm);
		tangle_paragraph(F, cwm->defining_paragraph);
		language_after_macro_expansion(F, lang, cwm);
		language_insert_line_marker(F, lang, L);
	} else {
		error_in_web("unknown macro", L);
		fprintf(stderr, "Macro is '%s'\n", temp);
		language_comment(F, lang, temp); /* recover by putting macro name in comment */
	}

	tangle_code(F, original + mpos + mlen, S, L);

}
#line 124 "inwebc/Chapter 4/The Tangler.w"

	else if (spos >= 0)
		
{
#line 185 "inwebc/Chapter 4/The Tangler.w"
	web *W = S->owning_chapter->owning_web;

	string temp; in_strcpy(temp, "");
	for (int i=0; i<spos; i++) in_set(temp, i, original[i]); in_truncate(temp, spos);
	language_tangle_code(F, S->sect_language, temp);

	for (int i=0; i<slen-4; i++) in_set(temp, i, original[spos+2+i]); in_truncate(temp, slen-4);
	if (language_special_data(F, S->sect_language, temp) == FALSE) {
		if (look_up_bibliographic_datum(W, temp))
			fprintf(F, "%s", get_bibliographic_data(W, temp));
		else
			fprintf(F, "[[%s]]", temp);
	}

	tangle_code(F, original + spos + slen, S, L);

}
#line 126 "inwebc/Chapter 4/The Tangler.w"

	else
		language_tangle_code(F, S->sect_language, original); /* this is usually what happens */
}

#line 53 "inwebc/Chapter 5/Programming Languages.w"
void create_programming_languages(void) {
	C_FOR_INFORM_LANGUAGE = new_language("C for Inform", ".c");
	C_FOR_INFORM_LANGUAGE->c_like = TRUE;
	C_LANGUAGE = new_language("C", ".c");
	C_LANGUAGE->c_like = TRUE;
	CPP_LANGUAGE = new_language("C++", ".cpp");
	CPP_LANGUAGE->c_like = TRUE;
	I6_LANGUAGE = new_language("Inform 6", ".i6");
	I6_LANGUAGE->source_file_extension = ".i6t";
	I7_LANGUAGE = new_language("Inform 7", ".i7x");
	PERL_LANGUAGE = new_language("Perl", ".pl");
	PERL_LANGUAGE->shebang = "#!/usr/bin/perl\n\n";
	PLAIN_LANGUAGE = new_language("Plain Text", ".txt");
	/* something of an exception: */
	NO_LANGUAGE = new_language("None", "");
}

#line 73 "inwebc/Chapter 5/Programming Languages.w"
programming_language *new_language(char *name, char *ext) {
	programming_language *pl = CREATE(programming_language);
	pl->language_name = name; pl->file_extension = ext;
	pl->shebang = ""; pl->c_like = FALSE;
	pl->source_file_extension = ".w";
	return pl;
}

#line 84 "inwebc/Chapter 5/Programming Languages.w"
programming_language *language_with_name(char *lname) {
	programming_language *pl;
	LOOP_OVER(pl, programming_language)
		if (in_string_eq(lname, pl->language_name))
			return pl;
	fatal_error_with_parameter("unsupported programming language '%s'", lname);
	return NULL;
}

#line 96 "inwebc/Chapter 5/Programming Languages.w"
int language_special_data(FILE *F, programming_language *pl, char *data) {
	if (pl == C_FOR_INFORM_LANGUAGE) return c_for_inform_special_data(F, data);
	return FALSE;
}

#line 107 "inwebc/Chapter 5/Programming Languages.w"
void language_further_parsing(web *W, programming_language *pl) {
	if (pl->c_like) c_like_further_parsing(W);
	if (pl == C_FOR_INFORM_LANGUAGE) c_for_inform_further_parsing(W);
}

void language_subcategorise_code(programming_language *pl, source_line *L) {
	if (pl->c_like) c_like_subcategorise_code(pl, L);
}

#line 120 "inwebc/Chapter 5/Programming Languages.w"
int language_tangles(programming_language *pl) {
	if (pl == NO_LANGUAGE) return FALSE;
	return TRUE;
}

#line 128 "inwebc/Chapter 5/Programming Languages.w"
void language_shebang(FILE *F, programming_language *pl, web *W, tangle_target *target) {
	fprintf(F, "%s", pl->shebang);
	if (pl != I7_LANGUAGE)
		language_comment(F, pl, "Tangled output generated by inweb-C: do not edit");
	if (pl->c_like) c_like_shebang(F, pl, W, target);
}

#line 143 "inwebc/Chapter 5/Programming Languages.w"
void language_start_definition(FILE *F, programming_language *pl,
	char *term, char *start, section *S, source_line *L) {
	if (pl->c_like) {
		fprintf(F, "#define %s ", term);
		tangle_code(F, start, S, L);
	} else if (pl == PERL_LANGUAGE) {
		fprintf(F, "%s = ", term);
		tangle_code(F, start, S, L);
	} else error_in_web("this programming language does not support @d", L);
}

void language_prolong_definition(FILE *F, programming_language *pl,
	char *more, section *S, source_line *L) {
	if (pl->c_like) {
		fprintf(F, "\\\n    ");
		tangle_code(F, more, S, L);
	} else error_in_web("this programming language does not support multiline @d", L);
}

void language_end_definition(FILE *F, programming_language *pl,
	section *S, source_line *L) {
	if (pl->c_like) fprintf(F, "\n");
	else if (pl == PERL_LANGUAGE) fprintf(F, "\n;\n");
}

#line 172 "inwebc/Chapter 5/Programming Languages.w"
void language_additional_predeclarations(FILE *F, programming_language *pl, web *W) {
	if (pl->c_like) c_like_additional_predeclarations(F, pl, W);
	if (pl == C_FOR_INFORM_LANGUAGE) c_for_inform_additional_predeclarations(F, W);
}

#line 183 "inwebc/Chapter 5/Programming Languages.w"
int language_will_insert_in_tangle(programming_language *pl, source_line *L) {
	if (pl == C_FOR_INFORM_LANGUAGE) return c_for_inform_will_insert_in_tangle(L);
	return FALSE;
}

void language_insert_in_tangle(FILE *F, programming_language *pl, source_line *L) {
	if (pl == C_FOR_INFORM_LANGUAGE) c_for_inform_insert_in_tangle(F, L);
}

#line 200 "inwebc/Chapter 5/Programming Languages.w"
void language_insert_line_marker(FILE *F, programming_language *pl, source_line *L) {
	if ((pl->c_like) || (pl == PERL_LANGUAGE)) c_like_insert_line_marker(F, pl, L);
}

#line 209 "inwebc/Chapter 5/Programming Languages.w"
void language_before_macro_expansion(FILE *F, programming_language *pl, cweb_macro *cwm) {
	if ((pl->c_like) || (pl == PERL_LANGUAGE)) c_like_before_macro_expansion(F, pl, cwm);
}

void language_after_macro_expansion(FILE *F, programming_language *pl, cweb_macro *cwm) {
	if ((pl->c_like) || (pl == PERL_LANGUAGE)) c_like_after_macro_expansion(F, pl, cwm);
}

#line 220 "inwebc/Chapter 5/Programming Languages.w"
void language_comment(FILE *F, programming_language *pl, char *comm) {
	if (pl->c_like) c_like_comment(F, pl, comm);
	if (pl == PERL_LANGUAGE) fprintf(F, "# %s\n", comm);
	if (pl == I6_LANGUAGE) fprintf(F, "! %s\n", comm);
	if (pl == I7_LANGUAGE) fprintf(F, "[%s]\n", comm);
}

#line 230 "inwebc/Chapter 5/Programming Languages.w"
int language_parse_comment(programming_language *pl,
	char *line, char *part_before_comment, char *part_within_comment) {
	if (pl->c_like)
		return c_like_parse_comment(pl, line, part_before_comment, part_within_comment);
	if (pl == PERL_LANGUAGE) {
		if (pattern_match(line, "# (%c*?) *")) {
			in_strcpy(part_before_comment, "");
			in_strcpy(part_within_comment, found_text1);
			return TRUE;
		}
		if (pattern_match(line, "(%c*) # (%c*?) *")) {
			in_strcpy(part_before_comment, found_text1);
			in_strcpy(part_within_comment, found_text2);
			return TRUE;
		}
	}
	return FALSE;
}

#line 254 "inwebc/Chapter 5/Programming Languages.w"
void language_tangle_code(FILE *F, programming_language *pl, char *original) {
	if (pl == C_FOR_INFORM_LANGUAGE) c_for_inform_tangle_code(F, original);
	else fprintf(F, "%s", original);
}

#line 262 "inwebc/Chapter 5/Programming Languages.w"
void language_gnabehs(FILE *F, programming_language *pl, web *W) {
	if (pl == C_FOR_INFORM_LANGUAGE) c_for_inform_gnabehs(F, W);
}

#line 271 "inwebc/Chapter 5/Programming Languages.w"
void language_additional_tangling(programming_language *pl, web *W, tangle_target *target) {
	if (pl == C_FOR_INFORM_LANGUAGE)
		c_for_inform_additional_tangling(pl, W, target);
}

#line 279 "inwebc/Chapter 5/Programming Languages.w"
void language_begin_weave(section *S, weave_target *wv) {
	if (S->sect_language->c_like) c_like_begin_weave(S, wv);
	if (S->sect_language == C_FOR_INFORM_LANGUAGE) c_for_inform_begin_weave(S, wv);
}

#line 287 "inwebc/Chapter 5/Programming Languages.w"
void language_new_tag_declared(theme_tag *tag) {
	c_for_inform_new_tag_declared(tag);
}

int language_skip_in_weaving(programming_language *pl, weave_target *wv, source_line *L) {
	if (pl == C_FOR_INFORM_LANGUAGE) return c_for_inform_skip_in_weaving(wv, L);
	return FALSE;
}

int language_syntax_colour(programming_language *pl, FILE *WEAVEOUT, weave_target *wv,
	web *W, chapter *C, section *S, source_line *L, char *matter, char *colouring) {
	in_strcpy(colouring, matter);
	for (int i=0; matter[i]; i++) colouring[i] = PLAIN_CODE;
	if (pl->c_like)
		if (c_like_syntax_colour(pl, WEAVEOUT, wv, W, C, S, L, matter, colouring))
			return TRUE;
	if (pl == C_FOR_INFORM_LANGUAGE)
		if (c_for_inform_syntax_colour(WEAVEOUT, wv, W, C, S, L, matter, colouring))
			return TRUE;
	return FALSE;
}

int language_weave_code_line(programming_language *pl, FILE *WEAVEOUT, weave_target *wv,
	web *W, chapter *C, section *S, source_line *L, char *matter, char *concluding_comment) {
	if (pl->c_like)
		if (c_like_weave_code_line(pl, WEAVEOUT, wv, W, C, S, L, matter, concluding_comment))
			return TRUE;
	if (pl == C_FOR_INFORM_LANGUAGE)
		if (c_for_inform_weave_code_line(WEAVEOUT, wv, W, C, S, L, matter, concluding_comment))
			return TRUE;
	return FALSE;
}

#line 323 "inwebc/Chapter 5/Programming Languages.w"
void language_analysis(programming_language *pl, section *S, int functions_too) {
	if (pl->c_like) c_like_analysis(pl, S, functions_too);
}

void language_analyse_code(programming_language *pl, web *W) {
	if (pl->c_like) c_like_analyse_code(pl, W);
	if (pl == C_FOR_INFORM_LANGUAGE) c_for_inform_analyse_code(pl, W);
}

void language_post_analysis(programming_language *pl, web *W) {
	if (pl->c_like) c_like_post_analysis(pl, W);
}

#line 108 "inwebc/Chapter 5/C-Like Languages.w"
void c_like_further_parsing(web *W) {
	
{
#line 121 "inwebc/Chapter 5/C-Like Languages.w"
	c_structure *current_bt = NULL;
	LOOP_WITHIN_TANGLE(W->first_target) {
		if (pattern_match(L->text, "typedef struct (%i+) %c*")) {
			string sname; in_strcpy(sname, found_text1);
			current_bt = attach_c_structure(W, sname, L);
			add_tag_by_name(L, "Structures");
		} else if (((L->text)[0] == '}') && (current_bt)) {
			current_bt->typedef_ends = L;
			current_bt = NULL;
		} else if ((current_bt) && (current_bt->typedef_ends == NULL)) {
			char *p = L->text;
			while (white_space(*p)) p++;
			char *modifier_patterns[] = {
				"(struct )(%C%c*)", "(signed )(%C%c*)", "(unsigned )(%C%c*)",
				"(short )(%C%c*)", "(long )(%C%c*)", "(static )(%C%c*)", NULL };
			int seek_modifiers = TRUE;
			while (seek_modifiers) {
				seek_modifiers = FALSE;
				for (int i = 0; modifier_patterns[i]; i++)
					if (pattern_match(p, modifier_patterns[i])) {
						p = found_text2;
						seek_modifiers = TRUE;
						break;
					}
			}
			if (*p != '/') {
				while ((*p) && (white_space(*p) == FALSE)) p++;
				while ((white_space(*p)) || (*p == '*') || (*p == '(') || (*p == ')')) p++;
				if (p[0]) {
					string elname; in_strcpy(elname, p);
					for (int i=0; elname[i]; i++)
						if (identifier_char(elname[i]) == FALSE)
							in_truncate(elname, i);
					mark_reserved_word(L->owning_section, elname, ELEMENT_CODE);
					structure_element *elt = CREATE(structure_element);
					in_strcpy(elt->element_name, elname);
					elt->next_element = NULL;
					elt->allow_sharing = FALSE;
					elt->element_created_at = L;
					if (W->main_language == C_FOR_INFORM_LANGUAGE) {
						if (in_string_eq(elname, "word_ref1")) elt->allow_sharing = TRUE;
						if (in_string_eq(elname, "word_ref2")) elt->allow_sharing = TRUE;
						if (in_string_eq(elname, "next")) elt->allow_sharing = TRUE;
						if (in_string_eq(elname, "down")) elt->allow_sharing = TRUE;
						if (in_string_eq(elname, "allocation_id")) elt->allow_sharing = TRUE;
					}
					if (current_bt->first_element == NULL)
						current_bt->first_element = elt;
					else
						current_bt->last_element->next_element = elt;
					current_bt->last_element = elt;
				}
			}
		} else if (pattern_match(L->text, "typedef char%c+")) {
			L->category = TYPEDEF_LCAT;
		}
	}

}
#line 109 "inwebc/Chapter 5/C-Like Languages.w"
;
	
{
#line 186 "inwebc/Chapter 5/C-Like Languages.w"
	c_structure *current_bt;
	LOOP_OVER(current_bt, c_structure) {
		for (source_line *L = current_bt->typedef_begins;
			((L) && (L != current_bt->typedef_ends));
			L = L->next_line)
			if (pattern_match(L->text, " struct (%i+) %i%c*"))
				
{
#line 198 "inwebc/Chapter 5/C-Like Languages.w"
	string used_structure; in_strcpy(used_structure, found_text1);
	for (c_structure *str = W->first_c_structure; str; str = str->next_c_structure)
		if ((str != current_bt) &&
			(in_string_eq(used_structure, str->structure_name))) {
			structure_dependence *dpd = CREATE(structure_dependence);
			dpd->incorporates = str;
			if (current_bt->first_dependence == NULL) {
				current_bt->first_dependence = dpd;
				current_bt->last_dependence = dpd;
			} else {
				current_bt->last_dependence->next_dependence = dpd;
				current_bt->last_dependence = dpd;
			}
		}

}
#line 192 "inwebc/Chapter 5/C-Like Languages.w"
;
	}

}
#line 110 "inwebc/Chapter 5/C-Like Languages.w"
;
	LOOP_WITHIN_TANGLE(W->first_target)
		if ((L->category == CODE_BODY_LCAT) ||
			(L->category == BEGIN_DEFINITION_LCAT) ||
			(L->category == CONT_DEFINITION_LCAT))
			
{
#line 298 "inwebc/Chapter 5/C-Like Languages.w"
	char *p = L->text;
	if (!(white_space(p[0]))) {
		string qualifiers; in_strcpy(qualifiers, "");
		string modified; in_strcpy(modified, "");
		
{
#line 345 "inwebc/Chapter 5/C-Like Languages.w"
	char *modifier_patterns[] = {
		"(signed )(%C%c*)", "(unsigned )(%C%c*)",
		"(short )(%C%c*)", "(long )(%C%c*)", "(static )(%C%c*)", NULL };
	int seek_modifiers = TRUE;
	while (seek_modifiers) {
		seek_modifiers = FALSE;
		for (int i = 0; modifier_patterns[i]; i++)
			if (pattern_match(p, modifier_patterns[i])) {
				in_strcat(qualifiers, found_text1);
				in_strcpy(modified, found_text2);
				p = modified; seek_modifiers = TRUE; break;
			}
	}

}
#line 302 "inwebc/Chapter 5/C-Like Languages.w"
;
		if (pattern_match(p, "(%i+) (%**)(%i+)%((%c*)")) {
			string ftype; in_strcpy(ftype, found_text1);
			string asts; in_strcpy(asts, found_text2);
			string fname; in_strcpy(fname, found_text3);
			string arguments; in_strcpy(arguments, found_text4);
			
{
#line 369 "inwebc/Chapter 5/C-Like Languages.w"
	source_line *AL = L;
	int arg_lc = 1;
	while ((AL) && (arg_lc <= MAX_ARG_LINES) && (find_open_brace(arguments) == -1)) {
		AL = AL->next_line;
		in_strcat(arguments, " ");
		in_strcat(arguments, AL->text);
		arg_lc++;
	}
	int n = find_open_brace(arguments);
	if (n >= 0) in_truncate(arguments, n);

}
#line 308 "inwebc/Chapter 5/C-Like Languages.w"
;
			mark_reserved_word(L->owning_section, fname, FUNCTION_CODE);

			function *fn = CREATE(function);
			in_strcpy(fn->function_name, fname);
			in_strcpy(fn->function_arguments, arguments);
			in_sprintf(fn->function_type, "%s%s %s", qualifiers, ftype, asts);
			fn->within_namespace = FALSE;
			fn->called_from_other_sections = FALSE;
			fn->call_freely = FALSE;
			if ((in_string_eq(fn->function_name, "isdigit")) &&
				(W->main_language == C_FOR_INFORM_LANGUAGE))
				fn->call_freely = TRUE;
			fn->function_header_at = L;
			fn->next_defined_in_paragraph = NULL;
			paragraph *P = L->owning_paragraph;
			if (P) {
				if (P->first_defined_in_paragraph == NULL)
					P->first_defined_in_paragraph = fn;
				else {
					function *ofn = P->first_defined_in_paragraph;
					while ((ofn) && (ofn->next_defined_in_paragraph))
						ofn = ofn->next_defined_in_paragraph;
					ofn->next_defined_in_paragraph = fn;
				}
			}
			L->function_defined = fn;
			if ((W->main_language == C_FOR_INFORM_LANGUAGE) &&
				(pattern_match(fname, "%c*::%c*"))) fn->within_namespace = TRUE;
		}
	}

}
#line 115 "inwebc/Chapter 5/C-Like Languages.w"
;
}

#line 216 "inwebc/Chapter 5/C-Like Languages.w"
c_structure *find_c_structure(web *W, char *name) {
	for (c_structure *str = W->first_c_structure; str; str = str->next_c_structure)
		if (in_string_eq(name, str->structure_name))
			return str;
	return NULL;
}

function *get_function_with_name(char *name) {
	function *fn;
	LOOP_OVER(fn, function)
		if (in_string_eq(name, fn->function_name))
			return fn;
	return NULL;
}

#line 234 "inwebc/Chapter 5/C-Like Languages.w"
c_structure *attach_c_structure(web *W, char *name, source_line *L) {
	c_structure *str = CREATE(c_structure);
	in_strcpy(str->structure_name, name);
	mark_reserved_word(L->owning_section, str->structure_name, RESERVED_CODE);
	str->typedef_begins = L;
	str->declared_owner = NULL;
	str->tangled = FALSE;
	str->typedef_ends = NULL;
	str->next_c_structure = NULL;
	str->next_c_structure_in_para = NULL;
	str->first_dependence = NULL;
	str->last_dependence = NULL;
	str->first_element = NULL;
	str->last_element = NULL;
	if (W->first_c_structure == NULL) {
		W->first_c_structure = str;
		W->last_c_structure = str;
	} else {
		W->last_c_structure->next_c_structure = str;
		W->last_c_structure = str;
	}
	paragraph *P = L->owning_paragraph;
	if (P) {
		if (P->first_c_structure_in_para == NULL) {
			P->first_c_structure_in_para = str;
			P->last_c_structure_in_para = str;
		} else {
			P->last_c_structure_in_para->next_c_structure_in_para = str;
			P->last_c_structure_in_para = str;
		}
	}
	str->next_cst_alphabetically = NULL;
	if (first_cst_alphabetically == NULL) first_cst_alphabetically = str;
	else {
		int placed = FALSE;
		c_structure *last = NULL;
		for (c_structure *seq = first_cst_alphabetically; seq;
			seq = seq->next_cst_alphabetically) {
			if (in_string_cmp(name, seq->structure_name) < 0) {
				if (seq == first_cst_alphabetically) {
					str->next_cst_alphabetically = first_cst_alphabetically;
					first_cst_alphabetically = str;
				} else {
					last->next_cst_alphabetically = str;
					str->next_cst_alphabetically = seq;
				}
				placed = TRUE;
				break;
			}
			last = seq;
		}
		if (placed == FALSE) last->next_cst_alphabetically = str;
	}
	return str;
}

#line 383 "inwebc/Chapter 5/C-Like Languages.w"
void c_like_subcategorise_code(programming_language *pl, source_line *L) {
	if (pattern_match(L->text, "#include <(%C+)>%c*")) {
		string library_file; in_strcpy(library_file, found_text1);
		char *ansi_libs[] = {
			"assert.h", "ctype.h", "errno.h", "float.h", "limits.h",
			"locale.h", "math.h", "setjmp.h", "signal.h", "stdarg.h",
			"stddef.h", "stdio.h", "stdlib.h", "string.h", "time.h",
			NULL
		};
		for (int j = 0; ansi_libs[j]; j++)
			if (in_string_eq(library_file, ansi_libs[j]))
				L->category = C_LIBRARY_INCLUDE_LCAT;
	}
}

#line 407 "inwebc/Chapter 5/C-Like Languages.w"
void c_like_shebang(FILE *F, programming_language *pl, web *W, tangle_target *target) {
	LOOP_WITHIN_TANGLE(target)
		if (L->category == C_LIBRARY_INCLUDE_LCAT) {
			tangle_code(F, L->text, S, L);
			fprintf(F, "\n");
		}
}

#line 419 "inwebc/Chapter 5/C-Like Languages.w"
void c_like_additional_predeclarations(FILE *F, programming_language *pl, web *W) {
	
{
#line 428 "inwebc/Chapter 5/C-Like Languages.w"
	LOOP_WITHIN_TANGLE(W->first_target)
		if (L->category == TYPEDEF_LCAT) {
			language_tangle_code(F, W->main_language, L->text);
			fprintf(F, "\n");
		}

}
#line 420 "inwebc/Chapter 5/C-Like Languages.w"
;
	
{
#line 455 "inwebc/Chapter 5/C-Like Languages.w"
	for (c_structure *str = W->first_c_structure; str; str = str->next_c_structure)
		str->tangled = FALSE;
	for (c_structure *str = W->first_c_structure; str; str = str->next_c_structure)
		tangle_structure(F, pl, str);

}
#line 421 "inwebc/Chapter 5/C-Like Languages.w"
;
	
{
#line 437 "inwebc/Chapter 5/C-Like Languages.w"
	LOOP_WITHIN_TANGLE(W->first_target)
		if (L->function_defined) {
			function *fn = L->function_defined;
			language_insert_line_marker(F, W->main_language, L);
			fprintf(F, "%s ", fn->function_type);
			language_tangle_code(F, W->main_language, fn->function_name);
			fprintf(F, "(%s;\n", fn->function_arguments);
		}

}
#line 422 "inwebc/Chapter 5/C-Like Languages.w"
;
}

#line 463 "inwebc/Chapter 5/C-Like Languages.w"
void tangle_structure(FILE *F, programming_language *pl, c_structure *str) {
	if (str->tangled != FALSE) return;
	str->tangled = UNKNOWN;
	for (structure_dependence *dpd = str->first_dependence; dpd; dpd = dpd->next_dependence)
		tangle_structure(F, pl, dpd->incorporates);
	str->tangled = TRUE;
	language_insert_line_marker(F, pl, str->typedef_begins);
	for (source_line *L = str->typedef_begins; L; L = L->next_line) {
		fprintf(F, "%s\n", L->text);
		L->suppress_tangling = TRUE;
		if (L == str->typedef_ends) break;
	}
}

#line 485 "inwebc/Chapter 5/C-Like Languages.w"
void c_like_insert_line_marker(FILE *F, programming_language *pl, source_line *L) {
	fprintf(F, "#line %d \"%s\"\n",
		L->source.line_count,
		L->source.text_file_filename);
}

#line 494 "inwebc/Chapter 5/C-Like Languages.w"
void c_like_comment(FILE *F, programming_language *pl, char *comm) {
	fprintf(F, "/* %s */\n", comm);
}

#line 501 "inwebc/Chapter 5/C-Like Languages.w"
int c_like_parse_comment(programming_language *pl,
	char *line, char *part_before_comment, char *part_within_comment) {
	if (pattern_match(line, "(%c*)/%* *(%c*?) *%*/ *")) {
		in_strcpy(part_before_comment, found_text1);
		in_strcpy(part_within_comment, found_text2);
		return TRUE;
	}
	return FALSE;
}

#line 529 "inwebc/Chapter 5/C-Like Languages.w"
void c_like_before_macro_expansion(FILE *F, programming_language *pl, cweb_macro *cwm) {
	fprintf(F, "\n{\n");
}

void c_like_after_macro_expansion(FILE *F, programming_language *pl, cweb_macro *cwm) {
	fprintf(F, "}\n");
}

#line 541 "inwebc/Chapter 5/C-Like Languages.w"
void c_like_begin_weave(section *S, weave_target *wv) {
	mark_reserved_word(S, "FILE", RESERVED_CODE);

	mark_reserved_word(S, "auto", RESERVED_CODE);
	mark_reserved_word(S, "break", RESERVED_CODE);
	mark_reserved_word(S, "case", RESERVED_CODE);
	mark_reserved_word(S, "char", RESERVED_CODE);
	mark_reserved_word(S, "const", RESERVED_CODE);
	mark_reserved_word(S, "continue", RESERVED_CODE);
	mark_reserved_word(S, "default", RESERVED_CODE);
	mark_reserved_word(S, "do", RESERVED_CODE);
	mark_reserved_word(S, "double", RESERVED_CODE);
	mark_reserved_word(S, "else", RESERVED_CODE);
	mark_reserved_word(S, "enum", RESERVED_CODE);
	mark_reserved_word(S, "extern", RESERVED_CODE);
	mark_reserved_word(S, "float", RESERVED_CODE);
	mark_reserved_word(S, "for", RESERVED_CODE);
	mark_reserved_word(S, "goto", RESERVED_CODE);
	mark_reserved_word(S, "if", RESERVED_CODE);
	mark_reserved_word(S, "int", RESERVED_CODE);
	mark_reserved_word(S, "long", RESERVED_CODE);
	mark_reserved_word(S, "register", RESERVED_CODE);
	mark_reserved_word(S, "return", RESERVED_CODE);
	mark_reserved_word(S, "short", RESERVED_CODE);
	mark_reserved_word(S, "signed", RESERVED_CODE);
	mark_reserved_word(S, "sizeof", RESERVED_CODE);
	mark_reserved_word(S, "static", RESERVED_CODE);
	mark_reserved_word(S, "struct", RESERVED_CODE);
	mark_reserved_word(S, "switch", RESERVED_CODE);
	mark_reserved_word(S, "typedef", RESERVED_CODE);
	mark_reserved_word(S, "union", RESERVED_CODE);
	mark_reserved_word(S, "unsigned", RESERVED_CODE);
	mark_reserved_word(S, "void", RESERVED_CODE);
	mark_reserved_word(S, "volatile", RESERVED_CODE);
	mark_reserved_word(S, "while", RESERVED_CODE);
}

#line 581 "inwebc/Chapter 5/C-Like Languages.w"
int colouring_state = PLAIN_CODE;
int c_like_syntax_colour(programming_language *pl, FILE *WEAVEOUT, weave_target *wv,
	web *W, chapter *C, section *S, source_line *L, char *matter, char *colouring) {
	for (int i=0; matter[i]; i++) {
		int skip = FALSE, one_off = -1, will_be = -1;
		switch (colouring_state) {
			case PLAIN_CODE:
				switch (matter[i]) {
					case '\"': colouring_state = STRING_CODE; break;
					case '\'': colouring_state = CHAR_LITERAL_CODE; break;
				}
				if ((identifier_char(matter[i])) && (matter[i] != ':')) {
					if ((!(isdigit(matter[i]))) ||
						((i>0) && (colouring[i-1] == IDENTIFIER_CODE)))
						one_off = IDENTIFIER_CODE;
				}
				break;
			case CHAR_LITERAL_CODE:
				switch (matter[i]) {
					case '\\': skip = TRUE; break;
					case '\'': will_be = PLAIN_CODE; break;
				}
				break;
			case STRING_CODE:
				switch (matter[i]) {
					case '\\': skip = TRUE; break;
					case '\"': will_be = PLAIN_CODE; break;
				}
				break;
		}
		if (one_off >= 0) colouring[i] = one_off; else colouring[i] = colouring_state;
		if (will_be >= 0) colouring_state = will_be;
		if ((skip) && (matter[i+1])) i++;
	}
	int ident_from = -1;
	for (int i=0; matter[i]; i++) {
		if ((matter[i] == ':') && (matter[i+1] == ':') &&
			(colouring[i-1] == IDENTIFIER_CODE) && (colouring[i+2] == IDENTIFIER_CODE)) {
			colouring[i] = IDENTIFIER_CODE;
			colouring[i+1] = IDENTIFIER_CODE;
		}
		if (colouring[i] == IDENTIFIER_CODE) {
			if (ident_from == -1) ident_from = i;
		} else {
			if (ident_from >= 0)
				c_like_colour_ident(S, matter, colouring, ident_from, i-1);
			ident_from = -1;
		}
	}
	if (ident_from >= 0)
		c_like_colour_ident(S, matter, colouring, ident_from, in_strlen(matter)-1);
	/* printf("%s\n", matter);
	for (int i=0; matter[i]; i++) printf("%c", '0'+colouring[i]); */
	return FALSE;
}

void c_like_colour_ident(section *S, char *matter, char *colouring, int from, int to) {
	string id; in_strcpy(id, matter+from); in_truncate(id, to-from+1);
	int override = -1;

	if (is_reserved_word(S, id, FUNCTION_CODE)) override = FUNCTION_CODE;
	if (is_reserved_word(S, id, RESERVED_CODE)) override = RESERVED_CODE;
	if (is_reserved_word(S, id, CONSTANT_CODE)) override = CONSTANT_CODE;
	if (is_reserved_word(S, id, ELEMENT_CODE)) {
		int at = --from;
		while ((at > 0) && (white_space(matter[at]))) at--;
		if (((at >= 0) && (matter[at] == '.')) ||
			((at >= 0) && (matter[at-1] == '-') && (matter[at] == '>')))
			override = ELEMENT_CODE;
	}

	if (override >= 0) {
		for (int i=from; i<=to; i++) colouring[i] = override;
	}
}

int c_like_weave_code_line(programming_language *pl, FILE *WEAVEOUT, weave_target *wv,
	web *W, chapter *C, section *S, source_line *L, char *matter, char *concluding_comment) {
	return FALSE;
}

#line 665 "inwebc/Chapter 5/C-Like Languages.w"
void c_like_analysis(programming_language *pl, section *S, int functions_too) {
	c_structure *str;
	LOOP_OVER(str, c_structure)
		if (str->typedef_begins->owning_section == S)
			printf(" %s ", str->structure_name);
	if (functions_too) {
		function *fn;
		LOOP_OVER(fn, function)
			if (fn->function_header_at->owning_section == S)
				printf("\n                     %s", fn->function_name);
	}
}

void c_like_analyse_code(programming_language *pl, web *W) {
	function *fn;
	LOOP_OVER(fn, function)
		find_hash_entry(fn->function_header_at->owning_section, fn->function_name, TRUE);
	c_structure *st;
	LOOP_OVER(st, c_structure)
		for (structure_element *elt = st->first_element; elt; elt = elt->next_element)
			if (elt->allow_sharing == FALSE)
				find_hash_entry(elt->element_created_at->owning_section, elt->element_name, TRUE);

	c_structure *str = NULL;
	LOOP_WITHIN_TANGLE(W->first_target) {
		if (L->category == INTERFACE_BODY_LCAT) {
			if (pattern_match(L->text, "-- Owns struct (%c+) %((%c+)%) *")) {
				int private_flag = UNKNOWN;
				if (in_string_eq(found_text2, "private")) private_flag = TRUE;
				if (in_string_eq(found_text2, "public")) private_flag = FALSE;
				if (private_flag == UNKNOWN) {
					error_in_web("should be marked private or public", L);
					private_flag = TRUE;
				}
				str = find_c_structure(W, found_text1);
				if (str == NULL)
					error_in_web("should be marked private or public", L);
				else {
					str->declared_owner = S;
					str->declared_private = private_flag;
				}
				L->interface_line_identified = TRUE;
			} else if (pattern_match(L->text, " *!- shared with (%c+?) *")) {
				if (str == NULL)
					error_in_web("no structure yet to be shared", L);
				else {
					section *SW = section_by_filename(W, found_text1);
					if (SW == NULL)
						error_in_web("no such section", L);
					else {
						structure_permission *sp = CREATE(structure_permission);
						sp->shared_with = SW;
						sp->next_permission = NULL;
						sp->granted_at = L;
						if (str->first_permission == NULL)
							str->first_permission = sp;
						else
							str->last_permission->next_permission = sp;
						str->last_permission = sp;
					}
				}
				L->interface_line_identified = TRUE;
			} else if (pattern_match(L->text, "-- Defines {-(%c+?):(%c+)} *")) {
				L->interface_line_identified = TRUE;
			}
		}
	}
}

void c_like_post_analysis(programming_language *pl, web *W) {
	int check_namespaces = FALSE;
	if (in_string_eq(get_bibliographic_data(W, "Namespaces"), "On")) check_namespaces = TRUE;
	function *fn;
	LOOP_OVER(fn, function) {
		hash_table_entry *hte = find_hash_entry(fn->function_header_at->owning_section, fn->function_name, FALSE);
		if (hte)
			for (hash_table_entry_usage *hteu = hte->first_usage; hteu; hteu = hteu->next_usage)
				if ((hteu->form_of_usage & FCALL_USAGE) || (fn->within_namespace))
					if (hteu->usage_recorded_at->under_section != fn->function_header_at->owning_section)
						fn->called_from_other_sections = TRUE;
		if ((fn->within_namespace != fn->called_from_other_sections)
			&& (check_namespaces)
			&& (fn->call_freely == FALSE)) {
			if (fn->within_namespace)
				error_in_web(
					"Being internally called, this function mustn't belong to a :: namespace",
					fn->function_header_at);
			else
				error_in_web(
					"Being externally called, this function must belong to a :: namespace",
					fn->function_header_at);
		}
	}
	if (in_string_eq(get_bibliographic_data(W, "Strict Usage Rules"), "On")) {
		c_structure *str;
		LOOP_OVER(str, c_structure) {
			if (str->declared_owner == NULL) {
				error_in_web("undeclared structure",
					str->typedef_begins);
				str->typedef_begins->owning_section->erroneous_interface = TRUE;
			}
			section_subset(str, TRUE);
			for (structure_permission *sp = str->first_permission; sp; sp = sp->next_permission) {
				sp->shared_with->scratch_flag |= 2;
				if (sp->shared_with->scratch_flag == 2) {
					error_in_web("structure declared as shared, but it isn't",
						sp->granted_at);
					str->typedef_begins->owning_section->erroneous_interface = TRUE;
				}
			}
			section *S;
			LOOP_OVER(S, section)
				if (S->scratch_flag == 1) {
					error_in_web("structure has missing shared declarations",
						str->typedef_begins);
					str->typedef_begins->owning_section->erroneous_interface = TRUE;
					break;
				}
		}
		section *S;
		LOOP_OVER(S, section)
			if (S->erroneous_interface) {
				printf("Interface for section %s should be:\n", S->sect_title);
				
{
#line 796 "inwebc/Chapter 5/C-Like Languages.w"
	c_structure *str;
	for (str = first_cst_alphabetically; str;
		str = str->next_cst_alphabetically)
		if (str->typedef_begins->owning_section == S) {
			int c = section_subset(str, FALSE);
			printf("-- Owns struct %s (%s)\n", str->structure_name,
				(c > 0)?"public":"private");
			section *SS;
			LOOP_OVER(SS, section)
				if (SS->scratch_flag)
					printf("\t!- shared with %s\n", SS->pathname_relative_to_web);
		}

}
#line 788 "inwebc/Chapter 5/C-Like Languages.w"
;
			}
	}
}

#line 812 "inwebc/Chapter 5/C-Like Languages.w"
int section_subset(c_structure *str, int report) {
	int c = 0;
	section *S;
	LOOP_OVER(S, section) S->scratch_flag = 0;
	for (structure_element *elt = str->first_element; elt; elt = elt->next_element) {
		int d = 0;
		hash_table_entry *hte = find_hash_entry(elt->element_created_at->owning_section, elt->element_name, FALSE);
		if (hte)
			for (hash_table_entry_usage *hteu = hte->first_usage; hteu; hteu = hteu->next_usage) {
				if (hteu->form_of_usage & ELEMENT_ACCESS_USAGE) {
					d++;
					if (hteu->usage_recorded_at->under_section != str->typedef_begins->owning_section) {
						if (hteu->usage_recorded_at->under_section->scratch_flag == 0) c++;
						hteu->usage_recorded_at->under_section->scratch_flag = 1;
					}
				}
			}
		if ((report) && (d == 0) && (elt->allow_sharing == FALSE))
			error_in_web("element is never used",
				elt->element_created_at);
	}
	return c;
}

#line 84 "inwebc/Chapter 5/C for Inform.w"
int c_for_inform_special_data(FILE *F, char *data) {
	if (in_string_eq(data, "nonterminals")) {
		fprintf(F, "register_tangled_nonterminals();\n");
		return TRUE;
	}
	return FALSE;
}

#line 101 "inwebc/Chapter 5/C for Inform.w"
void c_for_inform_further_parsing(web *W) {
	LOOP_WITHIN_TANGLE(W->first_target) {
		int form = NOT_A_NONTERMINAL; /* one of the four values above, or a non-negative word count */
		string pntname; in_strcpy(pntname, "");
		string header; in_strcpy(header, "");
		
{
#line 150 "inwebc/Chapter 5/C for Inform.w"
	if (pattern_match(L->text, "(<%p+>) ::=%c*")) {
		form = A_GRAMMAR_NONTERMINAL;
		in_strcpy(pntname, found_text1);
		in_strcpy(header, found_text1);
		
{
#line 180 "inwebc/Chapter 5/C for Inform.w"
	source_line *AL;
	for (AL = L; (AL) && (AL->category == CODE_BODY_LCAT); AL = AL->next_line) {
		if (string_is_white_space(AL->text)) break;
		AL->category = PREFORM_GRAMMAR_LCAT;

		if (pattern_match(AL->text, "(%c+) ==> (%c*)")) {
			AL->text_operand = new_string(found_text1);
			AL->text_operand2 = new_string(found_text2);
		} else {
			AL->text_operand = AL->text;
			AL->text_operand2 = "";
		}

		
{
#line 205 "inwebc/Chapter 5/C for Inform.w"
	if (pattern_match(AL->text_operand, "(%c*)%/%*%c*%*%/ *"))
		AL->text_operand = new_string(found_text1);

}
#line 193 "inwebc/Chapter 5/C for Inform.w"
;
		
{
#line 213 "inwebc/Chapter 5/C for Inform.w"
	string to_scan; in_strcpy(to_scan, AL->text_operand2);
	while (pattern_match(to_scan, "%c*?<<(%P+?)>> =(%c*)")) {
		string var_given; in_strcpy(var_given, found_text1);
		string type_given; in_strcpy(type_given, "int");
		in_strcpy(to_scan, found_text2);
		if (pattern_match(var_given, "(%p+):%p+")) {
			in_sprintf(type_given, "%s *", found_text1);
		}
		nonterminal_variable *ntv;
		LOOP_OVER(ntv, nonterminal_variable)
			if (in_string_eq(ntv->ntv_name, var_given))
				break;
		if (ntv == NULL) 
{
#line 233 "inwebc/Chapter 5/C for Inform.w"
	ntv = CREATE(nonterminal_variable);
	in_strcpy(ntv->ntv_name, var_given);
	in_strcpy(ntv->ntv_type, type_given);
	for (int i=0; var_given[i]; i++)
		if ((var_given[i] == '-') || (var_given[i] == ':'))
			in_set(var_given, i, '_');
	in_sprintf(ntv->ntv_identifier, "%s_NTMV", var_given);
	ntv->first_mention = AL;

}
#line 225 "inwebc/Chapter 5/C for Inform.w"
;
	}

}
#line 194 "inwebc/Chapter 5/C for Inform.w"
;
	}

}
#line 154 "inwebc/Chapter 5/C for Inform.w"
;
	} else if (pattern_match(L->text, "((<%p+>) internal %?) {%c*")) {
		form = A_VORACIOUS_NONTERMINAL;
		in_strcpy(pntname, found_text2);
		in_strcpy(header, found_text1);
	} else if (pattern_match(L->text, "((<%p+>) internal) {%c*")) {
		form = A_FLEXIBLE_NONTERMINAL;
		in_strcpy(pntname, found_text2);
		in_strcpy(header, found_text1);
	} else if (pattern_match(L->text, "((<%p+>) internal (%d+)) {%c*")) {
		form = atoi(found_text3);
		in_strcpy(pntname, found_text2);
		in_strcpy(header, found_text1);
	}

}
#line 106 "inwebc/Chapter 5/C for Inform.w"
;
		if (form != NOT_A_NONTERMINAL) {
			preform_nonterminal *pnt = CREATE(preform_nonterminal);
			pnt->where_defined = L;
			in_strcpy(pnt->nt_name, pntname);
			in_strcpy(pnt->unangled_name, pntname + 1);
			in_truncate(pnt->unangled_name, in_strlen(pnt->unangled_name)-1);
			pnt->next_pnt_alphabetically = NULL;
			if (first_pnt_alphabetically == NULL) first_pnt_alphabetically = pnt;
			else {
				int placed = FALSE;
				preform_nonterminal *last = NULL;
				for (preform_nonterminal *seq = first_pnt_alphabetically; seq;
					seq = seq->next_pnt_alphabetically) {
					if (in_string_cmp(pntname, seq->nt_name) < 0) {
						if (seq == first_pnt_alphabetically) {
							pnt->next_pnt_alphabetically = first_pnt_alphabetically;
							first_pnt_alphabetically = pnt;
						} else {
							last->next_pnt_alphabetically = pnt;
							pnt->next_pnt_alphabetically = seq;
						}
						placed = TRUE;
						break;
					}
					last = seq;
				}
				if (placed == FALSE) last->next_pnt_alphabetically = pnt;
			}
			
{
#line 248 "inwebc/Chapter 5/C for Inform.w"
	in_strcpy(pnt->as_C_identifier, pnt->nt_name + 1);
	for (int i=0; pnt->as_C_identifier[i]; i++) {
		if (pnt->as_C_identifier[i] == '-') in_set(pnt->as_C_identifier, i, '_');
		if (pnt->as_C_identifier[i] == '>') in_truncate(pnt->as_C_identifier, i);
	}
	in_strcat(pnt->as_C_identifier, "_NTM");

}
#line 135 "inwebc/Chapter 5/C for Inform.w"
;
			
{
#line 258 "inwebc/Chapter 5/C for Inform.w"
	pnt->voracious = FALSE; if (form == A_VORACIOUS_NONTERMINAL) pnt->voracious = TRUE;
	pnt->as_function = TRUE; if (form == A_GRAMMAR_NONTERMINAL) pnt->as_function = FALSE;

	pnt->takes_pointer_result = FALSE;
	if (pattern_match(pnt->nt_name, "<k-%c+")) pnt->takes_pointer_result = TRUE;
	if (pattern_match(pnt->nt_name, "<s-%c+")) pnt->takes_pointer_result = TRUE;

	int min = 1, max = form;
	if (form < 0) max = INFINITE_WORD_COUNT;
	if (max == 0) min = 0;
	else if (max != INFINITE_WORD_COUNT) min = max;
	pnt->min_word_count = min;
	pnt->max_word_count = max;

}
#line 136 "inwebc/Chapter 5/C for Inform.w"
;
			L->preform_nonterminal_defined = pnt;
			if (Preform_theme) add_tag_to_para(L->owning_paragraph, Preform_theme, NULL);
			L->category = PREFORM_LCAT;
			L->text_operand = new_string(header);
		}
	}
}

#line 283 "inwebc/Chapter 5/C for Inform.w"
void c_for_inform_additional_predeclarations(FILE *F, web *W) {
	LOOP_WITHIN_TANGLE(W->first_target)
		if (L->preform_nonterminal_defined) {
			preform_nonterminal *pnt = L->preform_nonterminal_defined;
			language_insert_line_marker(F, W->main_language, L);
			fprintf(F, "nonterminal *%s = NULL;\n", pnt->as_C_identifier);
		}

	nonterminal_variable *ntv;
	LOOP_OVER(ntv, nonterminal_variable)
		fprintf(F, "%s %s = %s;\n",
			ntv->ntv_type, ntv->ntv_identifier,
			(in_string_eq(ntv->ntv_type, "int"))?"0":"NULL");

	fprintf(F, "void register_tangled_nonterminals(void);\n");
}

#line 304 "inwebc/Chapter 5/C for Inform.w"
void c_for_inform_gnabehs(FILE *F, web *W) {
	fprintf(F, "void register_tangled_nonterminals(void) {\n");
	LOOP_WITHIN_TANGLE(W->first_target)
		if (L->preform_nonterminal_defined) {
			preform_nonterminal *pnt = L->preform_nonterminal_defined;
			language_insert_line_marker(F, W->main_language, L);
			if (pnt->as_function) {
				fprintf(F, "\tINTERNAL_NONTERMINAL(\"%s\", %s, %d, %d);\n",
					pnt->nt_name, pnt->as_C_identifier,
					pnt->min_word_count, pnt->max_word_count);
				fprintf(F, "\t%s->voracious = %d;\n",
					pnt->as_C_identifier, pnt->voracious);
			} else {
				fprintf(F, "\tREGISTER_NONTERMINAL(\"%s\", %s);\n",
					pnt->nt_name, pnt->as_C_identifier);
			}
		}
	fprintf(F, "}\n");
}

#line 332 "inwebc/Chapter 5/C for Inform.w"
int c_for_inform_will_insert_in_tangle(source_line *L) {
	if (L->category == PREFORM_LCAT) return TRUE;
	return FALSE;
}

#line 354 "inwebc/Chapter 5/C for Inform.w"
void c_for_inform_insert_in_tangle(FILE *F, source_line *L) {
	preform_nonterminal *pnt = L->preform_nonterminal_defined;
	if (pnt->as_function) {
		fprintf(F, "int %sR(int w1, int w2, int *X, void **XP) {\n",
			pnt->as_C_identifier);
	} else {
		fprintf(F, "int %sC(int *X, void **XP, int *R, void **RP, int w1, int w2) {\n",
			pnt->as_C_identifier);
		
{
#line 411 "inwebc/Chapter 5/C for Inform.w"
	int needs_collation = FALSE;
	for (source_line *AL = L->next_line;
		((AL) && (AL->category == PREFORM_GRAMMAR_LCAT));
		AL = AL->next_line)
			if (AL->text_operand2[0])
				needs_collation = TRUE;
	if (needs_collation) 
{
#line 431 "inwebc/Chapter 5/C for Inform.w"
	fprintf(F, "\tswitch(R[0]) {\n");
	int c = 0;
	for (source_line *AL = L->next_line;
		((AL) && (AL->category == PREFORM_GRAMMAR_LCAT));
		AL = AL->next_line, c++) {
		char *formula = AL->text_operand2;
		if (formula[0]) {
			fprintf(F, "\t\tcase %d: ", c);
			
{
#line 469 "inwebc/Chapter 5/C for Inform.w"
	if (!pattern_match(formula, "@<%c*")) {
		if (pnt->takes_pointer_result) fprintf(F, "*XP = ");
		else fprintf(F, "*X = ");
	}
	string expanded; in_strcpy(expanded, "");
	for (int i=0; formula[i]; i++) {
		if ((formula[i] == 'W') && ((formula[i+1] == '1') || (formula[i+1] == '2')) &&
			(formula[i+2] == '[') && (isdigit(formula[i+3])) && (formula[i+4] == ']')) {
				in_sprintf(expanded+in_strlen(expanded),
					"%s->range_result_w%c[%c]", pnt->as_C_identifier,
					formula[i+1], formula[i+3]);
				i += 4;
		} else {
			in_sprintf(expanded+in_strlen(expanded), "%c", formula[i]);
		}
	}
	tangle_code(F, expanded, AL->owning_section, AL);

}
#line 439 "inwebc/Chapter 5/C for Inform.w"
;
			fprintf(F, ";\n");
			fprintf(F, "#pragma clang diagnostic push\n");
			fprintf(F, "#pragma clang diagnostic ignored \"-Wunreachable-code\"\n");
			fprintf(F, "break;\n");
			fprintf(F, "#pragma clang diagnostic pop\n");
		}
	}
	fprintf(F, "\t\tdefault: *X = R[0]; break;\n");
	fprintf(F, "\t}\n");

}
#line 417 "inwebc/Chapter 5/C for Inform.w"

	else 
{
#line 426 "inwebc/Chapter 5/C for Inform.w"
	fprintf(F, "\t*X = R[0];\n");

}
#line 418 "inwebc/Chapter 5/C for Inform.w"
;
	fprintf(F, "\treturn TRUE;\n");

}
#line 362 "inwebc/Chapter 5/C for Inform.w"
;
		fprintf(F, "}\n");
	}
}

#line 492 "inwebc/Chapter 5/C for Inform.w"
void c_for_inform_tangle_code(FILE *F, char *original) {
	int fcall_mode = FALSE;
	for (int i = 0; original[i]; i++) {
		
{
#line 534 "inwebc/Chapter 5/C for Inform.w"
	if ((i > 0) && (original[i] == ':') && (original[i+1] == ':') &&
		(isalpha(original[i+2])) && (isalnum(original[i-1]))) {
		fprintf(F, "__"); i++;
		continue;
	}

}
#line 495 "inwebc/Chapter 5/C for Inform.w"
;
		if (original[i] == '<') {
			if (original[i+1] == '<') {
				
{
#line 546 "inwebc/Chapter 5/C for Inform.w"
	if (pattern_match(original+i, "<<(%P+)>>(%c*)")) {
		string putative; in_strcpy(putative, found_text1);
		char *pv_identifier = nonterminal_variable_identifier(putative);
		if (pv_identifier) {
			fprintf(F, "%s", pv_identifier);
			i += in_strlen(putative) + 3;
			continue;
		}
	}

}
#line 498 "inwebc/Chapter 5/C for Inform.w"
;
			} else {
				
{
#line 574 "inwebc/Chapter 5/C for Inform.w"
	if (pattern_match(original+i, "(<%p+>)(%c*)")) {
		string putative; in_strcpy(putative, found_text1);
		preform_nonterminal *pnt = nonterminal_by_name(putative);
		if (pnt) {
			i += in_strlen(putative) - 1;
			if (original[i+1] == '(') fcall_mode = TRUE;
			if (fcall_mode) fprintf(F, "parse_nt_against_word_range(");
			fprintf(F, "%s", pnt->as_C_identifier);
			if (fcall_mode) {
				fprintf(F, ", "); i++;
			}
			continue;
		}
	}

}
#line 500 "inwebc/Chapter 5/C for Inform.w"
;
			}
		}
		if ((original[i] == ')') && (fcall_mode)) {
			fcall_mode = FALSE;
			fprintf(F, ", NULL, NULL");
		}
		fputc(original[i], F);
	}
}

#line 595 "inwebc/Chapter 5/C for Inform.w"
preform_nonterminal *nonterminal_by_name(char *name) {
	preform_nonterminal *pnt;
	LOOP_OVER(pnt, preform_nonterminal)
		if (in_string_eq(name, pnt->nt_name))
			return pnt;
	return NULL;
}

#line 609 "inwebc/Chapter 5/C for Inform.w"
char *nonterminal_variable_identifier(char *name) {
	if (in_string_eq(name, "r")) return "most_recent_result";
	if (in_string_eq(name, "rp")) return "most_recent_result_p";
	nonterminal_variable *ntv;
	LOOP_OVER(ntv, nonterminal_variable)
		if (in_string_eq(ntv->ntv_name, name))
			return ntv->ntv_identifier;
	return NULL;
}

#line 631 "inwebc/Chapter 5/C for Inform.w"
void c_for_inform_additional_tangling(programming_language *pl, web *W, tangle_target *target) {
	string defn_to;
	in_sprintf(defn_to, "%sTangled%c%s", W->path_to_web, SEP_CHAR, "Syntax.preform");

	FILE *SYNTAX = fopen(defn_to, "w");
	if (SYNTAX == NULL)
		fatal_filing_system_error("unable to open Preform file for output", defn_to);
	printf("Writing Preform syntax to: %s\n", defn_to);
	fprintf(SYNTAX, "[This is English.preform, generated by inweb: do not edit.]\n\n");
	fprintf(SYNTAX, "language English\n");

	
{
#line 659 "inwebc/Chapter 5/C for Inform.w"
	LOOP_WITHIN_TANGLE(target)
		if (L->category == PREFORM_LCAT) {
			preform_nonterminal *pnt = L->preform_nonterminal_defined;
			if (pnt->as_function)
				fprintf(SYNTAX, "\n%s internal\n", pnt->nt_name);
			else
				fprintf(SYNTAX, "\n%s ::=\n", L->text_operand);
			for (source_line *AL = L->next_line;
				((AL) && (AL->category == PREFORM_GRAMMAR_LCAT));
				AL = AL->next_line) {
				fprintf(SYNTAX, "%s", AL->text_operand);
				if (pattern_match(AL->text_operand2, "%c+Issue (%c+) problem%c+"))
					fprintf(SYNTAX, "[issues %s]", found_text1);
				fprintf(SYNTAX, "\n");
			}
		}

}
#line 642 "inwebc/Chapter 5/C for Inform.w"
;
	fclose(SYNTAX);
}

#line 679 "inwebc/Chapter 5/C for Inform.w"
void weave_grammar_index(FILE *F) {
	fprintf(F, "\\raggedright\\tolerance=10000");
	preform_nonterminal *pnt;
	for (pnt = first_pnt_alphabetically; pnt;
		pnt = pnt->next_pnt_alphabetically) {
		fprintf(F, "\\line{\\nonterminal{%s}%s"
			"\\leaders\\hbox to 1em{\\hss.\\hss}\\hfill {\\xreffont %s}}\n",
			pnt->unangled_name,
			(pnt->as_function)?" (internal)":"",
			pnt->where_defined->owning_section->sigil);
		int said_something = FALSE;
		
{
#line 728 "inwebc/Chapter 5/C for Inform.w"
	section *S;
	LOOP_OVER(S, section) S->scratch_flag = FALSE;
	hash_table_entry *hte = find_hash_entry(pnt->where_defined->owning_section, pnt->unangled_name, FALSE);
	for (hash_table_entry_usage *hteu = hte->first_usage; hteu; hteu = hteu->next_usage)
		if (hteu->form_of_usage & PREFORM_IN_GRAMMAR_USAGE)
			hteu->usage_recorded_at->under_section->scratch_flag = TRUE;
	int use_count = 0;
	LOOP_OVER(S, section)
		if (S->scratch_flag)
			use_count++;
	if (use_count > 0) {
		said_something = TRUE;
		fprintf(F, "\\par\\hangindent=3em{\\it used by other nonterminals in} ");
		int c = 0;
		LOOP_OVER(S, section)
			if (S->scratch_flag) {
				if (c++ > 0) fprintf(F, ", ");
				fprintf(F, "{\\xreffont %s}", S->sigil);
			}
		fprintf(F, "\n\n");
	}

}
#line 690 "inwebc/Chapter 5/C for Inform.w"
;
		
{
#line 703 "inwebc/Chapter 5/C for Inform.w"
	section *S;
	LOOP_OVER(S, section) S->scratch_flag = FALSE;
	hash_table_entry *hte = find_hash_entry(pnt->where_defined->owning_section, pnt->unangled_name, FALSE);
	for (hash_table_entry_usage *hteu = hte->first_usage; hteu; hteu = hteu->next_usage)
		if (hteu->form_of_usage & PREFORM_IN_CODE_USAGE)
			hteu->usage_recorded_at->under_section->scratch_flag = TRUE;
	int use_count = 0;
	LOOP_OVER(S, section)
		if (S->scratch_flag)
			use_count++;
	if (use_count > 0) {
		said_something = TRUE;
		fprintf(F, "\\par\\hangindent=3em{\\it called from} ");
		int c = 0;
		LOOP_OVER(S, section)
			if (S->scratch_flag) {
				if (c++ > 0) fprintf(F, ", ");
				fprintf(F, "{\\xreffont %s}", S->sigil);
			}
		fprintf(F, "\n\n");
	}

}
#line 691 "inwebc/Chapter 5/C for Inform.w"
;
		if (said_something == FALSE)
			fprintf(F, "\\par\\hangindent=3em{\\it unused}\n\n");
	}
	fprintf(F, "\\penalty-1000\n");
	fprintf(F, "\\smallbreak\n");
	fprintf(F, "\\hrule\\smallbreak\n");
}

#line 754 "inwebc/Chapter 5/C for Inform.w"
void c_for_inform_new_tag_declared(theme_tag *tag) {
	if (in_string_eq(tag->tag_name, "Preform")) Preform_theme = tag;
}

int skipping_internal = FALSE, preform_production_count = 0;

int c_for_inform_skip_in_weaving(weave_target *wv, source_line *L) {
	if ((Preform_theme) && (wv->theme_match == Preform_theme)) {
		if (pattern_match(L->text, "}%c*")) { skipping_internal = FALSE; return TRUE; }
		if (skipping_internal) return TRUE;
		if (pattern_match(L->text, "<%c*?> internal%c*")) skipping_internal = TRUE;
	}
	return FALSE;
}

void c_for_inform_begin_weave(section *S, weave_target *wv) {
}

#line 775 "inwebc/Chapter 5/C for Inform.w"
int c_for_inform_syntax_colour(FILE *WEAVEOUT, weave_target *wv,
	web *W, chapter *C, section *S, source_line *L, char *matter, char *colouring) {
	return FALSE;
}

int c_for_inform_weave_code_line(FILE *WEAVEOUT, weave_target *wv,
	web *W, chapter *C, section *S, source_line *L, char *matter, char *concluding_comment) {
	if ((Preform_theme) && (wv->theme_match == Preform_theme)) {
		if (L->preform_nonterminal_defined) preform_production_count = 0;
		if (L->preform_nonterminal_defined) {
			fprintf(WEAVEOUT, "\\nonterminal{%s} |::=|",
				L->preform_nonterminal_defined->unangled_name);
			if (L->preform_nonterminal_defined->as_function) {
				fprintf(WEAVEOUT, "{\\it internal definition");
				if (L->preform_nonterminal_defined->voracious)
					fprintf(WEAVEOUT, " (voracious)");
				else if (L->preform_nonterminal_defined->min_word_count ==
					L->preform_nonterminal_defined->min_word_count)
					fprintf(WEAVEOUT, " (%d word%s)",
						L->preform_nonterminal_defined->min_word_count,
						(L->preform_nonterminal_defined->min_word_count != 1)?"s":"");
				fprintf(WEAVEOUT, "}");
			}
			fprintf(WEAVEOUT, "\n");
			return TRUE;
		} else {
			if (L->category == PREFORM_GRAMMAR_LCAT) {
				string problem; in_strcpy(problem, "");
				if (pattern_match(matter, "Issue (%c*?) problem")) in_strcpy(problem, found_text1);
				if (pattern_match(matter, "FAIL_NONTERMINAL %+")) in_strcpy(problem, "fail and skip");
				else if (pattern_match(matter, "FAIL_NONTERMINAL")) in_strcpy(problem, "fail");
				preform_production_count++;
				in_sprintf(matter, "|%s|", L->text_operand);
				while (pattern_match(matter, "(%c+?)|(%c+)"))
					in_sprintf(matter, "%s___stroke___%s",
						found_text1, found_text2);
				while (pattern_match(matter, "(%c*?)___stroke___(%c*)"))
					in_sprintf(matter, "%s|\\||%s",
						found_text1, found_text2);
				while (pattern_match(matter, "(%c*)<(%c*?)>(%c*)"))
					in_sprintf(matter, "%s|\\nonterminal{%s}|%s",
						found_text1, found_text2, found_text3);
				string label; in_strcpy(label, "");
				int N = preform_production_count;
				if (in_string_eq(S->sigil, "9/engin")) {
					in_sprintf(label, "${}_{%d}$", N);
				} else {
					int L = ((N-1)%26) + 1;
					if (N <= 26) in_sprintf(label, "%c", 'a'+L-1);
					else if (N <= 52) in_sprintf(label, "%c%c", 'a'+L-1, 'a'+L-1);
					else if (N <= 78) in_sprintf(label, "%c%c%c", 'a'+L-1, 'a'+L-1, 'a'+L-1);
				}
				fprintf(WEAVEOUT, "\\qquad {\\hbox to 0.4in{\\it %s\\hfil}}%s", label, matter);
				if (problem[0])
					fprintf(WEAVEOUT, "\\hfill$\\longrightarrow$ {\\ttninepoint\\it %s}", problem);
				else
					fprintf(WEAVEOUT, "%s", concluding_comment);
				fprintf(WEAVEOUT, "\n");
				return TRUE;
			}
		}
	}
	return FALSE;
}

#line 843 "inwebc/Chapter 5/C for Inform.w"
void c_for_inform_analyse_code(programming_language *pl, web *W) {
	preform_nonterminal *pnt;
	LOOP_OVER(pnt, preform_nonterminal)
		find_hash_entry(pnt->where_defined->owning_section, pnt->unangled_name, TRUE);
	LOOP_WITHIN_TANGLE(W->first_target) {
		if (L->category == INTERFACE_BODY_LCAT) {
			if (pattern_match(L->text, "-- Defines {-(%c+?):(%c+)} *")) {
				L->interface_line_identified = TRUE;
				int form = 0;
				if (in_string_eq(found_text1, "call")) form = 1;
				if (in_string_eq(found_text1, "callv")) form = 2;
				if (in_string_eq(found_text1, "routine")) form = 3;
				if (in_string_eq(found_text1, "array")) form = 4;
				if (form == 0) {
					error_in_web("bad {-format:...}", L);
					continue;
				}
				string function_name; in_strcpy(function_name, "");
				switch (form) {
					case 1: case 2: in_strcpy(function_name, found_text2); break;
					case 3: in_sprintf(function_name, "%s_routine", found_text2); break;
					case 4: in_sprintf(function_name, "%s_array", found_text2); break;
				}
				function *fn = get_function_with_name(function_name);
				if (fn == NULL) {
					error_in_web("no such function exists", L);
					fprintf(stderr, "  >> %s\n", function_name);
					continue;
				}
				fn->called_from_other_sections = TRUE;
			}
		}
	}
}

#line 13 "inwebc/Chapter 6/Weave Formats.w"
weave_format *plain_text_format = NULL;
weave_format *tex_format = NULL;
weave_format *dvi_format = NULL;
weave_format *pdf_format = NULL;
weave_format *html_format = NULL;
weave_format *epub_format = NULL;

void create_weave_formats(void) {
	plain_text_format = create_weave_format("plain", ".txt", NULL);
	tex_format = create_weave_format("TeX", ".tex", NULL);
	dvi_format = create_weave_format("DVI", ".dvi", tex_format);
	pdf_format = create_weave_format("PDF", ".pdf", tex_format);
	html_format = create_weave_format("HTML", ".html", NULL);
	epub_format = create_weave_format("ePub", ".epub", html_format);
}

#line 38 "inwebc/Chapter 6/Weave Formats.w"

#line 42 "inwebc/Chapter 6/Weave Formats.w"
weave_format *create_weave_format(char *name, char *ext, weave_format *intermediate) {
	weave_format *wf = CREATE(weave_format);
	wf->format_name = name;
	wf->woven_extension = ext;
	wf->intermediate = intermediate;
	return wf;
}

#line 53 "inwebc/Chapter 6/Weave Formats.w"
weave_format *parse_format(char *name) {
	weave_format *wf;
	LOOP_OVER(wf, weave_format)
		if (in_string_eq_insensitive(name, wf->format_name))
			return wf;
	return NULL;
}

int html_like(weave_format *wf) {
	if (wf->intermediate) wf = wf->intermediate;
	if ((wf == html_format) || (wf == epub_format)) return TRUE;
	return FALSE;
}

char *weave_file_extension(weave_format *wf) {
	if (wf->intermediate) wf = wf->intermediate;
	return wf->woven_extension;
}

#line 75 "inwebc/Chapter 6/Weave Formats.w"
void format_top(FILE *F, weave_target *wv, char *comment) {
	weave_format *wf = wv->format->intermediate;
	if (wf == NULL) wf = wv->format;
	if (wf == plain_text_format) return plain_top(F, wv, comment);
	if (wf == tex_format) return tex_top(F, wv, comment);
	if (html_like(wf)) return html_top(F, wv, comment);
}

void format_subheading(FILE *F, weave_target *wv, int level, char *comment, char *head) {
	weave_format *wf = wv->format->intermediate;
	if (wf == NULL) wf = wv->format;
	if (wf == plain_text_format) return plain_subheading(F, wv, level, comment, head);
	if (wf == tex_format) return tex_subheading(F, wv, level, comment, head);
	if (html_like(wf)) return html_subheading(F, wv, level, comment, head);
}

void format_toc(FILE *F, weave_target *wv, int stage, char *text1, char *text2, paragraph *P) {
	weave_format *wf = wv->format->intermediate;
	if (wf == NULL) wf = wv->format;
	if (wf == plain_text_format) return plain_toc(F, wv, stage, text1, text2, P);
	if (wf == tex_format) return tex_toc(F, wv, stage, text1, text2, P);
	if (html_like(wf)) return html_toc(F, wv, stage, text1, text2, P);
}

void format_chapter_tp(FILE *F, weave_target *wv, chapter *C) {
	weave_format *wf = wv->format->intermediate;
	if (wf == NULL) wf = wv->format;
	if (wf == plain_text_format) return plain_chapter_tp(F, wv, C);
	if (wf == tex_format) return tex_chapter_tp(F, wv, C);
	if (html_like(wf)) return html_chapter_tp(F, wv, C);
}

void format_paragraph_heading(FILE *F, weave_target *wv, char *TeX_macro,
	section *S, paragraph *P, char *heading_text, char *chaptermark, char *sectionmark,
	int weight) {
	weave_format *wf = wv->format->intermediate;
	if (wf == NULL) wf = wv->format;
	if (wf == plain_text_format)
		return plain_paragraph_heading(F, wv, TeX_macro, S, P, heading_text, chaptermark, sectionmark, weight);
	if (wf == tex_format)
		return tex_paragraph_heading(F, wv, TeX_macro, S, P, heading_text, chaptermark, sectionmark, weight);
	if (html_like(wf))
		return html_paragraph_heading(F, wv, TeX_macro, S, P, heading_text, chaptermark, sectionmark, weight);
}

void format_source_code(FILE *F, weave_target *wv,
	int tab_stops_of_indentation,
	char *prefatory, char *matter, char *colouring, char *concluding_comment,
	int starts, int finishes, int code_mode) {
	weave_format *wf = wv->format->intermediate;
	if (wf == NULL) wf = wv->format;
	if (wf == plain_text_format) return plain_source_code(F, wv, tab_stops_of_indentation,
		prefatory, matter, colouring, concluding_comment, starts, finishes, code_mode);
	if (wf == tex_format) return tex_source_code(F, wv, tab_stops_of_indentation,
		prefatory, matter, colouring, concluding_comment, starts, finishes, code_mode);
	if (html_like(wf)) return html_source_code(F, wv, tab_stops_of_indentation,
		prefatory, matter, colouring, concluding_comment, starts, finishes, code_mode);
}

void format_source_fragment(FILE *F, weave_target *wv, char *fragment) {
	weave_format *wf = wv->format->intermediate;
	if (wf == NULL) wf = wv->format;
	if (wf == plain_text_format) plain_inline_code(F, wv, TRUE);
	if (wf == tex_format) tex_inline_code(F, wv, TRUE);
	if (html_like(wf)) html_inline_code(F, wv, TRUE);
	string colouring;
	for (int i=0; fragment[i]; i++) colouring[i] = PLAIN_CODE;
	colouring[in_strlen(fragment)] = 0;
	format_source_code(F, wv, 0, "", fragment, colouring, "", FALSE, FALSE, TRUE);
	if (wf == plain_text_format) plain_inline_code(F, wv, FALSE);
	if (wf == tex_format) tex_inline_code(F, wv, FALSE);
	if (html_like(wf)) html_inline_code(F, wv, FALSE);
}

void format_comment_lines(FILE *F, weave_target *wv, source_line *from, source_line *to) {
	weave_format *wf = wv->format->intermediate;
	if (wf == NULL) wf = wv->format;
	if (wf == plain_text_format) return plain_comment_lines(F, wv, from, to);
	if (wf == tex_format) return tex_comment_lines(F, wv, from, to);
	if (html_like(wf)) return html_comment_lines(F, wv, from, to);
}

void format_display_line(FILE *F, weave_target *wv, char *from) {
	weave_format *wf = wv->format->intermediate;
	if (wf == NULL) wf = wv->format;
	if (wf == plain_text_format) return plain_display_line(F, wv, from);
	if (wf == tex_format) return tex_display_line(F, wv, from);
	if (html_like(wf)) return html_display_line(F, wv, from);
}

void format_item(FILE *F, weave_target *wv, int depth, char *label) {
	weave_format *wf = wv->format->intermediate;
	if (wf == NULL) wf = wv->format;
	if (wf == plain_text_format) return plain_item(F, wv, depth, label);
	if (wf == tex_format) return tex_item(F, wv, depth, label);
	if (html_like(wf)) return html_item(F, wv, depth, label);
}

void format_bar(FILE *F, weave_target *wv) {
	weave_format *wf = wv->format->intermediate;
	if (wf == NULL) wf = wv->format;
	if (wf == plain_text_format) return plain_bar(F, wv);
	if (wf == tex_format) return tex_bar(F, wv);
	if (html_like(wf)) return html_bar(F, wv);
}

void format_figure(FILE *F, weave_target *wv, char *figname, int cm) {
	weave_format *wf = wv->format->intermediate;
	if (wf == NULL) wf = wv->format;
	if (wf == plain_text_format) return plain_figure(F, wv, figname, cm);
	if (wf == tex_format) return tex_figure(F, wv, figname, cm);
	if (html_like(wf)) return html_figure(F, wv, figname, cm);
}

void format_cweb_macro(char *matter, weave_target *wv, cweb_macro *cwm, int defn) {
	weave_format *wf = wv->format->intermediate;
	if (wf == NULL) wf = wv->format;
	if (wf == plain_text_format) return plain_cweb_macro(matter, wv, cwm, defn);
	if (wf == tex_format) return tex_cweb_macro(matter, wv, cwm, defn);
	if (html_like(wf)) return html_cweb_macro(matter, wv, cwm, defn);
}

void format_pagebreak(FILE *F, weave_target *wv) {
	weave_format *wf = wv->format->intermediate;
	if (wf == NULL) wf = wv->format;
	if (wf == plain_text_format) return plain_pagebreak(F, wv);
	if (wf == tex_format) return tex_pagebreak(F, wv);
	if (html_like(wf)) return html_pagebreak(F, wv);
}

void format_blank_line(FILE *F, weave_target *wv, int in_comment) {
	weave_format *wf = wv->format->intermediate;
	if (wf == NULL) wf = wv->format;
	if (wf == plain_text_format) return plain_blank_line(F, wv, in_comment);
	if (wf == tex_format) return tex_blank_line(F, wv, in_comment);
	if (html_like(wf)) return html_blank_line(F, wv, in_comment);
}

void format_code_note(FILE *F, weave_target *wv, char *comment) {
	weave_format *wf = wv->format->intermediate;
	if (wf == NULL) wf = wv->format;
	if (wf == plain_text_format) return plain_code_note(F, wv, comment);
	if (wf == tex_format) return tex_code_note(F, wv, comment);
	if (html_like(wf)) return html_code_note(F, wv, comment);
}

void format_change_mode(FILE *F, weave_target *wv, int old_mode, int new_mode, int content) {
	weave_format *wf = wv->format->intermediate;
	if (wf == NULL) wf = wv->format;
	if (wf == plain_text_format) return plain_change_mode(F, wv, old_mode, new_mode, content);
	if (wf == tex_format) return tex_change_mode(F, wv, old_mode, new_mode, content);
	if (html_like(wf)) return html_change_mode(F, wv, old_mode, new_mode, content);
}

#line 242 "inwebc/Chapter 6/Weave Formats.w"
void format_change_colour(weave_target *wv, char *slot, int col, int in_code) {
	in_strcpy(slot, "");
	weave_format *wf = wv->format->intermediate;
	if (wf == NULL) wf = wv->format;
	if (wf == plain_text_format) return plain_change_colour(wv, slot, col, in_code);
	if (wf == tex_format) return tex_change_colour(wv, slot, col, in_code);
	if (html_like(wf)) return html_change_colour(wv, slot, col, in_code);
}

void format_endnote(FILE *F, weave_target *wv, int end) {
	weave_format *wf = wv->format->intermediate;
	if (wf == NULL) wf = wv->format;
	if (wf == plain_text_format) return plain_endnote(F, wv, end);
	if (wf == tex_format) return tex_endnote(F, wv, end);
	if (html_like(wf)) return html_endnote(F, wv, end);
}

void format_identifier(FILE *F, weave_target *wv, char *id) {
	format_identifier_r(F, wv, id, FALSE);
}

void format_identifier_r(FILE *F, weave_target *wv, char *id, int within) {
	for (int i=0; id[i]; i++) {
		if (id[i] == '\\') i++;
		else if (id[i] == '|') {
			string before; in_strcpy(before, id); before[i] = 0;
			string after; in_strcpy(after, id+i+1);
			format_identifier_r(F, wv, before, within);
			format_identifier_r(F, wv, after, (within)?FALSE:TRUE);
			return;
		}
	}
	if (within) {
		format_source_fragment(F, wv, id);
	} else {
		weave_format *wf = wv->format->intermediate;
		if (wf == NULL) wf = wv->format;
		if (wf == plain_text_format) return plain_identifier(F, wv, id);
		if (wf == tex_format) return tex_identifier(F, wv, id);
		if (html_like(wf)) return html_identifier(F, wv, id);
	}
}

void format_locale(FILE *F, weave_target *wv, paragraph *par1, paragraph *par2) {
	weave_format *wf = wv->format->intermediate;
	if (wf == NULL) wf = wv->format;
	if (wf == plain_text_format) return plain_locale(F, wv, par1, par2);
	if (wf == tex_format) return tex_locale(F, wv, par1, par2);
	if (html_like(wf)) return html_locale(F, wv, par1, par2);
}

void format_tail(FILE *F, weave_target *wv, char *comment) {
	weave_format *wf = wv->format->intermediate;
	if (wf == NULL) wf = wv->format;
	if (wf == plain_text_format) return plain_tail(F, wv, comment);
	if (wf == tex_format) return tex_tail(F, wv, comment);
	if (html_like(wf)) return html_tail(F, wv, comment);
}

#line 304 "inwebc/Chapter 6/Weave Formats.w"
void post_process_weave(weave_target *wv, int open_afterwards) {
	if (wv->format->intermediate == tex_format)
		tex_post_process_weave(wv, open_afterwards);
}

void report_on_post_processing(weave_target *wv) {
	if (wv->format->intermediate == tex_format)
		tex_report_on_post_processing(wv);
}

int substitute_post_processing_data(char *to, weave_target *wv, char *detail) {
	if (wv->format->intermediate == tex_format)
		return tex_substitute_post_processing_data(to, wv, detail);
	return FALSE;
}

int index_pdfs(char *format) {
	if (parse_format(format) == pdf_format) return TRUE;
	return FALSE;
}

#line 9 "inwebc/Chapter 6/Plain Text Format.w"
void plain_top(FILE *F, weave_target *wv, char *comment) {
	fprintf(F, "[%s]\n", comment);
}

#line 16 "inwebc/Chapter 6/Plain Text Format.w"
void plain_subheading(FILE *F, weave_target *wv, int level, char *comment, char *head) {
	fprintf(F, "%s:\n", comment);
	if ((level == 2) && (head)) { format_identifier(F, wv, head); fprintf(F, "\n\n"); }
}

#line 24 "inwebc/Chapter 6/Plain Text Format.w"
void plain_toc(FILE *F, weave_target *wv, int stage, char *text1, char *text2, paragraph *P) {
	switch (stage) {
		case 1: fprintf(F, "%s.", text1); break;
		case 2: fprintf(F, "; "); break;
		case 3: fprintf(F, "%s %s", text1, text2); break;
		case 4: fprintf(F, "\n\n"); break;
	}
}

#line 36 "inwebc/Chapter 6/Plain Text Format.w"
void plain_chapter_tp(FILE *F, weave_target *wv, chapter *C) {
	fprintf(F, "%s\n\n", C->rubric);
	for (section *S2 = C->first_section; S2; S2 = S2->next_section)
		fprintf(F, "    %s: %s\n        %s\n",
			S2->sigil, S2->sect_title, S2->sect_purpose);
}

#line 46 "inwebc/Chapter 6/Plain Text Format.w"
void plain_paragraph_heading(FILE *F, weave_target *wv, char *TeX_macro,
	section *S, paragraph *P, char *heading_text, char *chaptermark, char *sectionmark,
	int weight) {
	if (P) {
		fprintf(F, "\n");
		format_locale(F, wv, P, NULL);
		fprintf(F, ". %s    ", heading_text);
	} else {
		fprintf(F, "%s\n\n", heading_text);
	}
}

#line 61 "inwebc/Chapter 6/Plain Text Format.w"
void plain_source_code(FILE *WEAVEOUT, weave_target *wv,
	int tab_stops_of_indentation,
	char *prefatory, char *matter, char *colouring, char *concluding_comment,
	int starts, int finishes, int code_mode) {
	if (starts) {
		for (int i=0; i<tab_stops_of_indentation; i++)
			fprintf(WEAVEOUT, "    ");
		if (prefatory[0]) fprintf(WEAVEOUT, "%s ", prefatory);
	}
	fprintf(WEAVEOUT, "%s", matter);
	if (finishes) {
		if (concluding_comment[0]) fprintf(WEAVEOUT, "[%s]", concluding_comment);
		fprintf(WEAVEOUT, "\n");
	}
}

#line 80 "inwebc/Chapter 6/Plain Text Format.w"
void plain_inline_code(FILE *F, weave_target *wv, int enter) {
}

#line 86 "inwebc/Chapter 6/Plain Text Format.w"
void plain_comment_lines(FILE *F, weave_target *wv, source_line *from, source_line *to) {
}

#line 92 "inwebc/Chapter 6/Plain Text Format.w"
void plain_display_line(FILE *F, weave_target *wv, char *from) {
	fprintf(F, "    %s\n", from);
}

#line 99 "inwebc/Chapter 6/Plain Text Format.w"
void plain_item(FILE *F, weave_target *wv, int depth, char *label) {
	if (depth == 1) fprintf(F, "%-4s  ", label);
	else fprintf(F, "%-8s  ", label);
}

#line 107 "inwebc/Chapter 6/Plain Text Format.w"
void plain_bar(FILE *F, weave_target *wv) {
	fprintf(F, "\n----------------------------------------------------------------------\n\n");
}

#line 114 "inwebc/Chapter 6/Plain Text Format.w"
void plain_figure(FILE *F, weave_target *wv, char *figname, int cm) {
}

#line 120 "inwebc/Chapter 6/Plain Text Format.w"
void plain_cweb_macro(char *matter, weave_target *wv, cweb_macro *cwm, int defn) {
	sprintf(matter, "<%s (%s)>%s",
		cwm->macro_name, cwm->defining_paragraph->paragraph_number,
		(defn)?" =":"");
}

#line 129 "inwebc/Chapter 6/Plain Text Format.w"
void plain_pagebreak(FILE *F, weave_target *wv) {
}

#line 135 "inwebc/Chapter 6/Plain Text Format.w"
void plain_blank_line(FILE *F, weave_target *wv, int in_comment) {
	fprintf(F, "\n");
}

#line 142 "inwebc/Chapter 6/Plain Text Format.w"
void plain_code_note(FILE *F, weave_target *wv, char *comment) {
	fprintf(F, "    ...and so on...\n");
}

#line 149 "inwebc/Chapter 6/Plain Text Format.w"
void plain_change_mode(FILE *F, weave_target *wv, int old_mode, int new_mode, int content) {
}

#line 155 "inwebc/Chapter 6/Plain Text Format.w"
void plain_change_colour(weave_target *wv, char *slot, int col, int in_code) {
}

#line 161 "inwebc/Chapter 6/Plain Text Format.w"
void plain_endnote(FILE *F, weave_target *wv, int end) {
	fprintf(F, "\n");
}

#line 168 "inwebc/Chapter 6/Plain Text Format.w"
void plain_identifier(FILE *F, weave_target *wv, char *id) {
	fprintf(F, "%s", id);
}

#line 175 "inwebc/Chapter 6/Plain Text Format.w"
void plain_locale(FILE *F, weave_target *wv, paragraph *par1, paragraph *par2) {
	fprintf(F, "%s%s", par1->ornament, par1->paragraph_number);
	if (par2) fprintf(F, "-%s", par2->paragraph_number);
}

#line 183 "inwebc/Chapter 6/Plain Text Format.w"
void plain_tail(FILE *F, weave_target *wv, char *comment) {
	fprintf(F, "[%s]\n", comment);
}

#line 9 "inwebc/Chapter 6/TeX Format.w"
void tex_top(FILE *F, weave_target *wv, char *comment) {
	fprintf(F, "%% %s\n", comment);
	
{
#line 22 "inwebc/Chapter 6/TeX Format.w"
	string macros_at;
	in_sprintf(macros_at, "%sinweb-macros.tex", path_to_inweb_materials);
	FILE *MACROS = fopen(macros_at, "r");
	if (MACROS == NULL) fatal_filing_system_error("can't open file of TeX macros", macros_at);
	while (TRUE) {
		int c = fgetc(MACROS);
		if (c == EOF) break;
		putc(c, F);
	}
	fclose(MACROS);

}
#line 11 "inwebc/Chapter 6/TeX Format.w"
;
}

#line 36 "inwebc/Chapter 6/TeX Format.w"
void tex_subheading(FILE *F, weave_target *wv, int level, char *comment, char *head) {
	switch (level) {
		case 1:
			fprintf(F, "\\par\\noindent{\\bf %s}\\mark{%s}\\medskip\n",
				comment, head);
			break;
		case 2:
			fprintf(F, "\\smallskip\\par\\noindent{\\it %s}\\smallskip\\noindent\n",
				comment);
			if (head) format_identifier(F, wv, head);
			break;
	}
}

#line 53 "inwebc/Chapter 6/TeX Format.w"
void tex_toc(FILE *F, weave_target *wv, int stage, char *text1, char *text2, paragraph *P) {
	switch (stage) {
		case 1:
			fprintf(F, "\\medskip\\hrule\\smallskip\\par\\noindent{\\usagefont %s.",
				text1);
			break;
		case 2:
			fprintf(F, "; ");
			break;
		case 3:
			fprintf(F, "%s~%s", text1, text2);
			break;
		case 4:
			fprintf(F, "}\\par\\medskip\\hrule\\bigskip\n");
			break;
	}
}

#line 74 "inwebc/Chapter 6/TeX Format.w"
void tex_chapter_tp(FILE *F, weave_target *wv, chapter *C) {
	fprintf(F, "%s\\medskip\n", C->rubric);
	for (section *S2 = C->first_section; S2; S2 = S2->next_section)
		fprintf(F, "\\smallskip\\noindent |%s|: {\\it %s}\\qquad\n%s",
			S2->sigil, S2->sect_title, S2->sect_purpose);
}

#line 84 "inwebc/Chapter 6/TeX Format.w"
void tex_paragraph_heading(FILE *F, weave_target *wv, char *TeX_macro,
	section *S, paragraph *P, char *heading_text, char *chaptermark, char *sectionmark,
	int weight) {
	char *orn = (P)?(P->ornament):"P";
	char *N = (P)?(P->paragraph_number):"";
	string mark; in_strcpy(mark, "");
	in_sprintf(mark, "%s%s\\quad$\\%s$%s", chaptermark, sectionmark, orn, N);
	string modified; in_strcpy(modified, heading_text);
	if (pattern_match(modified, "(%c*?): (%c*)"))
		in_sprintf(modified, "{\\sinchhigh %s}\\quad %s", found_text1, found_text2);
	fprintf(F, "\\%s{%s}{%s}{%s}{\\%s}{%s}%%\n",
		TeX_macro, N, modified, mark, orn, S->sigil);
}

#line 104 "inwebc/Chapter 6/TeX Format.w"
void tex_source_code(FILE *WEAVEOUT, weave_target *wv,
	int tab_stops_of_indentation,
	char *prefatory, char *matter, char *colouring, char *concluding_comment,
	int starts, int finishes, int code_mode) {
	if (code_mode == FALSE) fprintf(WEAVEOUT, "\\smallskip\\par\\noindent");
	if (starts) {
		
{
#line 136 "inwebc/Chapter 6/TeX Format.w"
	for (int i=0; i<tab_stops_of_indentation; i++)
		fprintf(WEAVEOUT, "\\qquad");

}
#line 110 "inwebc/Chapter 6/TeX Format.w"
;
		if (prefatory[0]) fprintf(WEAVEOUT, "{\\ninebf %s} ", prefatory);
		fprintf(WEAVEOUT, "|");
	}
	int current_colour = PLAIN_CODE, colour_wanted = PLAIN_CODE;
	for (int i=0; matter[i]; i++) {
		colour_wanted = colouring[i]; 
{
#line 142 "inwebc/Chapter 6/TeX Format.w"
	if (colour_wanted != current_colour) {
		string col;
		format_change_colour(wv, col, colour_wanted, TRUE);
		fprintf(WEAVEOUT, "%s", col);
		current_colour = colour_wanted;
	}

}
#line 116 "inwebc/Chapter 6/TeX Format.w"
;
		if (matter[i] == '|') fprintf(WEAVEOUT, "|\\||");
		else fprintf(WEAVEOUT, "%c", matter[i]);
	}
	colour_wanted = PLAIN_CODE; 
{
#line 142 "inwebc/Chapter 6/TeX Format.w"
	if (colour_wanted != current_colour) {
		string col;
		format_change_colour(wv, col, colour_wanted, TRUE);
		fprintf(WEAVEOUT, "%s", col);
		current_colour = colour_wanted;
	}

}
#line 120 "inwebc/Chapter 6/TeX Format.w"
;
	if (finishes) {
		fprintf(WEAVEOUT, "|");
		if (concluding_comment[0]) {
			if ((in_string_ne(matter, "")) || (!starts))
				fprintf(WEAVEOUT, "\\hfill\\quad ");
			fprintf(WEAVEOUT, "{\\ttninepoint\\it %s}", concluding_comment);
		}
		fprintf(WEAVEOUT, "\n");
	}
}

#line 152 "inwebc/Chapter 6/TeX Format.w"
void tex_inline_code(FILE *F, weave_target *wv, int enter) {
	fprintf(F, "|");
}

#line 159 "inwebc/Chapter 6/TeX Format.w"
void tex_change_colour(weave_target *wv, char *slot, int col, int in_code) {
	if (wv->format == pdf_format) {
		char *inout = "";
		if (in_code) inout = "|";
		switch (col) {
			case MACRO_CODE: in_sprintf(slot, "%s\\pdfliteral direct{1 1 0 0 k}%s", inout, inout); break;
			case FUNCTION_CODE: in_sprintf(slot, "%s\\pdfliteral direct{0 1 1 0 k}%s", inout, inout); break;
			case PLAIN_CODE: in_sprintf(slot, "%s\\special{PDF:0 g}%s", inout, inout); break;
		}
	}
}

#line 174 "inwebc/Chapter 6/TeX Format.w"
void tex_comment_lines(FILE *F, weave_target *wv, source_line *from, source_line *to) {
}

#line 180 "inwebc/Chapter 6/TeX Format.w"
void tex_display_line(FILE *F, weave_target *wv, char *text) {
	fprintf(F, "\\quotesource{%s}\n", text);
}

#line 187 "inwebc/Chapter 6/TeX Format.w"
void tex_item(FILE *F, weave_target *wv, int depth, char *label) {
	if (label[0]) {
		if (depth == 1) fprintf(F, "\\item{(%s)}", label);
		else fprintf(F, "\\itemitem{(%s)}", label);
	} else {
		if (depth == 1) fprintf(F, "\\item{}");
		else fprintf(F, "\\itemitem{}");
	}
}

#line 200 "inwebc/Chapter 6/TeX Format.w"
void tex_bar(FILE *F, weave_target *wv) {
	fprintf(F, "\\par\\medskip\\noindent\\hrule\\medskip\\noindent\n");
}

#line 212 "inwebc/Chapter 6/TeX Format.w"
void tex_figure(FILE *F, weave_target *wv, char *figname, int cm) {
	if (wv->format == pdf_format) {
		fprintf(F, "\\pdfximage");
		if (cm >= 0)
			fprintf(F, " width %d cm{../Figures/%s}\n", cm, figname);
		else
			fprintf(F, "{../Figures/%s}\n", figname);
		fprintf(F, "\\smallskip\\noindent"
			"\\hbox to\\hsize{\\hfill\\pdfrefximage \\pdflastximage\\hfill}"
			"\\smallskip\n");
	}
}

#line 230 "inwebc/Chapter 6/TeX Format.w"
void tex_cweb_macro(char *matter, weave_target *wv, cweb_macro *cwm, int defn) {
	if (wv->format == pdf_format) {
		if (defn)
			in_sprintf(matter,
				"|\\pdfdest num %d fit ",
				cwm->allocation_id + 100);
		else
			in_sprintf(matter,
				"|\\pdfstartlink attr{/C [0.9 0 0] /Border [0 0 0]} goto num %d ",
				cwm->allocation_id + 100);
	}
	in_strcat(matter, "$\\langle${\\xreffont");
	string col;
	format_change_colour(wv, col, MACRO_CODE, FALSE); in_strcat(matter, col);
	in_strcat(matter, cwm->macro_name);
	in_strcat(matter, " ");
	string rest;
	in_sprintf(rest, "{\\sevenss %s}}", cwm->defining_paragraph->paragraph_number);
	in_strcat(matter, rest);
	format_change_colour(wv, col, PLAIN_CODE, FALSE); in_strcat(matter, col);
	in_strcat(matter, col);
	in_strcat(matter, "$\\rangle$ ");
	if (wv->format == pdf_format) {
		if (defn)
			in_strcat(matter, "$\\equiv$|");
		else
			in_strcat(matter, "\\pdfendlink|");
	}
}

#line 263 "inwebc/Chapter 6/TeX Format.w"
void tex_pagebreak(FILE *F, weave_target *wv) {
	fprintf(F, "\\vfill\\eject\n");
}

#line 270 "inwebc/Chapter 6/TeX Format.w"
void tex_blank_line(FILE *F, weave_target *wv, int in_comment) {
	if (in_comment) fprintf(F, "\\smallskip\\par\\noindent%%\n");
	else fprintf(F, "\\smallskip\n");
}

#line 278 "inwebc/Chapter 6/TeX Format.w"
void tex_endnote(FILE *F, weave_target *wv, int end) {
	if (end == 1) {
		fprintf(F, "\\par\\noindent\\penalty10000\n");
		fprintf(F, "{\\usagefont ");
	} else {
		fprintf(F, "}\\smallskip\n");
	}
}

#line 290 "inwebc/Chapter 6/TeX Format.w"
void tex_identifier(FILE *F, weave_target *wv, char *id) {
	for (int i=0; id[i]; i++) {
		switch (id[i]) {
			case '_': fprintf(F, "\\_"); break;
			case '"':
				if ((id[i] == '"') && ((i==0) || (id[i-1] == ' ')))
					fprintf(F, "``");
				else
					fprintf(F, "''");
				break;
			default: fprintf(F, "%c", id[i]);
		}
	}
}

#line 308 "inwebc/Chapter 6/TeX Format.w"
void tex_locale(FILE *F, weave_target *wv, paragraph *par1, paragraph *par2) {
	fprintf(F, "$\\%s$%s", par1->ornament, par1->paragraph_number);
	if (par2) fprintf(F, "-%s", par2->paragraph_number);
}

#line 316 "inwebc/Chapter 6/TeX Format.w"
void tex_code_note(FILE *F, weave_target *wv, char *comment) {
	fprintf(F, "\\smallskip\\par\\noindent");
	fprintf(F, "{\\ttninepoint\\it ...and so on...}\\smallskip\n");
}

#line 324 "inwebc/Chapter 6/TeX Format.w"
void tex_change_mode(FILE *F, weave_target *wv, int old_mode, int new_mode, int content) {
	if (old_mode != new_mode) {
		switch (old_mode) {
			case REGULAR_MATERIAL:
				switch (new_mode) {
					case CODE_MATERIAL:
						fprintf(F, "\\beginlines\n");
						break;
					case DEFINITION_MATERIAL:
						fprintf(F, "\\beginlines\n");
						break;
					case MACRO_MATERIAL:
						fprintf(F, "\\beginlines\n");
						break;
				}
				break;
			default:
				if (new_mode == REGULAR_MATERIAL)
					fprintf(F, "\\endlines\n");
				break;
		}
	}
}

#line 351 "inwebc/Chapter 6/TeX Format.w"
void tex_tail(FILE *F, weave_target *wv, char *comment) {
	fprintf(F, "%% %s\n", comment);
	fprintf(F, "\\end\n");
}

#line 14 "inwebc/Chapter 6/HTML Formats.w"
int html_in_para = HTML_OUT;
section *page_section = NULL;

void html_top(FILE *F, weave_target *wv, char *comment) {
	string template;
	in_sprintf(template, "%stemplate", path_to_inweb_materials);
	set_bibliographic_data(wv->weave_web, "Booklet Title", wv->booklet_title);
	weave_cover_from(F, wv->weave_web, template, wv, WEAVE_FIRST_HALF);
	string css;
	in_sprintf(css, "%sinweb.css", path_to_inweb_materials);
	issue_os_command_2("cp '%s' '%sWoven'", css, wv->weave_web->path_to_web);

	fprintf(F, "<!--%s-->\n", comment);
	html_in_para = HTML_OUT;
}

#line 45 "inwebc/Chapter 6/HTML Formats.w"
void html_subheading(FILE *F, weave_target *wv, int level, char *comment, char *head) {
	
{
#line 33 "inwebc/Chapter 6/HTML Formats.w"
	if (html_in_para != HTML_OUT) {
		switch (html_in_para) {
			case HTML_IN_P: fprintf(F, "</p>"); break;
			case HTML_IN_PRE: fprintf(F, "</pre>"); break;
			case HTML_IN_ITEM: exit_items(F, 0); break;
		}
		html_in_para = HTML_OUT;
	}

}
#line 46 "inwebc/Chapter 6/HTML Formats.w"
;
	switch (level) {
		case 1: fprintf(F, "<h3>%s</h3>\n", comment); break;
		case 2: fprintf(F, "<p class=\"purpose\">%s: ", comment);
			if (head) format_identifier(F, wv, head);
			fprintf(F, "</p>\n"); break;
	}
}

#line 58 "inwebc/Chapter 6/HTML Formats.w"
void html_toc(FILE *F, weave_target *wv, int stage, char *text1, char *text2, paragraph *P) {
	
{
#line 33 "inwebc/Chapter 6/HTML Formats.w"
	if (html_in_para != HTML_OUT) {
		switch (html_in_para) {
			case HTML_IN_P: fprintf(F, "</p>"); break;
			case HTML_IN_PRE: fprintf(F, "</pre>"); break;
			case HTML_IN_ITEM: exit_items(F, 0); break;
		}
		html_in_para = HTML_OUT;
	}

}
#line 59 "inwebc/Chapter 6/HTML Formats.w"
;
	switch (stage) {
		case 1: fprintf(F, "<ul class=\"toc\"><li>"); break;
		case 2: fprintf(F, "</li><li>"); break;
		case 3:
			fprintf(F, "<a href=\"");
			html_xref(F, wv, P, NULL, TRUE);
			fprintf(F, "\">");
			fprintf(F, "%s%s", (*(P->ornament) == 'S')?"&#167;":"&para;", P->paragraph_number);
			fprintf(F, ". %s</a>", text2);
			break;
		case 4: fprintf(F, "</li></ul><hr class=\"tocbar\">\n"); break;
	}
}

#line 77 "inwebc/Chapter 6/HTML Formats.w"
void html_chapter_tp(FILE *F, weave_target *wv, chapter *C) {
	return;
}

#line 84 "inwebc/Chapter 6/HTML Formats.w"
int crumbs_dropped = FALSE;

void html_paragraph_heading(FILE *F, weave_target *wv, char *TeX_macro,
	section *S, paragraph *P, char *heading_text, char *chaptermark, char *sectionmark,
	int weight) {
	page_section = S;
	if (weight == 3) return; /* Skip chapter headings */
	
{
#line 33 "inwebc/Chapter 6/HTML Formats.w"
	if (html_in_para != HTML_OUT) {
		switch (html_in_para) {
			case HTML_IN_P: fprintf(F, "</p>"); break;
			case HTML_IN_PRE: fprintf(F, "</pre>"); break;
			case HTML_IN_ITEM: exit_items(F, 0); break;
		}
		html_in_para = HTML_OUT;
	}

}
#line 91 "inwebc/Chapter 6/HTML Formats.w"
;
	if (P) {
		fprintf(F, "<p class=\"inwebparagraph\">");
		fprintf(F, "<a name=\"");
		html_xref(F, wv, P, NULL, FALSE);
		fprintf(F, "\"><b>");
		fprintf(F, "%s%s", (*(P->ornament) == 'S')?"&#167;":"&para;", P->paragraph_number);
		fprintf(F, ". %s%s</b> ", heading_text, (*heading_text)?".":"");
		html_in_para = HTML_IN_P;
	} else {
		if (crumbs_dropped == FALSE) {
			string crumb;
			in_sprintf(crumb, "%scrumbs.gif", path_to_inweb_materials);
			copy_files_into_weave(wv->weave_web, crumb);
			crumbs_dropped = TRUE;
		}
		fprintf(F, "<ul id=\"crumbs\">");
		breadcrumb(F, get_bibliographic_data(wv->weave_web, "Title"), "index.html");
		string chapter_link;
		in_sprintf(chapter_link, "index.html#%s", S->owning_chapter->ch_sigil);
		breadcrumb(F, S->owning_chapter->ch_title, chapter_link);
		breadcrumb(F, heading_text, NULL);
		fprintf(F, "</ul>\n");
	}
}

void breadcrumb(FILE *F, char *text, char *link) {
	if (link) fprintf(F, "<li><a href=\"%s\">%s</a></li>", link, text);
	else fprintf(F, "<li><b>%s</b></li>", text);
}

#line 125 "inwebc/Chapter 6/HTML Formats.w"
void html_source_code(FILE *WEAVEOUT, weave_target *wv, int tab_stops_of_indentation,
	char *prefatory, char *matter, char *colouring, char *concluding_comment,
	int starts, int finishes, int code_mode) {
	if (starts) {
		for (int i=0; i<tab_stops_of_indentation; i++)
			fprintf(WEAVEOUT, "    ");
		if (prefatory[0]) fprintf(WEAVEOUT, "<strong>%s</strong> ", prefatory);
	}
	int current_colour = -1, colour_wanted = PLAIN_CODE;
	for (int i=0; matter[i]; i++) {
		colour_wanted = colouring[i]; 
{
#line 156 "inwebc/Chapter 6/HTML Formats.w"
	if (colour_wanted != current_colour) {
		if (current_colour >= 0) fprintf(WEAVEOUT, "</span>");
		string col;
		format_change_colour(wv, col, colour_wanted, TRUE);
		fprintf(WEAVEOUT, "%s", col);
		current_colour = colour_wanted;
	}

}
#line 135 "inwebc/Chapter 6/HTML Formats.w"
;
		if (matter[i] == '<') fprintf(WEAVEOUT, "&lt;");
		else if (matter[i] == '>') fprintf(WEAVEOUT, "&gt;");
		else if (matter[i] == '&') fprintf(WEAVEOUT, "&amp;");
		else fprintf(WEAVEOUT, "%c", matter[i]);
	}
	colour_wanted = PLAIN_CODE; 
{
#line 156 "inwebc/Chapter 6/HTML Formats.w"
	if (colour_wanted != current_colour) {
		if (current_colour >= 0) fprintf(WEAVEOUT, "</span>");
		string col;
		format_change_colour(wv, col, colour_wanted, TRUE);
		fprintf(WEAVEOUT, "%s", col);
		current_colour = colour_wanted;
	}

}
#line 141 "inwebc/Chapter 6/HTML Formats.w"
;
	if (finishes) {
		if (concluding_comment[0]) {
			if ((in_string_ne(matter, "")) || (!starts)) fprintf(WEAVEOUT, "    ");
			fprintf(WEAVEOUT, "<span class=\"comment\">");
			format_identifier(WEAVEOUT, wv, concluding_comment);
			fprintf(WEAVEOUT, "</span>");
		}
		fprintf(WEAVEOUT, "\n");
	}
}

#line 167 "inwebc/Chapter 6/HTML Formats.w"
void html_inline_code(FILE *F, weave_target *wv, int enter) {
	if (enter) fprintf(F, "<code class=\"display\">");
	else fprintf(F, "</code>");
}

#line 175 "inwebc/Chapter 6/HTML Formats.w"
void html_comment_lines(FILE *F, weave_target *wv, source_line *from, source_line *to) {
}

#line 181 "inwebc/Chapter 6/HTML Formats.w"
void html_display_line(FILE *F, weave_target *wv, char *from) {
	
{
#line 33 "inwebc/Chapter 6/HTML Formats.w"
	if (html_in_para != HTML_OUT) {
		switch (html_in_para) {
			case HTML_IN_P: fprintf(F, "</p>"); break;
			case HTML_IN_PRE: fprintf(F, "</pre>"); break;
			case HTML_IN_ITEM: exit_items(F, 0); break;
		}
		html_in_para = HTML_OUT;
	}

}
#line 182 "inwebc/Chapter 6/HTML Formats.w"
;
	fprintf(F, "<blockquote>%s</blockquote>\n", from);
}

#line 189 "inwebc/Chapter 6/HTML Formats.w"
int item_depth = 0;
void html_item(FILE *F, weave_target *wv, int depth, char *label) {
	if (html_in_para != HTML_IN_ITEM) {
		if (html_in_para != HTML_OUT) fprintf(F, "</p>");
		item_depth = 0;
	}
	exit_items(F, depth);

	if (*label) fprintf(F, "(%s) ", label);
	else fprintf(F, " ");
	html_in_para = HTML_IN_ITEM;
}

void exit_items(FILE *F, int depth) {
	if (item_depth == depth) {
		fprintf(F, "</li>");
	} else {
		while (item_depth < depth) {
			fprintf(F, "<ul class=\"items\">"); item_depth++;
		}
		while (item_depth > depth) {
			fprintf(F, "</li></ul>"); item_depth--;
		}
	}
	if (depth > 0) fprintf(F, "<li>");
}

#line 219 "inwebc/Chapter 6/HTML Formats.w"
void html_bar(FILE *F, weave_target *wv) {
	
{
#line 33 "inwebc/Chapter 6/HTML Formats.w"
	if (html_in_para != HTML_OUT) {
		switch (html_in_para) {
			case HTML_IN_P: fprintf(F, "</p>"); break;
			case HTML_IN_PRE: fprintf(F, "</pre>"); break;
			case HTML_IN_ITEM: exit_items(F, 0); break;
		}
		html_in_para = HTML_OUT;
	}

}
#line 220 "inwebc/Chapter 6/HTML Formats.w"
;
	fprintf(F, "<hr>\n");
}

#line 227 "inwebc/Chapter 6/HTML Formats.w"
void html_figure(FILE *F, weave_target *wv, char *figname, int cm) {
	
{
#line 33 "inwebc/Chapter 6/HTML Formats.w"
	if (html_in_para != HTML_OUT) {
		switch (html_in_para) {
			case HTML_IN_P: fprintf(F, "</p>"); break;
			case HTML_IN_PRE: fprintf(F, "</pre>"); break;
			case HTML_IN_ITEM: exit_items(F, 0); break;
		}
		html_in_para = HTML_OUT;
	}

}
#line 228 "inwebc/Chapter 6/HTML Formats.w"
;
	fprintf(F, "<center><img src=\"Figures%c%s\"></center>\n", SEP_CHAR, figname);
}

#line 235 "inwebc/Chapter 6/HTML Formats.w"
void html_cweb_macro(char *matter, weave_target *wv, cweb_macro *cwm, int defn) {
	paragraph *P = cwm->defining_paragraph;
	in_sprintf(matter, "&lt;");
	in_sprcat(matter, "<span class=\"cwebmacro%s\">%s</span>",
		(defn)?"defn":"", cwm->macro_name);
	if (defn == FALSE)
		in_sprcat(matter, "</a>");
	in_sprcat(matter, " <span class=\"cwebmacronumber\">%s</span>&gt;%s",
		P->paragraph_number, (defn)?" =":"");
}

#line 249 "inwebc/Chapter 6/HTML Formats.w"
void html_pagebreak(FILE *F, weave_target *wv) {
	
{
#line 33 "inwebc/Chapter 6/HTML Formats.w"
	if (html_in_para != HTML_OUT) {
		switch (html_in_para) {
			case HTML_IN_P: fprintf(F, "</p>"); break;
			case HTML_IN_PRE: fprintf(F, "</pre>"); break;
			case HTML_IN_ITEM: exit_items(F, 0); break;
		}
		html_in_para = HTML_OUT;
	}

}
#line 250 "inwebc/Chapter 6/HTML Formats.w"
;
}

#line 256 "inwebc/Chapter 6/HTML Formats.w"
void html_blank_line(FILE *F, weave_target *wv, int in_comment) {
	if (in_comment) {
		
{
#line 33 "inwebc/Chapter 6/HTML Formats.w"
	if (html_in_para != HTML_OUT) {
		switch (html_in_para) {
			case HTML_IN_P: fprintf(F, "</p>"); break;
			case HTML_IN_PRE: fprintf(F, "</pre>"); break;
			case HTML_IN_ITEM: exit_items(F, 0); break;
		}
		html_in_para = HTML_OUT;
	}

}
#line 258 "inwebc/Chapter 6/HTML Formats.w"
;
		fprintf(F, "<p>"); html_in_para = HTML_IN_P;
	} else fprintf(F, "\n");
}

#line 266 "inwebc/Chapter 6/HTML Formats.w"
void html_code_note(FILE *F, weave_target *wv, char *comment) {
	
{
#line 33 "inwebc/Chapter 6/HTML Formats.w"
	if (html_in_para != HTML_OUT) {
		switch (html_in_para) {
			case HTML_IN_P: fprintf(F, "</p>"); break;
			case HTML_IN_PRE: fprintf(F, "</pre>"); break;
			case HTML_IN_ITEM: exit_items(F, 0); break;
		}
		html_in_para = HTML_OUT;
	}

}
#line 267 "inwebc/Chapter 6/HTML Formats.w"
;
	fprintf(F, "<p>%s</p>\n", comment);
}

#line 274 "inwebc/Chapter 6/HTML Formats.w"
void html_change_mode(FILE *F, weave_target *wv, int old_mode, int new_mode, int content) {
	if (old_mode != new_mode) {
		if ((content) || (new_mode != MACRO_MATERIAL)) 
{
#line 33 "inwebc/Chapter 6/HTML Formats.w"
	if (html_in_para != HTML_OUT) {
		switch (html_in_para) {
			case HTML_IN_P: fprintf(F, "</p>"); break;
			case HTML_IN_PRE: fprintf(F, "</pre>"); break;
			case HTML_IN_ITEM: exit_items(F, 0); break;
		}
		html_in_para = HTML_OUT;
	}

}
#line 276 "inwebc/Chapter 6/HTML Formats.w"
;
		switch (old_mode) {
			case REGULAR_MATERIAL:
				switch (new_mode) {
					case CODE_MATERIAL:
						fprintf(F, "\n<pre class=\"display\">\n");
						break;
					case DEFINITION_MATERIAL:
						fprintf(F, "\n<pre class=\"definitions\">\n");
						break;
					case MACRO_MATERIAL:
						if (content) fprintf(F, "\n<p class=\"macrodefinition\">");
						fprintf(F, "<code class=\"display\">\n");
						break;
				}
				break;
			case MACRO_MATERIAL:
				fprintf(F, "</code></p>");
				switch (new_mode) {
					case CODE_MATERIAL:
						fprintf(F, "\n<pre class=\"displaydefn\">\n");
						break;
					case DEFINITION_MATERIAL:
						fprintf(F, "\n<pre class=\"definitions\">\n");
						break;
				}
				break;
			case DEFINITION_MATERIAL:
				fprintf(F, "</pre>");
				switch (new_mode) {
					case CODE_MATERIAL:
						fprintf(F, "\n<pre class=\"display\">\n");
						break;
					case MACRO_MATERIAL:
						fprintf(F, "\n<p class=\"macrodefinition\"><code class=\"display\">\n");
						break;
				}
				break;
			default:
				fprintf(F, "</pre>\n");
				break;
		}
	}
}

#line 324 "inwebc/Chapter 6/HTML Formats.w"
void html_change_colour(weave_target *wv, char *slot, int col, int in_code) {
	switch (col) {
		case MACRO_CODE: in_sprintf(slot, "<span class=\"cwebmacrotext\">"); break;
		case FUNCTION_CODE: in_sprintf(slot, "<span class=\"functiontext\">"); break;
		case IDENTIFIER_CODE: in_sprintf(slot, "<span class=\"identifier\">"); break;
		case ELEMENT_CODE: in_sprintf(slot, "<span class=\"element\">"); break;
		case RESERVED_CODE: in_sprintf(slot, "<span class=\"reserved\">"); break;
		case STRING_CODE: in_sprintf(slot, "<span class=\"string\">"); break;
		case CHAR_LITERAL_CODE: in_sprintf(slot, "<span class=\"character\">"); break;
		case CONSTANT_CODE: in_sprintf(slot, "<span class=\"constant\">"); break;
		case PLAIN_CODE: in_sprintf(slot, "<span class=\"plain\">"); break;
		default: printf("col: %d\n", col); fatal_error("internal: bad colour"); break;
	}
}

#line 342 "inwebc/Chapter 6/HTML Formats.w"
void html_endnote(FILE *F, weave_target *wv, int end) {
	if (end == 1) {
		
{
#line 33 "inwebc/Chapter 6/HTML Formats.w"
	if (html_in_para != HTML_OUT) {
		switch (html_in_para) {
			case HTML_IN_P: fprintf(F, "</p>"); break;
			case HTML_IN_PRE: fprintf(F, "</pre>"); break;
			case HTML_IN_ITEM: exit_items(F, 0); break;
		}
		html_in_para = HTML_OUT;
	}

}
#line 344 "inwebc/Chapter 6/HTML Formats.w"
;
		fprintf(F, "<p class=\"endnote\">");
	} else {
		fprintf(F, "</p>\n");
	}
}

#line 354 "inwebc/Chapter 6/HTML Formats.w"
void html_identifier(FILE *F, weave_target *wv, char *id) {
	for (int i=0; id[i]; i++)
		if (id[i] == '&') fprintf(F, "&amp;");
		else if (id[i] == '<') fprintf(F, "&lt;");
		else if (id[i] == '>') fprintf(F, "&gt;");
		else if ((id[i] == ' ') && (id[i+1] == '-') && (id[i+2] == '-') &&
			((id[i+3] == ' ') || (id[i+3] == 0))) {
			fprintf(F, " &mdash;"); i+=2;
		} else fprintf(F, "%c", id[i]);
}

#line 368 "inwebc/Chapter 6/HTML Formats.w"
void html_locale(FILE *F, weave_target *wv, paragraph *par1, paragraph *par2) {
	fprintf(F, "<a href=\"");
	html_xref(F, wv, par1, page_section, TRUE);
	fprintf(F, "\">");
	fprintf(F, "%s%s",
		(*(par1->ornament) == 'S')?"&#167;":"&para;",
		par1->paragraph_number);
	if (par2) fprintf(F, "-%s", par2->paragraph_number);
	fprintf(F, "</a>");
}

#line 382 "inwebc/Chapter 6/HTML Formats.w"
void html_xref(FILE *F, weave_target *wv, paragraph *P, section *from, int a_link) {
	string linkto;
	in_strcpy(linkto, "");
	if ((from) && (P->under_section != from)) {
		in_strcpy(linkto, P->under_section->sigil);
		for (int i=0; linkto[i]; i++)
			if ((linkto[i] == '/') || (linkto[i] == ' '))
				in_set(linkto, i, '-');
		in_strcat(linkto, ".html");
	}
	fprintf(F, "%s%s%s", linkto, (a_link)?"#":"", P->ornament);
	char *N = P->paragraph_number;
	for (int i=0; N[i]; i++)
		if (N[i] == '.') fprintf(F, "_");
		else fprintf(F, "%c", N[i]);
}

#line 402 "inwebc/Chapter 6/HTML Formats.w"
void html_tail(FILE *F, weave_target *wv, char *comment) {
	
{
#line 33 "inwebc/Chapter 6/HTML Formats.w"
	if (html_in_para != HTML_OUT) {
		switch (html_in_para) {
			case HTML_IN_P: fprintf(F, "</p>"); break;
			case HTML_IN_PRE: fprintf(F, "</pre>"); break;
			case HTML_IN_ITEM: exit_items(F, 0); break;
		}
		html_in_para = HTML_OUT;
	}

}
#line 403 "inwebc/Chapter 6/HTML Formats.w"
;
	fprintf(F, "<!--%s-->\n", comment);
	string template;
	in_sprintf(template, "%stemplate", path_to_inweb_materials);
	set_bibliographic_data(wv->weave_web, "Booklet Title", wv->booklet_title);
	weave_cover_from(F, wv->weave_web, template, wv, WEAVE_SECOND_HALF);
}

#line 30 "inwebc/Chapter 6/Running Through TeX.w"

#line 34 "inwebc/Chapter 6/Running Through TeX.w"
int serious_error_count = 0;
tex_results *via_tex = NULL;

void tex_post_process_weave(weave_target *wv, int open_afterwards) {
	tex_results *res = CREATE(tex_results);
	wv->post_processing_results = (void *) res;
	res->overfull_hbox_count = 0;
	res->tex_error_count = 0;
	res->page_count = 0;
	res->pdf_size = 0;

	string tex_leafname; in_strcpy(tex_leafname, "");
	string path_to_tex; in_strcpy(path_to_tex, "");
	string console_filename; in_strcpy(console_filename, "");
	string console_leafname; in_strcpy(console_leafname, "");
	string log_filename; in_strcpy(log_filename, "");
	string pdf_filename; in_strcpy(pdf_filename, "");
	
{
#line 65 "inwebc/Chapter 6/Running Through TeX.w"
	if (pattern_match(wv->weave_to, "(%c+)/(%c+?)")) {
		in_strcpy(path_to_tex, found_text1);
		in_strcpy(tex_leafname, found_text2);
	} else {
		in_strcpy(tex_leafname, wv->weave_to);
		in_strcpy(path_to_tex, "");
	}
	copy_with_changed_extension(console_leafname, tex_leafname, "tex", "console");
	copy_with_changed_extension(console_filename, wv->weave_to, "tex", "console");
	copy_with_changed_extension(log_filename, wv->weave_to, "tex", "log");
	copy_with_changed_extension(pdf_filename, wv->weave_to, "tex", "pdf");
	in_strcpy(res->PDF_filename, pdf_filename);

}
#line 51 "inwebc/Chapter 6/Running Through TeX.w"
;

	serious_error_count = 0; via_tex = res;

	
{
#line 81 "inwebc/Chapter 6/Running Through TeX.w"
	string console_command; in_strcpy(console_command, "");
	if (path_to_tex[0]) in_sprintf(console_command, "cd \"%s\"; ", path_to_tex);
	else in_strcpy(console_command, "");
	char *tool = pdftex_configuration;
	if (wv->format == dvi_format) tool = tex_configuration;
	in_sprintf(console_command + in_strlen(console_command),
		"%s -interaction=scrollmode \"%s\" >\"%s\"",
		tool,
		tex_leafname,
		console_leafname);
	issue_os_command_0(console_command);

}
#line 55 "inwebc/Chapter 6/Running Through TeX.w"
;
	
{
#line 98 "inwebc/Chapter 6/Running Through TeX.w"
	file_read(console_filename, "can't open console file", TRUE, scan_console_line, NULL, NULL);

}
#line 56 "inwebc/Chapter 6/Running Through TeX.w"
;
	
{
#line 108 "inwebc/Chapter 6/Running Through TeX.w"
	if (serious_error_count == 0) {
		issue_os_command_1("rm \"%s\"", console_filename);
		issue_os_command_1("rm \"%s\"", log_filename);
		issue_os_command_1("rm \"%s\"", wv->weave_to);
	}

}
#line 57 "inwebc/Chapter 6/Running Through TeX.w"
;

	if (open_afterwards) 
{
#line 117 "inwebc/Chapter 6/Running Through TeX.w"
	if (in_string_eq(open_configuration, ""))
		fatal_error("no way to open PDF (see configuration file)");
	else
		issue_os_command_2("%s \"%s\"", open_configuration, pdf_filename);

}
#line 59 "inwebc/Chapter 6/Running Through TeX.w"
;
}

#line 125 "inwebc/Chapter 6/Running Through TeX.w"
void scan_console_line(char *line, text_file_position *tfp, void *unused_state) {
	if (pattern_match(line, "Output written %c*? %((%d+) page%c*?(%d+) bytes%).")) {
		via_tex->page_count = atoi(found_text1);
		via_tex->pdf_size = atoi(found_text2);
	}
	if (pattern_match(line, "%c+verfull \\hbox%c+"))
		via_tex->overfull_hbox_count++;
	else if (line[0] == '!') {
		via_tex->tex_error_count++;
		serious_error_count++;
	}
}

#line 141 "inwebc/Chapter 6/Running Through TeX.w"
void tex_report_on_post_processing(weave_target *wv) {
	tex_results *res = wv->post_processing_results;
	if (res) {
		printf(": %dpp %dK", res->page_count, res->pdf_size/1024);
		if (res->overfull_hbox_count > 0)
			printf(", %d overfull hbox(es)", res->overfull_hbox_count);
		if (res->tex_error_count > 0)
			printf(", %d error(s)", res->tex_error_count);
	}
}

#line 155 "inwebc/Chapter 6/Running Through TeX.w"
void copy_with_changed_extension(char *to, char *from, char *old_ext, char *new_ext) {
	in_strcpy(to, from);
	int n = in_strlen(to) - in_strlen(old_ext) - 1;
	if ((n>=0) && (to[n] == '.') && (in_string_eq(to+n+1, old_ext)))
		in_strcpy(to+n+1, new_ext);
}

#line 165 "inwebc/Chapter 6/Running Through TeX.w"
int tex_substitute_post_processing_data(char *to, weave_target *wv, char *detail) {
	if (wv) {
		tex_results *res = wv->post_processing_results;
		if (res) {
			if (in_string_eq(detail, "PDF Size")) {
				in_sprintf(to, "%dKB", res->pdf_size/1024);
			} else if (in_string_eq(detail, "Extent")) {
				in_sprintf(to, "%dpp", res->page_count);
			} else if (in_string_eq(detail, "Leafname")) {
				if (pattern_match(res->PDF_filename, "%c+/(%c+?)"))
					in_strcpy(to, found_text1);
				else
					in_strcpy(to, res->PDF_filename);
			} else if (in_string_eq(detail, "Errors")) {
				in_strcpy(to, "");
				if ((res->overfull_hbox_count > 0) || (res->tex_error_count > 0))
					in_sprintf(to, ": ");
				if (res->overfull_hbox_count > 0)
					in_sprintf(to + in_strlen(to), "%d overfull line%s",
						res->overfull_hbox_count,
						(res->overfull_hbox_count>1)?"s":"");
				if ((res->overfull_hbox_count > 0) && (res->tex_error_count > 0))
					in_sprintf(to + in_strlen(to), ", ");
				if (res->tex_error_count > 0)
					in_sprintf(to + in_strlen(to), "%d TeX error%s",
						res->tex_error_count,
						(res->tex_error_count>1)?"s":"");
			} else return FALSE;
			return TRUE;
		}
	}
	return FALSE;
}

