4/weave: The Weaver.

@Purpose: To weave a portion of the code into instructions for TeX.

@p The Master Weaver.
Here's what has happened so far, on a weave run of Inweb: on any other
sort of run, of course, we would never be in this section of code. The web was
read completely into memory and fully parsed. A request was then made either
to swarm a mass of individual weaves, or to make just a single weave, with the
target in each case being identified by its sigil. A further decoding layer
then translated each sigil into rather more basic details of what to weave and
where to put the result: and so we arrive at the front door of the routine
|weave_source| below.

@c
int weave_source(web *W, weave_target *wv) {
	FILE *F = fopen(wv->weave_to, "w");
	if (F == NULL)
		fatal_filing_system_error("can't open weave file for output", wv->weave_to);

	string banner;
	in_sprintf(banner, "Weave of '%s' generated by %s", wv->booklet_title, INWEB_BUILD);
	format_top(F, wv, banner);

	if (wv->cover_sheet_to_use[0]) @<Weave a cover sheet@>;
	int lines_woven = 0;
	@<Weave the body of the material@>;
	if (wv->cover_sheet_to_use[0]) @<Weave tail of the cover sheet, if any@>;

	string rennab; /* which is |banner| backwards */
	in_sprintf(rennab, "End of weave: %d lines from a web of %d", lines_woven, W->no_lines);
	format_tail(F, wv, rennab);

	fclose(F);
	return lines_woven; /* number of lines woven */
}

@

@<Weave the body of the material@> =
	weaver_state state_at; weaver_state *state = &state_at;
	@<Start the weaver with a clean slate@>;
	for (chapter *C = W->first_chapter; C; C = C->next_chapter) {
		in_strcpy(state->chaptermark, "");
		for (section *S = C->first_section; S; S = S->next_section)
			if (sigil_within(S->sigil, wv->weave_sigil))
				@<Weave this section@>;
	}

@p The state.
We can now begin on a clean page, by initialising the state of the weaver.
It's convenient for these to be global variables since the weaver is not
recursively called, and it avoids some nuisance over scope. The state is
all bundled up into a singleton object, a structure as follows:

@d REGULAR_MATERIAL 1
@d MACRO_MATERIAL 2       /* when a macro is being defined... */
@d DEFINITION_MATERIAL 3  /* ...versus when an |@d| definition is being made */
@d CODE_MATERIAL 4

@c
typedef struct weaver_state {
	int kind_of_material; /* one of the defined |*_MATERIAL| constants above */
	int line_break_pending;
	int weaving_suspended; /* because of ...and so on... markers? */
	int next_heading_without_vertical_skip;
	int show_section_toc_soon; /* is a table of contents for the section imminent? */
	int horizontal_rule_just_drawn;
	struct section *last_extract_from;
	struct paragraph *last_endnoted_para;
	int substantive_comment;
	string chaptermark;
	string sectionmark;
} weaver_state;

@

@<Start the weaver with a clean slate@> =
	state->kind_of_material = REGULAR_MATERIAL;
	state->line_break_pending = FALSE;
	state->weaving_suspended = FALSE;
	state->next_heading_without_vertical_skip = FALSE;
	state->show_section_toc_soon = FALSE;
	state->horizontal_rule_just_drawn = FALSE;
	state->last_extract_from = NULL;
	state->last_endnoted_para = NULL;
	state->substantive_comment = FALSE;
	in_strcpy(state->chaptermark, "");
	in_strcpy(state->sectionmark, "");

@p Weaving a section.

@<Weave this section@> =
	language_begin_weave(S, wv);
	in_strcpy(state->sectionmark, "");
	paragraph *current_paragraph = NULL;
	for (source_line *L = S->first_line; L; L = L->next_line) {
		if ((is_tagged_with(L, wv->theme_match)) &&
			(language_skip_in_weaving(S->sect_language, wv, L) == FALSE)) {
			lines_woven++;
			
			/* In principle, all of these source lines should be woven, but... */
			@<Material between ...and so on... markers is not visible@>;
			@<Certain categories of line are excluded from the weave@>;
			@<Respond to any commands aimed at the weaver, and otherwise skip commands@>;
	
			/* Some of the more baroque front matter of a section... */
			@<Weave the Purpose marker as a little heading@>;
			@<If we need to work in a section table of contents and this is a blank line, do it now@>;
			@<Deal with the Interface passage@>;
			@<Weave the Definitions marker as a little heading@>;
			@<Weave the section bar as a horizontal rule@>;
	
			/* The crucial junction point between modes... */
			@<Deal with the marker for the start of a new paragraph, section or chapter@>;
	
			/* With all exotica dealt with, we now just have material to weave verbatim... */
			string matter; in_strcpy(matter, L->text);
			if (L->is_commentary) @<Weave verbatim matter in commentary style@>
			else @<Weave verbatim matter in code style@>;
		}
	}
	source_line *L = NULL;
	@<Complete any started but not-fully-woven paragraph@>;

@p Reasons to skip things.
We skip material between "...and so on..." markers as being even more
tedious than the rest of the program:

@<Material between ...and so on... markers is not visible@> =
	if (L->category == TOGGLE_WEAVING_LCAT) {
		if (state->weaving_suspended == FALSE) {
			format_code_note(F, wv, "...and so on...");
			state->weaving_suspended = TRUE;
			continue;
		}
		state->weaving_suspended = FALSE;
		continue;
	}
	if (state->weaving_suspended) continue;

@ And we skip these because we weave their contents in some other way:

@<Certain categories of line are excluded from the weave@> =
	if (L->category == INTERFACE_BODY_LCAT) continue;
	if (L->category == PURPOSE_BODY_LCAT) continue;
	if (L->category == BEGIN_VERBATIM_LCAT) continue;

@ And lastly we ignore commands, or act on them if they happen to be aimed
at us; but we don't weave them into the output, that's for sure.

@<Respond to any commands aimed at the weaver, and otherwise skip commands@> =
	if (L->category == COMMAND_LCAT) {
		if (L->command_code == PAGEBREAK_CMD) format_pagebreak(F, wv);
		if (L->command_code == GRAMMAR_INDEX_CMD) weave_grammar_index(F);
		if (L->command_code == FIGURE_CMD) @<Weave a figure@>;
		/* Otherwise assume it was a tangler command, and ignore it here */
		continue;
	}

@

@<Weave a figure@> =
	char *figname = L->text_operand;
	if (pattern_match(figname, "(%d+)cm: (%c+)"))
		format_figure(F, wv, found_text2, atoi(found_text2));
	else
		format_figure(F, wv, figname, -1);

@p Headings.
The purpose is set with a little heading. Its operand is that part of
the purpose-text which is on the opening line; the rest follows on
subsequent lines until the next blank.

@<Weave the Purpose marker as a little heading@> =
	if (L->category == PURPOSE_LCAT) {
		format_subheading(F, wv, 2, "Purpose", S->sect_purpose);
		weave_table_of_contents(F, wv, S);
		continue;
	}

@ This normally appears just after the Purpose subheading:

@<If we need to work in a section table of contents and this is a blank line, do it now@> =
	if ((state->show_section_toc_soon == 1) && (string_is_white_space(L->text))) {
		state->show_section_toc_soon = FALSE;
		if (weave_table_of_contents(F, wv, S)) {
			state->horizontal_rule_just_drawn = TRUE;
		} else {
			state->horizontal_rule_just_drawn = FALSE;
		}
	}

@ After which we have the Interface, except that this is skipped entirely,
as far as weaving is concerned, unless (a) there's a body to it, and (b) we
are in C-for-Inform mode, in which case the body is ignored anyway but
a table of I6 template invocations of the section's functions is set instead:

@<Deal with the Interface passage@> =
	if (L->category == INTERFACE_LCAT) {
		state->horizontal_rule_just_drawn = FALSE;
		L = weave_interface_table_for_section(F, wv, L);
		continue;
	}

@ And another little heading...

@<Weave the Definitions marker as a little heading@> =
	if (L->category == DEFINITIONS_LCAT) {
		format_subheading(F, wv, 2, "Definitions", NULL);
		state->next_heading_without_vertical_skip = TRUE;
		state->horizontal_rule_just_drawn = FALSE;
		continue;
	}

@ ...with the section bar to follow. The bar line completes any half-finished
paragraph and is set as a horizontal rule:

@<Weave the section bar as a horizontal rule@> =
	if (L->category == BAR_LCAT) {
		@<Complete any started but not-fully-woven paragraph@>;
		state->kind_of_material = REGULAR_MATERIAL;
		state->next_heading_without_vertical_skip = TRUE;
		if (state->horizontal_rule_just_drawn == FALSE) format_bar(F, wv);
		continue;
	}

@p Commentary matter.
Typographically this is a fairly simple business, since the commentary is
already by definition written in |TeX| format: it's almost the case that
we only have to transcribe it. But not quite! This is where we implement
the convenient additions Inweb makes to |TeX| syntax.

@<Weave verbatim matter in commentary style@> =
	@<Weave displayed source in its own special style@>;
	@<Weave a blank line as a thin vertical skip and paragraph break@>;
	@<Weave bracketed list indications at start of line into indentation@>;
	@<Weave tabbed code material as a new indented paragraph@>;
	state->substantive_comment = TRUE;
	in_strcat(matter, "\n");
	format_identifier(F, wv, matter);
	continue;

@ Displayed source is the material marked with |>>| arrows in column 1.

@<Weave displayed source in its own special style@> =
	if (L->category == SOURCE_DISPLAY_LCAT) {
		format_display_line(F, wv, L->text_operand);
		continue;
	}

@ Our style is to use paragraphs without initial-line indentation, so we
add a vertical skip between them to show the division more clearly.

@<Weave a blank line as a thin vertical skip and paragraph break@> =
	if (string_is_white_space(matter)) {
		if ((L->next_line) && (L->next_line->category == COMMENT_BODY_LCAT) &&
			(state->substantive_comment)) format_blank_line(F, wv, TRUE);
		continue;
	}

@ Here our extension is simply to provide a tidier way to use |TeX|'s standard
|\item| and |\itemitem| macros for indented list items.

@<Weave bracketed list indications at start of line into indentation@> =
	if (pattern_match(matter, "%(...%) (%c*)")) { /* continue single */
		format_change_mode(F, wv, state->kind_of_material, REGULAR_MATERIAL,
			state->substantive_comment);
		state->kind_of_material = REGULAR_MATERIAL;
		format_item(F, wv, 1, "");
		in_strcpy(matter, found_text1);	
	} else if (pattern_match(matter, "%(-...%) (%c*)")) { /* continue double */
		format_change_mode(F, wv, state->kind_of_material, REGULAR_MATERIAL,
			state->substantive_comment);
		state->kind_of_material = REGULAR_MATERIAL;
		format_item(F, wv, 2, "");
		in_strcpy(matter, found_text1);
	} else if (pattern_match(matter, "%((%i+)%) (%c*)")) { /* begin single */
		format_change_mode(F, wv, state->kind_of_material, REGULAR_MATERIAL,
			state->substantive_comment);
		state->kind_of_material = REGULAR_MATERIAL;
		format_item(F, wv, 1, found_text1);
		in_strcpy(matter, found_text2);
	} else if (pattern_match(matter, "%(-(%i+)%) (%c*)")) { /* begin double */
		format_change_mode(F, wv, state->kind_of_material, REGULAR_MATERIAL,
			state->substantive_comment);
		state->kind_of_material = REGULAR_MATERIAL;
		format_item(F, wv, 2, found_text1);
		in_strcpy(matter, found_text2);
	}

@ Finally, matter encased in vertical strokes one tab stop in from column 1
in the source is set indented in code style.

@<Weave tabbed code material as a new indented paragraph@> =
	if (pattern_match(matter, "\t|(%c*)|(%c*?)")) {
		if (state->kind_of_material != CODE_MATERIAL) {
			format_change_mode(F, wv, state->kind_of_material, CODE_MATERIAL, TRUE);
			state->kind_of_material = CODE_MATERIAL;
		}
		string original; in_strcpy(original, found_text1);
		in_strcpy(matter, found_text2);
		string colouring;
		for (int i=0; original[i]; i++) colouring[i] = PLAIN_CODE;
		colouring[in_strlen(original)] = 0;
		format_source_code(F, wv, 1, "", original, colouring, "", TRUE, TRUE, FALSE);
		format_identifier(F, wv, matter);
		continue;
	} else if (state->kind_of_material != REGULAR_MATERIAL) {
		format_change_mode(F, wv, state->kind_of_material, REGULAR_MATERIAL, TRUE);
		state->kind_of_material = REGULAR_MATERIAL;
	}

@p Code-like matter.
Even though Inweb's approach, unlike |CWEB|'s, is to respect the layout
of the original, this is still quite typographically complex: commentary
and macro usage is rendered differently.

@<Weave verbatim matter in code style@> =
	@<Enter beginlines/endlines mode if necessary@>;
	@<Weave a blank line as a thin vertical skip@>;

	int tab_stops_of_indentation = 0;
	@<Convert leading space in line matter to a number of tab stops@>;

	string prefatory; in_strcpy(prefatory, "");
	string concluding_comment; in_strcpy(concluding_comment, "");
	@<Extract any comment matter ending the line to be set in italic@>;
	@<Give constant definition lines slightly fancier openings@>;

	if (language_weave_code_line(S->sect_language, F, wv,
		W, C, S, L, matter, concluding_comment)) continue;

	string colouring;
	language_syntax_colour(S->sect_language, F, wv, W, C, S, L, matter, colouring);

	int found = 0;
	while (pattern_match(matter, "(%c*?)%@%<(%c*?)%@%>(%c*)")) {
		in_strcpy(matter, found_text3);
		cweb_macro *cwm = get_cweb_macro_by_name(found_text2, S);
		format_source_code(F, wv, tab_stops_of_indentation, prefatory,
			found_text1, colouring, concluding_comment, (found == 0)?TRUE:FALSE, FALSE, TRUE);	
		found++;
		int defn = (L->owning_paragraph == cwm->defining_paragraph)?TRUE:FALSE;
		string mac;
		format_cweb_macro(mac, wv, cwm, defn);
		fprintf(F, "%s", mac);
		if (defn) in_strcpy(matter, "");
		string temp; in_strcpy(temp, colouring);
		in_strcpy(colouring, temp+in_strlen(temp)-in_strlen(matter));
	}
	format_source_code(F, wv, tab_stops_of_indentation, prefatory,
		matter, colouring, concluding_comment, (found == 0)?TRUE:FALSE, TRUE, TRUE);

	continue;

@ Code is typeset between the |\beginlines| and |\endlines| macros in |TeX|, so:

@<Enter beginlines/endlines mode if necessary@> =
	int mode_now = state->kind_of_material;
	if (state->kind_of_material != CODE_MATERIAL) {
		if (L->category == MACRO_DEFINITION_LCAT)
			state->kind_of_material = MACRO_MATERIAL;
		else if ((L->category == BEGIN_DEFINITION_LCAT) ||
				(L->category == CONT_DEFINITION_LCAT))
			state->kind_of_material = DEFINITION_MATERIAL;
		else
			state->kind_of_material = CODE_MATERIAL;
		format_change_mode(F, wv, mode_now, state->kind_of_material,
			state->substantive_comment);
		state->line_break_pending = FALSE;
	}

@ A blank line is typeset as a thin vertical skip (no |TeX| paragraph break
is needed):

@<Weave a blank line as a thin vertical skip@> =
	if (state->line_break_pending) {
		format_blank_line(F, wv, FALSE);
		state->line_break_pending = FALSE;
	}
	if (string_is_white_space(matter)) {
		state->line_break_pending = TRUE;
		continue;
	}

@ Examine the white space at the start of the code line, and count the
number of tab steps of indentation, rating 1 tab = 4 spaces:

@<Convert leading space in line matter to a number of tab stops@> =
	int spaces_in = 0;
	while (white_space(matter[0])) {
		if (matter[0] == '\t') {
			spaces_in = 0;
			tab_stops_of_indentation++;
		} else {
			spaces_in++;
			if (spaces_in == 4) {
				tab_stops_of_indentation++;
				spaces_in = 0;
			}
		}
		in_strcpy(found_text1, matter+1);
		in_strcpy(matter, found_text1);
	}

@ Comments which run to the end of a line are set in italic type. If the
only item on their lines, they are presented at the code tab stop;
otherwise, they are set flush right.

@<Extract any comment matter ending the line to be set in italic@> =
	string part_before_comment; in_strcpy(part_before_comment, "");
	string part_within_comment; in_strcpy(part_within_comment, "");
	if (language_parse_comment(S->sect_language,
		matter, part_before_comment, part_within_comment)) {
		in_strcpy(matter, part_before_comment);
		in_strcpy(concluding_comment, part_within_comment);
	}

@ Set the |@d| definition escape very slightly more fancily:

@<Give constant definition lines slightly fancier openings@> =
	if (pattern_match(matter, "@d (%c*)")) {
		in_strcpy(prefatory, "define");
		in_strcpy(matter, found_text1);
	}

@pp How paragraphs begin.

@<Deal with the marker for the start of a new paragraph, section or chapter@> =
	if ((L->category == PB_PARAGRAPH_START_LCAT) ||
		(L->category == PARAGRAPH_START_LCAT) ||
		(L->category == CHAPTER_HEADING_LCAT) ||
		(L->category == SECTION_HEADING_LCAT)) {
		@<Complete any started but not-fully-woven paragraph@>;
		if (wv->theme_match)
			@<If this is a paragraph break forced onto a new page, then throw a page@>;

		int weight = 0;
		if (L->category == PB_PARAGRAPH_START_LCAT) weight = 1;
		if (L->category == SECTION_HEADING_LCAT) weight = 2;
		if (L->category == CHAPTER_HEADING_LCAT) weight = 3;

		@<Work out the next mark to place into the |TeX| vertical list@>;

		char *TeX_macro = "";
		@<Choose which |TeX| macro to use in order to typeset the new paragraph heading@>;
		
		string heading_text;
		if (weight == 3) {
			string brief_title; in_strcpy(brief_title, "");
			if (pattern_match(C->ch_title, "%c*?: (%c*)"))
				in_strcpy(brief_title, found_text1);
			else
				in_strcpy(brief_title, C->ch_title);
			in_sprintf(heading_text, "%s: %s", C->ch_sigil, brief_title);
		} else {
			in_strcpy(heading_text, L->text_operand);
		}
		
		format_paragraph_heading(F, wv, TeX_macro, S, L->owning_paragraph,
			heading_text, state->chaptermark, state->sectionmark, weight);

		if (weight == 0) state->substantive_comment = FALSE;
		else state->substantive_comment = TRUE;

		/* There's quite likely ordinary text on the line following the paragraph */
		/* start indication, too, so we need to weave this out: */
		
		if (in_string_ne(L->text_operand2, "")) {
			string matter;
			in_sprintf(matter, "%s\n", L->text_operand2);
			format_identifier(F, wv, matter);
			state->substantive_comment = TRUE;
		}
			
		/* Chapter headings get a chapter title page, or possibly pages, too: */
		if (weight == 3) format_chapter_tp(F, wv, C);
		
		/* And that completes the new paragraph opening. */
		continue;
	}

@ A few paragraphs are marked |@pp| and forced to begin on a new page:

@<If this is a paragraph break forced onto a new page, then throw a page@> =
	if ((L->owning_paragraph) &&
		(L->owning_paragraph->starts_on_new_page)) format_pagebreak(F, wv);

@ "Marks" are the vile contrivance by which |TeX| produces running heads
on pages which follow the material on those pages: so that the running
head for a page can show the paragraph sigil for the material which tops
it, for instance.

The ornament has to be set in math mode, even in the mark. $\S$ and $\P$
only work in math mode because they abbreviate characters found in math
fonts but not regular ones, in |TeX|'s deeply peculiar font encoding system.

@<Work out the next mark to place into the |TeX| vertical list@> =
	if (weight == 3) {
		in_strcpy(state->chaptermark, L->text_operand);
		in_strcpy(state->sectionmark, "");
	}
	if (weight == 2) {
		in_strcpy(state->sectionmark, L->text_operand);
		if (S->sigil[0]) in_strcpy(state->chaptermark, S->sigil);
		if (in_string_ne(state->chaptermark, ""))
			in_sprintf(state->sectionmark, " - %s", L->text_operand);
	}

@ We want to have different heading styles for different weights, and |TeX| is
horrible at using macro parameters as function arguments, so we don't want
to pass the weight that way. Instead we use
	
	|\weavesection|
	|\weavesections|
	|\weavesectionss|
	|\weavesectionsss|

where the weight is the number of terminal |s|s, 0 to 3. (|TeX| macros,
lamentably, are not allowed digits in their name.) In the cases 0 and 1, we
also have variants |\nsweavesection| and |\nsweavesections| which are
the same, but with the initial vertical spacing removed; these allow us to
prevent unsightly excess white space in certain configurations of a section.

@<Choose which |TeX| macro to use in order to typeset the new paragraph heading@> =
	switch (weight) {
		case 0: TeX_macro = "weavesection"; break;
		case 1: TeX_macro = "weavesections"; break;
		case 2: TeX_macro = "weavesectionss"; break;
		default: TeX_macro = "weavesectionsss"; break;
	}
	if (wv->theme_match) @<Apply special rules for thematic extracts@>;
	if ((state->next_heading_without_vertical_skip) && (weight < 2)) {
		state->next_heading_without_vertical_skip = FALSE;
		switch (weight) {
			case 0: TeX_macro = "nsweavesection"; break;
			case 1: TeX_macro = "nsweavesections"; break;
		}
	}

@ If we are weaving a selection of extracted paragraphs, normal conventions
about breaking pages at chapters and sections fail to work. So:

@<Apply special rules for thematic extracts@> =
	switch (weight) {
		case 0: TeX_macro = "tweavesection"; break;
		case 1: TeX_macro = "tweavesections"; break;
		case 2: TeX_macro = "tweavesectionss"; break;
		default: TeX_macro = "tweavesectionsss"; break;
	}
	if (weight >= 0) { weight = 0; }
	if (state->last_extract_from != S) {
		state->last_extract_from = S;
		format_pagebreak(F, wv);
		string extr; in_sprintf(extr, "From %s: %s", C->ch_title, S->sect_title);
		format_subheading(F, wv, 1, extr, C->ch_title);
	}

@p How paragraphs end.
At the end of a paragraph, on the other hand, we do this:

@<Complete any started but not-fully-woven paragraph@> =
	int mode_now = state->kind_of_material;
	if (state->kind_of_material != REGULAR_MATERIAL) {
		state->kind_of_material = REGULAR_MATERIAL;
		format_change_mode(F, wv, mode_now, state->kind_of_material, TRUE);
	}
	if ((current_paragraph) && (current_paragraph != state->last_endnoted_para)) {
		state->last_endnoted_para = current_paragraph;
		show_endnotes_on_previous_paragraph(F, wv, current_paragraph);
	}
	if (L) current_paragraph = L->owning_paragraph;

@ The endnotes describe function calls from far away, or unexpected
structure usage, or how |CWEB|-style code substitutions were made.

@c
void show_endnotes_on_previous_paragraph(FILE *F, weave_target *wv, paragraph *P) {
	if (P->defines_macro) {
		format_endnote(F, wv, 1);
		format_identifier(F, wv, "This code is ");
		int ct = 0;
		for (macro_usage *mu = P->defines_macro->macro_usages; mu; mu = mu->next_macro_usage)
			ct++;
		if (ct == 1) format_identifier(F, wv, "never used");
		else {
			int k = 0, used_flag = FALSE;
			for (macro_usage *mu = P->defines_macro->macro_usages; mu; mu = mu->next_macro_usage)
				if (P != mu->used_in_paragraph) {
					if (used_flag) {
						if (k < ct-1) format_identifier(F, wv, ", ");
						else format_identifier(F, wv, " and ");
					} else {
						format_identifier(F, wv, "used in ");
					}
					format_locale(F, wv, mu->used_in_paragraph, NULL);
					used_flag = TRUE; k++;
					switch (mu->multiplicity) {
						case 1: break;
						case 2: format_identifier(F, wv, " (twice)"); break;
						case 3: format_identifier(F, wv, " (three times)"); break;
						case 4: format_identifier(F, wv, " (four times)"); break;
						case 5: format_identifier(F, wv, " (five times)"); break;
						default: {
							string mt;
							in_sprcat(mt, " (%d times)", mu->multiplicity);
							format_identifier(F, wv, mt);
							break;
						}
					}
				}
		}
		format_identifier(F, wv, ".");
		format_endnote(F, wv, 2);
	}

	function *fn;
	for (fn = P->first_defined_in_paragraph; fn; fn = fn->next_defined_in_paragraph) {
		format_endnote(F, wv, 1);
		hash_table_entry *hte = find_hash_entry(fn->function_header_at->owning_section, fn->function_name, FALSE);
		format_identifier(F, wv, "The function ");
		format_identifier(F, wv, fn->function_name);
		int used_flag = FALSE;
		hash_table_entry_usage *hteu = NULL;
		section *last_cited_in = NULL;
		int count_under = 0;
		for (hteu = hte->first_usage; hteu; hteu = hteu->next_usage)
			if ((P != hteu->usage_recorded_at) &&
				(P->under_section == hteu->usage_recorded_at->under_section))
				@<Cite usage of function here@>;
		for (hteu = hte->first_usage; hteu; hteu = hteu->next_usage)
			if (P->under_section != hteu->usage_recorded_at->under_section)
				@<Cite usage of function here@>;
		if (used_flag == FALSE) format_identifier(F, wv, " appears nowhere else");
		if ((last_cited_in != P->under_section) && (last_cited_in))
			format_identifier(F, wv, ")");
		format_identifier(F, wv, ".");
		format_endnote(F, wv, 2);
	}

	c_structure *st;
	for (st = P->first_c_structure_in_para; st; st = st->next_c_structure_in_para) {
		format_endnote(F, wv, 1);
		format_identifier(F, wv, "The structure ");
		format_identifier(F, wv, st->structure_name);
		
		section *S;
		LOOP_OVER(S, section) S->scratch_flag = FALSE;
		for (structure_element *elt = st->first_element; elt; elt = elt->next_element) {
			hash_table_entry *hte = find_hash_entry(elt->element_created_at->owning_section, elt->element_name, FALSE);
			if (hte)
				for (hash_table_entry_usage *hteu = hte->first_usage; hteu; hteu = hteu->next_usage)
					if (hteu->form_of_usage & ELEMENT_ACCESS_USAGE)
						hteu->usage_recorded_at->under_section->scratch_flag = TRUE;
		}
		
		int usage_count = 0, external = 0;
		LOOP_OVER(S, section)
			if (S->scratch_flag) {
				usage_count++;
				if (S != P->under_section) external++;
			}
		if (external == 0) format_identifier(F, wv, " is private to this section");
		else {
			format_identifier(F, wv, " is accessed in ");
			int c = 0;
			LOOP_OVER(S, section)
				if ((S->scratch_flag) && (S != P->under_section)) {
					if (c++ > 0) format_identifier(F, wv, ", ");
					format_identifier(F, wv, S->sigil);
				}
			if (P->under_section->scratch_flag) format_identifier(F, wv, " and here");
		}
		format_identifier(F, wv, ".");
		format_endnote(F, wv, 2);
	}
}

@

@<Cite usage of function here@> =
	if (used_flag == FALSE) format_identifier(F, wv, " is used in ");
	used_flag = TRUE;
	section *S = hteu->usage_recorded_at->under_section;
	if ((S != last_cited_in) && (S != P->under_section)) {
		count_under = 0;
		if (last_cited_in) {
			if (last_cited_in != P->under_section) format_identifier(F, wv, "), ");
			else format_identifier(F, wv, ", ");
		}
		format_identifier(F, wv, hteu->usage_recorded_at->under_section->sigil);
		format_identifier(F, wv, " (");
	}
	if (count_under++ > 0) format_identifier(F, wv, ", ");
	format_locale(F, wv, hteu->usage_recorded_at, NULL);
	last_cited_in = hteu->usage_recorded_at->under_section;

@p Section tables of contents.

@c
int weave_table_of_contents(FILE *F, weave_target *wv, section *S) {
	int noteworthy = 0;
	for (paragraph *P = S->first_paragraph; P; P = P->next_paragraph_in_section)
		if ((P->weight > 0) && ((S->barred == FALSE) || (P->above_bar == FALSE)))
			noteworthy++;
	if (noteworthy == 0) return FALSE;

	format_toc(F, wv, 1, S->sigil, "", NULL);
	noteworthy = 0;
	for (paragraph *P = S->first_paragraph; P; P = P->next_paragraph_in_section)
		if ((P->weight > 0) && ((S->barred == FALSE) || (P->above_bar == FALSE))) {
			if (noteworthy > 0) format_toc(F, wv, 2, "", "", NULL);
			paragraph *LP = NULL, *CP = P->next_paragraph_in_section;
			while ((CP) && (CP->weight == 0)) {
				LP = CP; CP = CP->next_paragraph_in_section;
			}
			string loc;
			in_sprintf(loc, "%s%s", P->ornament, P->paragraph_number);
			format_toc(F, wv, 3, loc, P->first_line_in_paragraph->text_operand, P);
			noteworthy++;
		}
	format_toc(F, wv, 4, "", "", NULL);
	return TRUE;
}

@p The cover sheet.
This is added to the front of larger PDFs; whole chapters and the complete work.
People will probably want to customise this, so it's implemented as a |TeX|
file which we substitute bibliographic data into.

@<Weave a cover sheet@> =
	set_bibliographic_data(W, "Booklet Title", wv->booklet_title);
	weave_cover_from(F, W, wv->cover_sheet_to_use, wv, WEAVE_FIRST_HALF);

@

@<Weave tail of the cover sheet, if any@> =
	set_bibliographic_data(W, "Booklet Title", wv->booklet_title);
	weave_cover_from(F, W, wv->cover_sheet_to_use, wv, WEAVE_SECOND_HALF);

@ Note that the substitution |[[Cover Sheet]]| embeds the whole default cover
sheet; this is so that we can just add a continuation of that, if we want to.

@d WEAVE_FIRST_HALF 1
@d WEAVE_SECOND_HALF 2
@d IN_SECOND_HALF 4

@c
FILE *WEAVE_COVER_TO = NULL;
int weave_cover_halves = 0;

int weave_cover_from(FILE *F, web *W, char *cs_filename, weave_target *wv, int halves) {
	int swc = weave_cover_halves;
	weave_cover_halves = halves;
	WEAVE_COVER_TO = F;
	string full_filename;
	in_sprintf(full_filename, "%s%s", cs_filename, weave_file_extension(wv->format));
	file_read(full_filename, "can't open cover sheet file", TRUE,
		scan_cover_line, NULL, (void *) wv);
	weave_cover_halves = swc;
	return 0;
}

void scan_cover_line(char *line, text_file_position *tfp, void *state) {
	int include = FALSE;
	if (((weave_cover_halves & WEAVE_FIRST_HALF) &&
			((weave_cover_halves & IN_SECOND_HALF) == 0)) ||
		((weave_cover_halves & WEAVE_SECOND_HALF) &&
			(weave_cover_halves & IN_SECOND_HALF))) include = TRUE;
	
	weave_target *wv = (weave_target *) state;
	string matter; in_strcpy(matter, line);
	while (pattern_match(matter, "(%c*?)%[%[(%c*?)%]%](%c*)")) {
		string left; in_strcpy(left, found_text1);
		string middle; in_strcpy(middle, found_text2);
		string right; in_strcpy(right, found_text3);
		fprintf(WEAVE_COVER_TO, "%s", left);
		if (in_string_eq(middle, "Code")) {
			weave_cover_halves |= IN_SECOND_HALF;
		} else if (in_string_eq(middle, "Cover Sheet")) {
			if ((include) && ((weave_cover_halves & IN_SECOND_HALF) == 0)) {
				string default_cs;
				in_sprintf(default_cs, "%scover-sheet", path_to_inweb_materials);
				weave_cover_from(WEAVE_COVER_TO, wv->weave_web, default_cs, wv, WEAVE_FIRST_HALF);
			}
		} else if (bibliographic_data_exists(wv->weave_web, middle)) {
			if (include)
				fprintf(WEAVE_COVER_TO, "%s", get_bibliographic_data(wv->weave_web, middle));
		} else {
			if (include) fprintf(WEAVE_COVER_TO, "%s", middle);
		}
		in_strcpy(matter, right);
	}
	if (include) fprintf(WEAVE_COVER_TO, "%s\n", matter);
}

@p Interface.

@d SHOW_INTERFACES FALSE

@c
source_line *weave_interface_table_for_section(FILE *F, weave_target *wv, source_line *L) {
	if (SHOW_INTERFACES) {
		format_subheading(F, wv, 2, "Interface", NULL);
		format_change_mode(F, wv, REGULAR_MATERIAL, CODE_MATERIAL, TRUE);
	}
	source_line *CL = L->next_line, *LL = L;
	while ((CL) && (CL->next_line) &&
		(CL->owning_paragraph == L->owning_paragraph) &&
		(CL->category == COMMENT_BODY_LCAT)) {
		LL = CL;
		if ((SHOW_INTERFACES) && (string_is_white_space(CL->text) == FALSE)) {
			string colouring;
			for (int i=0; CL->text[i]; i++) colouring[i] = PLAIN_CODE;
			colouring[in_strlen(CL->text)] = 0;
			format_source_code(F, wv, 1, "", CL->text, colouring, "",
				TRUE, TRUE, TRUE);
		}
		CL = CL->next_line;
	}
	if (SHOW_INTERFACES) {
		format_change_mode(F, wv, CODE_MATERIAL, REGULAR_MATERIAL, TRUE);
	}
	return LL;
}
