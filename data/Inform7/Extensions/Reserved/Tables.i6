! Tables.i6 segment

! A table T is represented by a "table" array: T-->0 holds the
! number of columns (which is at most 99) and T-->i is the address
! of column number i.
! Columns are therefore numbered from 1 to T-->0, but they are also
! identified by an ID number of 100 or more, with each different
! column name having its own ID number.
! Each column C is also a "table" array, with C-->1 holding the unique
! ID number for the column's name, C-->2 holding the blank entry flags
! offset and C-->3 up to C-->(C-->0) holding the entries.
! C-->1 also contains four upper bit flags. These are also defined in
! Tables.w in the NI source, and the values must agree.

Constant I7_COLUMN_SIGNED $4000;
Constant I7_COLUMN_TOPIC $2000;
Constant I7_COLUMN_DONTSORTME $1000;
Constant I7_COLUMN_NOBLANKBITS $0800;
Constant I7_COLUMN_CANEXCHANGE $0400;
Constant I7_COLUMN_ALLOCATED $0200;
Constant I7_COLUMN_NUMBER $01ff; ! Mask to remove upper bit flags

Constant COL_HSIZE 2; ! Column header size: two words (ID/flags, blank bits)

Array T_empty_table --> 0 0;

[ TableFindCol tab col f i j n;
	j = tab-->0;
	for (i=1:i<=j:i++)
		if (col == ((tab-->i)-->1) & I7_COLUMN_NUMBER) return i;
	if (f) return RunTimeProblem(RTP_TABLE_NOCOL, tab);
	return 0;
];

! The columns in a table can be assumed all to have the same
! height (i.e., number of rows): thus the number of rows in T
! can be calculated by looking at column 1, thus...

[ TableRows tab; return ((tab-->1)-->0) - COL_HSIZE; ];

! The following dummy value is invalid for most types and unlikely in the
! others, so is used to suggest an empty cell. We cannot be certain that a
! cell is empty unless it both contains this value and also has the
! corresponding bit set in the blanks bitmap for the column (unless the
! column is one with the I7_COLUMN_NOBLANKBITS flag set, in which case
! its data type is such that I7 can prove that the dummy value is certain
! to mean that the cell is blank).

#ifdef TARGET_ZCODE;
Constant I7_TABLE_NOVALUE $7fe3;
#ifnot; ! TARGET_GLULX
Constant I7_TABLE_NOVALUE $deadce11;
#endif; ! TARGET_

! The following should be used only where the entry has been found to be
! I7_TABLE_NOVALUE, so that it is probably a blank. For some columns we
! can immediately deduce from the value that this is indeed true, but
! for others we have to consult the "blank bits".

Array CheckTableEntryIsBlank_LU
	->	$$00000001
		$$00000010
		$$00000100
		$$00001000
		$$00010000
		$$00100000
		$$01000000
		$$10000000;
Array CheckTableEntryIsNonBlank_LU
	->	$$11111110
		$$11111101
		$$11111011
		$$11110111
		$$11101111
		$$11011111
		$$10111111
		$$01111111;

[ CheckTableEntryIsBlank tab col row i at;
	if (col >= 100) col=TableFindCol(tab, col);
	if (col == 0) rtrue;
	if ((tab-->col)-->(row+COL_HSIZE) ~= I7_TABLE_NOVALUE) {
		print "*** CTEIB on nonblank value: ", tab, " ", col, " ", row, "^";
	}
	if (((tab-->col)-->1) & I7_COLUMN_NOBLANKBITS) rtrue;
	row--;
	at = ((tab-->col)-->2) + (row/8);
	!print "Check nonblank at = ", at, "^";
	!print "Started = ", I7_T_Blanks->at, "^";
	if ((I7_T_Blanks->at) & (CheckTableEntryIsBlank_LU->(row%8))) rtrue;
	rfalse;
];

[ ForceTableEntryBlank tab col row i at oldv flags;
	if (col >= 100) col=TableFindCol(tab, col);
	if (col == 0) rtrue;
	flags = (tab-->col)-->1;
	oldv = (tab-->col)-->(row+COL_HSIZE);
	!print "Force so: ", col, " ", row, " ", flags, " ", oldv, "^";
	if ((flags & I7_COLUMN_ALLOCATED) &&
		(oldv ~= 0 or I7_TABLE_NOVALUE)) {
		I7_Blk_Free(oldv);
	}
	(tab-->col)-->(row+COL_HSIZE) = I7_TABLE_NOVALUE;
	if (flags & I7_COLUMN_NOBLANKBITS) return;
	row--;
	at = ((tab-->col)-->2) + (row/8);
	(I7_T_Blanks->at) 
		= (I7_T_Blanks->at) | (CheckTableEntryIsBlank_LU->(row%8));
];

[ ForceTableEntryNonBlank tab col row i at oldv flags tc kov j;
	if (col >= 100) col=TableFindCol(tab, col);
	if (col == 0) rtrue;
	if (((tab-->col)-->1) & I7_COLUMN_NOBLANKBITS) return;
	flags = (tab-->col)-->1;
	oldv = (tab-->col)-->(row+COL_HSIZE);
	!print "Force not: ", col, " ", row, " ", flags, " ", oldv, "^";
	if ((flags & I7_COLUMN_ALLOCATED) &&
		(oldv == 0 or I7_TABLE_NOVALUE)) {
		kov = UNKNOWN_TY;
		tc = ((tab-->col)-->1) & I7_COLUMN_NUMBER;
		for (j=0: I7_TC_KOV-->j: j=j+2)
			if (I7_TC_KOV-->j == tc)
				kov = I7_TC_KOV-->(j+1);
		if (kov ~= UNKNOWN_TY)
			(tab-->col)-->(row+COL_HSIZE) = I7_Blk_Create(kov);
	}
	row--;
	at = ((tab-->col)-->2) + (row/8);
	!print "Force nonblank at = ", at, "^";
	!print "Started = ", I7_T_Blanks->at, "^";
	(I7_T_Blanks->at) 
		= (I7_T_Blanks->at) & (CheckTableEntryIsNonBlank_LU->(row%8));
	!print "Finished = ", I7_T_Blanks->at, "^";
];

[ TableSwapBlankBits tab row1 row2 col at1 at2 bit1 bit2;
	if (col >= 100) col=TableFindCol(tab, col);
	if (col == 0) rtrue;
	if (((tab-->col)-->1) & I7_COLUMN_NOBLANKBITS) return;
	row1--;
	at1 = ((tab-->col)-->2) + (row1/8);
	row2--;
	at2 = ((tab-->col)-->2) + (row2/8);
	bit1 = ((I7_T_Blanks->at1) & (CheckTableEntryIsBlank_LU->(row1%8)));
	bit2 = ((I7_T_Blanks->at2) & (CheckTableEntryIsBlank_LU->(row2%8)));
	if (bit1) bit1 = true; 
	if (bit2) bit2 = true;
	if (bit1 == bit2) return;
	if (bit1) {
		(I7_T_Blanks->at1)
			= (I7_T_Blanks->at1) & (CheckTableEntryIsNonBlank_LU->(row1%8));
		(I7_T_Blanks->at2)
			= (I7_T_Blanks->at2) | (CheckTableEntryIsBlank_LU->(row2%8));
	} else {
		(I7_T_Blanks->at1)
			= (I7_T_Blanks->at1) | (CheckTableEntryIsBlank_LU->(row1%8));
		(I7_T_Blanks->at2)
			= (I7_T_Blanks->at2) & (CheckTableEntryIsNonBlank_LU->(row2%8));
	}
];

[ TableMoveBlankBitsDown tab row1 row2 col at atp1 bit rx;
	if (col >= 100) col=TableFindCol(tab, col);
	if (col == 0) rtrue;
	if (((tab-->col)-->1) & I7_COLUMN_NOBLANKBITS) return;
	row1--; row2--;
	! Read blank bit for row1:
	at = ((tab-->col)-->2) + (row1/8);
	bit = ((I7_T_Blanks->at) & (CheckTableEntryIsBlank_LU->(row1%8)));
	if (bit) bit = true;
	! Loop through, setting each blank bit to the next:
	for (rx=row1:rx<row2:rx++) {
		atp1 = ((tab-->col)-->2) + ((rx+1)/8);
		at = ((tab-->col)-->2) + (rx/8);
		if ((I7_T_Blanks->atp1) & (CheckTableEntryIsBlank_LU->((rx+1)%8))) {
			(I7_T_Blanks->at)
				= (I7_T_Blanks->at) | (CheckTableEntryIsBlank_LU->(rx%8));
		} else {
			(I7_T_Blanks->at)
				= (I7_T_Blanks->at) & (CheckTableEntryIsNonBlank_LU->(rx%8));
		}
	}
	! Write bit to blank bit for row2:
	at = ((tab-->col)-->2) + (row2/8);
	if (bit) {
		(I7_T_Blanks->at)
			= (I7_T_Blanks->at) | (CheckTableEntryIsBlank_LU->(row2%8));
	} else {
		(I7_T_Blanks->at)
			= (I7_T_Blanks->at) & (CheckTableEntryIsNonBlank_LU->(row2%8));
	}
];

! TableRowCorr(T, C, V) returns the first row on which value V
! appears in column C of table T, or prints an error if it doesn't.

[ TableRowCorr tab col lookup_value lookup_col i j;
	if (col >= 100) col=TableFindCol(tab, col, true);
	lookup_col = tab-->col;
	j = lookup_col-->0 - COL_HSIZE;
	for (i=1:i<=j:i++)
		if (lookup_col-->(i+COL_HSIZE) == lookup_value) {
			if ((lookup_value == I7_TABLE_NOVALUE) &&
				(CheckTableEntryIsBlank(tab,col,i))) continue;
			return i;
		}
	return RunTimeProblem(RTP_TABLE_NOCORR, tab);
];

! ExistsTableRowCorr(T, C, V) returns the first row on which V
! appears in column C of table T, or 0 if V does not occur at all.

[ ExistsTableRowCorr tab col entry i k v f a b;
	if (col >= 100) col=TableFindCol(tab, col);
	if (col == 0) rfalse;
	f = ((tab-->col)-->1) & I7_COLUMN_TOPIC;
	k = TableRows(tab);
	for (i=1:i<=k:i++) {
		! print "Checking row ", i, "^";
		v = (tab-->col)-->(i+COL_HSIZE);
		if ((v == I7_TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col,i))) continue;
		if (f) {
			if ((entry >= 256) && (entry == consult_from + 256*consult_words)) {
				a = consult_from; b = consult_words;
			} else {
				a = entry/100; b = entry%100;
			}
			! print "a,b = ", a, ",", b, "^";
		    if ((v)(a, b) ~= GPR_FAIL) return i;
		} else {
		    if (v == entry) return i;
		}
	}
	! print "Giving up^";
	return 0;
];

! TableLookUpCorr(T, C1, C2, V) finds the first row on which value
! V appears in column C2, and returns the corresponding value in C1,
! or prints an error if the value V cannot be found or has no
! corresponding value in C1.

[ TableLookUpCorr tab col1 col2 lookup_value write_flag write_value cola1 cola2 i j v;
	if (col1 >= 100) col1=TableFindCol(tab, col1, true);
	if (col2 >= 100) col2=TableFindCol(tab, col2, true);
	cola1 = tab-->col1;
	cola2 = tab-->col2;
	j = cola2-->0;
	for (i=1+COL_HSIZE:i<=j:i++)
		if (cola2-->i == lookup_value) {
		    if (write_flag) {
		    	ForceTableEntryNonBlank(tab,col1,i-COL_HSIZE);
		    	cola1-->i = write_value;
		    	rfalse;
		    }
			v = cola1-->i;
			if ((v == I7_TABLE_NOVALUE) &&
				(CheckTableEntryIsBlank(tab,col1,i-COL_HSIZE))) continue;
			return v;
		}
	return RunTimeProblem(RTP_TABLE_NOCORR, tab);
];

! ExistsTableLookUpCorr(T, C1, C2, V) returns true if the operation
! TableLookUpCorr(T, C1, C2, V) can be done, false otherwise.

[ ExistsTableLookUpCorr tab col1 col2 lookup_value cola1 cola2 i j;
	if (col1 >= 100) col1=TableFindCol(tab, col1, false);
	if (col2 >= 100) col2=TableFindCol(tab, col2, false);
	if (col1*col2 == 0) rfalse;
	cola1 = tab-->col1; cola2 = tab-->col2;
	j = cola2-->0;
	for (i=1+COL_HSIZE:i<=j:i++)
		if (cola2-->i == lookup_value) {
			if ((cola1-->i == I7_TABLE_NOVALUE) &&
				(CheckTableEntryIsBlank(tab,col1,i-COL_HSIZE))) continue;
			rtrue;
		}
	rfalse;
];

! TableLookUpEntry(T, C, R) returns the value at column C, row R,
! printing an error if that doesn't exist.

[ TableLookUpEntry tab col index write_flag write_value v;
	if (col >= 100) col=TableFindCol(tab, col, true);
	if ((index < 1) || (index > TableRows(tab)))
		return RunTimeProblem(RTP_TABLE_NOROW, tab, index);
	if (write_flag) {
		switch(write_flag) {
			1:	ForceTableEntryNonBlank(tab,col,index);
				(tab-->col)-->(index+COL_HSIZE) = write_value;
			2:	ForceTableEntryNonBlank(tab,col,index);
				(tab-->col)-->(index+COL_HSIZE) =
					((tab-->col)-->(index+COL_HSIZE)) + write_value;
			3:	ForceTableEntryNonBlank(tab,col,index);
				(tab-->col)-->(index+COL_HSIZE) =
					((tab-->col)-->(index+COL_HSIZE)) - write_value;
			4:	ForceTableEntryBlank(tab,col,index);
			5:	ForceTableEntryNonBlank(tab,col,index);
				return ((tab-->col)-->(index+COL_HSIZE));
		}
		rfalse;
	}
	v = ((tab-->col)-->(index+COL_HSIZE));
	if ((v == I7_TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col,index)))
		return RunTimeProblem(RTP_TABLE_NOENTRY, tab, col, 0, index);
	return v;
];

! ExistsTableLookUpEntry(T, C, R) returns true if a value exists
! at column C, row R, false otherwise.

[ ExistsTableLookUpEntry tab col index v;
	if (col >= 100) col=TableFindCol(tab, col);
	if (col == 0) rfalse;
	if ((index<1) || (index > TableRows(tab))) rfalse;
	v = ((tab-->col)-->(index+COL_HSIZE));
	if ((v == I7_TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col,index)))
		rfalse;
	rtrue;
];

! TableRowIsBlank(T, R) returns true if row R of table T is blank.
! (R must be a legal row number.)

[ TableRowIsBlank tab j k;
	for (k=1:k<=tab-->0:k++) {
		if (((tab-->k)-->(j+COL_HSIZE)) ~= I7_TABLE_NOVALUE) rfalse;
		if (CheckTableEntryIsBlank(tab, k, j) == false) rfalse;
	}
	rtrue;
];

! TableBlankOutRow(T, R) fills row R of table T with blanks.
! (R must be a legal row number.)

[ TableBlankOutRow tab j k;
	if (tab==0) return RunTimeProblem(RTP_TABLE_NOTABLE, tab);
	for (k=1:k<=tab-->0:k++)
		ForceTableEntryBlank(tab, k, j);
];

! TableBlankRows(T) returns the number of blank rows in T.

[ TableBlankRows tab i j c;
	i = TableRows(tab); !print i, " rows^";
	for (j=1:j<=i:j++)
		if (TableRowIsBlank(tab, j)) c++;
	!print c, " blank^";
	return c;
];

! TableFilledRows(T) returns the number of non-blank rows in T.

[ TableFilledRows tab;
	return TableRows(tab) - TableBlankRows(tab);
];

! TableBlankRow(T) finds the first blank row in T.

[ TableBlankRow tab i j;
	i = TableRows(tab);
	for (j=1:j<=i:j++)
		if (TableRowIsBlank(tab, j)) return j;
	RunTimeProblem(RTP_TABLE_NOMOREBLANKS, tab);
	return i;
];

! TableRandomRow(T) chooses a random non-blank row in T.

[ TableRandomRow tab i j k;
	i = TableRows(tab);
	j = TableFilledRows(tab);
	if (j==0) return RunTimeProblem(RTP_TABLE_NOROWS, tab);
	if (j>1) j = random(j);
	for (k=1:k<=i:k++) {
		if (TableRowIsBlank(tab, k) == false) j--;
		if (j==0) return k;
	}
];

! TableSwapRows(T, R1, R2) exchanges rows R1 and R2.

[ TableSwapRows tab i j k l v1 v2;
	if (i==j) return;
	l = tab-->0;
	for (k=1:k<=l:k++) {
		v1 = (tab-->k)-->(i+COL_HSIZE);
		v2 = (tab-->k)-->(j+COL_HSIZE);
		(tab-->k)-->(i+COL_HSIZE) = v2;
		(tab-->k)-->(j+COL_HSIZE) = v1;
		if ((v1 == I7_TABLE_NOVALUE) || (v2 == I7_TABLE_NOVALUE))
			TableSwapBlankBits(tab, i, j, k);
	}
];

[ TableMoveRowDown tab r1 r2 rx k l m v f;
	if (r1==r2) return;
	l = tab-->0;
	for (k=1:k<=l:k++) {
		f = false;
		m = (tab-->k)-->(r1+COL_HSIZE);
		if (m == I7_TABLE_NOVALUE) f = true;
		for (rx=r1:rx<r2:rx++) {
			v = (tab-->k)-->(rx+COL_HSIZE+1);
			(tab-->k)-->(rx+COL_HSIZE) = v;
			if (v == I7_TABLE_NOVALUE) f = true;
		}
		(tab-->k)-->(r2+COL_HSIZE) = m;
		if (f) TableMoveBlankBitsDown(tab, r1, r2, k);
	}
];

! TableShuffle(T) sorts T into random row order.

[ TableShuffle tab i j k;
	k = TableRows(tab);
	for (i=2:i<=k:i++) TableSwapRows(tab, i, random(i));
];

! TableNextRow(T, C, R, D) is used when scanning through a
! table in order of the values in column C: ascending order
! if D = 1, descending if D = -1. The current position is row R
! of column C, or R=0 if we have not yet found the first row.
! The return value is the row number for the next value, or 0
! if we are already at the final value. Note that if there
! are several equal values in the column, they will be run
! through in turn, in order of their physical row numbers -
! ascending if D = 1, descending if D = -1, so that using
! the routine with D = -1 always produces the exact reverse
! ordering from using it with D = 1 and the same parameters.
! Rows with blank entries in C are skipped.
!
! for (R=TableNextRow(T,C,0,D): R : R=TableNextRow(T,C,R,D)) ...
! will perform a loop of valid row numbers in order of column C.

[ TableNextRow tab col row dir i k val v dv min_dv min_at signed_arithmetic f;
	if (col >= 100) col=TableFindCol(tab, col, false);
	signed_arithmetic = ((tab-->col)-->1) & I7_COLUMN_SIGNED;
	#ifdef TARGET_ZCODE;
	if (row == 0) {
		if (signed_arithmetic) {
		    if (dir == 1) val = $8000; else val = $7fff;
		} else {
		    if (dir == 1) val = 0; else val = $ffff;
		}
	} else val = (tab-->col)-->(row+COL_HSIZE);
	if (signed_arithmetic) min_dv = $7fff; else min_dv = $ffff;
	#ifnot; ! TARGET_GLULX
	if (row == 0) {
		if (signed_arithmetic) {
		    if (dir == 1) val = $80000000; else val = $7fffffff;
		} else {
		    if (dir == 1) val = 0; else val = $ffffffff;
		}
	} else val = (tab-->col)-->(row+COL_HSIZE);
	if (signed_arithmetic) min_dv = $7fffffff; else min_dv = $ffffffff;
	#endif; ! TARGET_
	k = TableRows(tab);
	if (dir == 1) {
		for (i=1:i<=k:i++) {
		    v = (tab-->col)-->(i+COL_HSIZE);
		    if ((v == I7_TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col,i)))
		    	continue;
		    dv = dir*v;
		    if (signed_arithmetic)
		    f = (((dv > dir*val) || ((v == val) && (i>row))) &&
				  (dv < min_dv));
		    else
		    f = (((UnsignedCompare(dv, dir*val) > 0) || ((v == val) && (i>row))) &&
				  (UnsignedCompare(dv, min_dv) < 0));
		    if (f) { min_dv = dv; min_at = i; }
		}
	} else {
		for (i=k:i>=1:i--) {
		    v = (tab-->col)-->(i+COL_HSIZE);
		    if ((v == I7_TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col,i)))
		    	continue;
		    dv = dir*v;
		    if (signed_arithmetic)
		    f = (((dv > dir*val) || ((v == val) && (i<row))) &&
				  (dv < min_dv));
		    else
		    f = (((UnsignedCompare(dv, dir*val) > 0) || ((v == val) && (i<row))) &&
				  (UnsignedCompare(dv, min_dv) < 0));
		    if (f) { min_dv = dv; min_at = i; }
		}
	}
	return min_at;
];

! TableCompareRows(T, C, R1, R2, D) returns:
! +1 if the entry at row R1 of column C is > the entry at row R2,
! 0 if they are equal, and
! -1 if entry at R1 < entry at R2.
! When D = +1, a blank value is > all other values, so that in
! an ascending sort the blanks come last; when D = -1, a blank
! value is < all others, so that once again blanks are last.
! Finally, a wholly blank row is always placed after a row in
! which the entry in C is blank but where other entries are not.

[ TableCompareRows tab col row1 row2 dir val1 val2 bl1 bl2;
	if (col >= 100) col=TableFindCol(tab, col, false);
	val1 = (tab-->col)-->(row1+COL_HSIZE);
	val2 = (tab-->col)-->(row2+COL_HSIZE);
	if (val1 == I7_TABLE_NOVALUE) bl1 = CheckTableEntryIsBlank(tab,col,row1);
	if (val2 == I7_TABLE_NOVALUE) bl2 = CheckTableEntryIsBlank(tab,col,row2);
	if ((val1 == val2) && (bl1 == bl2)) {
		if (val1 ~= I7_TABLE_NOVALUE) return 0;
		if (bl1 == false) return 0;
		! The two entries are both blank:
		if (TableRowIsBlank(tab, row1)) {
		    if (TableRowIsBlank(tab, row2)) return 0;
		    return -1*dir;
		}
		if (TableRowIsBlank(tab, row2)) return dir;
		return 0;
	}
	if (bl1) return -1*dir;
	if (bl2) return dir;
	if (((tab-->col)-->1) & I7_COLUMN_SIGNED) {
		if (val1 > val2) return 1;
		return -1;
	} else {
		if (UnsignedCompare(val1, val2) > 0) return 1;
		return -1;
	}
];

[ TableMoveBlanksToBack tab fromrow torow i fbl lnbl blc;
	if (torow<fromrow) return;
	fbl = 0; lnbl = 0;
	for (i=fromrow:i<=torow:i++)
		if (TableRowIsBlank(tab, i)) {
			if (fbl == 0) fbl = i;
			blc++;
		} else {
			lnbl = i;
		}
	!print "First blank is ", fbl, "^";
	!print "Last nonblank is ", lnbl, "^";
	if ((fbl>0) && (lnbl>0) && (fbl < lnbl)) {
		TableMoveRowDown(tab, fbl, lnbl); ! Move first blank just past last nonblank
		TableMoveBlanksToBack(tab, fbl+1, lnbl-1);
	}
	return torow-blc; ! Final non-blank row
];

[ TableColumnDebug tab col k i v;
	if (col >= 100) col=TableFindCol(tab, col, false);
	k = TableRows(tab);
	print "Table col ", col, ": ";
	for (i=1:i<=k:i++) {
		v = (tab-->col)-->(i+COL_HSIZE);
		if ((v == I7_TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col,i)))
			print "BLANK ";
		else print v, " ";
	}
	print "*^";
];

[ TableSort tab col dir test_flag algorithm i j k f;
	for (i=1:i<=tab-->0:i++) {
		j = tab-->i; ! Address of column table
		if ((j-->1) & I7_COLUMN_DONTSORTME)
		    return RunTimeProblem(RTP_TABLE_CANTSORT, tab);
	}
	if (col >= 100) col=TableFindCol(tab, col, false);
	!print "Initial state:^"; TableColumnDebug(tab, col);

	k = TableRows(tab);
	k = TableMoveBlanksToBack(tab, 1, k);
	if (test_flag) {
		print "After moving blanks to back:^"; TableColumnDebug(tab, col);
	}

	I7_Sort(tab, col, dir, k, test_flag, algorithm);

	if (test_flag) {
		print "Final state:^"; TableColumnDebug(tab, col);
	}
];

[ TablePrint tab i j k row col v tc kov;
	for (i=1:i<=tab-->0:i++) {
		j = tab-->i; ! Address of column table
		if (((j-->1) & I7_COLUMN_CANEXCHANGE) == 0)
		    rtrue;
	}
	k = TableRows(tab);
	k = TableMoveBlanksToBack(tab, 1, k);
	print "! ", (PrintTableName) tab, " (", k, ")^";
	for (row=1:row<=k:row++) {
		for (col=1:col<=tab-->0:col++) {
			tc = ((tab-->col)-->1) & I7_COLUMN_NUMBER;
			kov = NUMBER_TY;
			for (i=0: I7_TC_KOV-->i: i=i+2)
				if (I7_TC_KOV-->i == tc)
					kov = I7_TC_KOV-->(i+1);
			v = (tab-->col)-->(row+COL_HSIZE);
			if ((v == I7_TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col,row)))
				print "-- ";
			else {
				if (I7_Blk_Write_File_Form(v, kov) == false) print v;
				print " ";
			}
		}
		print "^";
	}
	rfalse;
];

#ifdef TARGET_GLULX;
[ TableRead tab auxf row maxrow col ch v sgn dg j tc kov;
	for (col=1:col<=tab-->0:col++) {
		j = tab-->col; ! Address of column table
		if (((j-->1) & I7_COLUMN_CANEXCHANGE) == 0)
		    return RunTimeProblem(RTP_TABLE_CANTSAVE, tab);
	}
	maxrow = TableRows(tab);
	!print maxrow, " rows available.^";
	for (row=1: row<=maxrow: row++) {
		TableBlankOutRow(tab, row);
	}
	for (row=1: row<=maxrow: row++) {
		!print "Reading row ", row, "^";
		ch = I7_FileIO_GetC(auxf);
		if (ch == '!') {
			while (ch ~= -1 or 10 or 13) ch = I7_FileIO_GetC(auxf);
			while (ch == 10 or 13) ch = I7_FileIO_GetC(auxf);
		}
		for (col=1: col<=tab-->0: col++) {
			if (ch == -1) { row++; jump NoMore; }
			if (ch == 10 or 13) break;
			tc = ((tab-->col)-->1) & I7_COLUMN_NUMBER;
			kov = NUMBER_TY;
			for (j=0: I7_TC_KOV-->j: j=j+2)
				if (I7_TC_KOV-->j == tc)
					kov = I7_TC_KOV-->(j+1);
			!print "tc = ", tc, " kov = ", kov, "^";
			sgn = 1;
			if (ch == '-') {
				ch = I7_FileIO_GetC(auxf);
				if (ch == -1) jump NotTable;
				if (ch == '-') { ch = I7_FileIO_GetC(auxf); jump EntryDone; }
				sgn = -1;
			}
			if (((tab-->col)-->1) & I7_COLUMN_ALLOCATED)
				ForceTableEntryNonBlank(tab, col, row);
			!print "A";
			v = I7_Blk_Read_File_Form(0, 0, -1, kov);
			if (v) {
				if (((tab-->col)-->1) & I7_COLUMN_ALLOCATED)
					v = I7_Blk_Read_File_Form(TableLookUpEntry(tab, col, row),
						auxf, ch, kov);
				else
					v = I7_Blk_Read_File_Form(0, auxf, ch, kov);
				ch = 32;
			} else {
				dg = ch - '0';
				if ((dg < 0) || (dg > 9)) jump NotTable;
				v = dg;
				for (::) {
					ch = I7_FileIO_GetC(auxf);
					dg = ch - '0';
					if ((dg < 0) || (dg > 9)) break;
					v = 10*v + dg;
				}
				v = v*sgn;
			}
			!print "v=", v, " ";
			if (((tab-->col)-->1) & I7_COLUMN_ALLOCATED == 0)
				TableLookUpEntry(tab, col, row, true, v);
			.EntryDone;
			!print "First nd is ", ch, "^";
			while (ch == 9 or 32) ch = I7_FileIO_GetC(auxf);
		}
		while (ch ~= -1 or 10 or 13) {
			if ((ch ~= '-') && (((ch-'0')<0) || ((ch-'0')>9))) jump NotTable;
			if (ch ~= 9 or 32) jump WontFit;
			ch = I7_FileIO_GetC(auxf);
		}
	}
	.NoMore;
	while (ch == 9 or 32 or 10 or 13) ch = I7_FileIO_GetC(auxf);
	if (ch == -1) return;
	.WontFit;
	return RunTimeProblem(RTP_TABLE_WONTFIT, tab);
	.NotTable;
	return RunTimeProblem(RTP_TABLE_BADFILE, tab);
];
#ENDIF; ! TARGET_GLULX

#ifdef I7_RANKING_TABLE;
[ PrintRank i j v;
	print ", earning you the rank of ";
	j = TableRows(I7_RANKING_TABLE);
	for (i=j:i>=1:i--)
		if (score >= TableLookUpEntry(I7_RANKING_TABLE, 1, i)) {
		    v = TableLookUpEntry(I7_RANKING_TABLE, 2, i);
		    if (v ofclass String) print (string) v;
		    else v();
		    ".";
		}
	".";
];
#endif;

! Sorting algorithms.
! We are required to use a stable sorting algorithm with very low, ideally
! zero, auxiliary storage requirement. Exchanges are generally slower than
! comparisons.

Global I7S_Tab;
Global I7S_Col;
Global I7S_Dir;
#ifdef MEASURE_SORT_PERFORMANCE;
Global I7S_CCOUNT;
Global I7S_CCOUNT2;
Global I7S_XCOUNT;
#endif;

[ I7_Sort tab col dir size test_flag algorithm;
	I7S_Tab = tab;
	I7S_Col = col;
	I7S_Dir = dir;
	#ifdef MEASURE_SORT_PERFORMANCE;
	I7S_CCOUNT = 0;
	I7S_CCOUNT2 = 0;
	I7S_XCOUNT = 0;
	#endif;
	I7_Sort_Range(0, size, algorithm);
	#ifdef MEASURE_SORT_PERFORMANCE;
	if (test_flag)
		print "Sorted array of size ", size, " with ", I7S_CCOUNT2, "*10000 + ", I7S_CCOUNT,
			" comparisons and ", I7S_XCOUNT, " exchanges^";
	#endif;
];

[ I7_Sort_Range x y algorithm;
	if (y - x < 2) return;
	if (algorithm) {
		(algorithm)(x, y);
	} else {
		I7_InPlaceMergeSort(x, y);
	}
];

[ I7_Sort_Compare x y;
	#ifdef MEASURE_SORT_PERFORMANCE;
	I7S_CCOUNT++;
	if (I7S_CCOUNT == 10000) { I7S_CCOUNT = 0; I7S_CCOUNT2++; }
	#endif;
	return I7S_Dir*TableCompareRows(I7S_Tab, I7S_Col, x+1, y+1, I7S_Dir);
];

[ I7_Sort_Exchange x y;
	#ifdef MEASURE_SORT_PERFORMANCE;
	I7S_XCOUNT++;
	if (I7S_XCOUNT < 0) { print "XO^"; I7S_XCOUNT = 0; }
	#endif;
	return TableSwapRows(I7S_Tab, x+1, y+1);
];

! Sorting algorithm used in builds up to and including 4W37: note that this is
! not quite bubble sort, and that it is unstable. It is now no longer used.

[ I7_4W37Sort x y
	f i j;
	if (y - x < 2) return;
	f = true;
	while (f) {
		f = false;
		for (i=x:i<y:i++)
		    for (j=i+1:j<y:j++)
				if (I7_Sort_Compare(i, j) > 0) {
					I7_Sort_Exchange(i, j); f = true; break;
				}
	}
];

! Insertion sort: stable and O(n^2) running time, but better performance on
! nearly sorted tables, and with very low overhead.

[ I7_InsertionSort from to
	i j;
	if (to > from+1) { 
		for (i = from+1: i < to: i++) { 
			for (j = i: j > from: j--) { 
				if (I7_Sort_Compare(j, j-1) < 0) 
					I7_Sort_Exchange(j, j-1);
				else break;
			}
		}
	}
];

! In place mergesort: stable and O(n log n) running time, at some stack cost,
! and generally good for nearly sorted tables, but complex and with overhead.
! The code here mostly follows Thomas Baudel's implementation, which in turn
! follows the C++ STL library.

[ I7_InPlaceMergeSort from to
	middle;
	if (to - from < 12) {
		if (to - from < 2) return;
		I7_InsertionSort(from, to);
		return;
	}
	middle = (from + to)/2; 
	I7_InPlaceMergeSort(from, middle); 
	I7_InPlaceMergeSort(middle, to); 
	IPMS_Merge(from, middle, to, middle-from, to - middle); 
];

[ IPMS_Lower from to val
	len half mid;
	len = to - from;
	while (len > 0) { 
		half = len/2; 
		mid = from + half;
		if (I7_Sort_Compare(mid, val) < 0) {
			from = mid + 1;
			len = len - half -1; 
		} else len = half;
	}
	return from;
];

[ IPMS_Upper from to val
	len half mid;
	len = to - from;
	while (len > 0) { 
		half = len/2; 
		mid = from + half;
		if (I7_Sort_Compare(val, mid) < 0)
			len = half;
		else {
			from = mid + 1;
			len = len - half -1; 
		}
	}
	return from;
];

[ IPMS_Reverse from to;
	while (from < to) {
		I7_Sort_Exchange(from++, to--);
	}
];

[ IPMS_Rotate from mid to
	n val shift p1 p2;
	if ((from==mid) || (mid==to)) return; 
	IPMS_Reverse(from, mid-1); 
	IPMS_Reverse(mid, to-1); 
	IPMS_Reverse(from, to-1);
];

[ IPMS_Merge from pivot to len1 len2
	first_cut second_cut len11 len22 new_mid;
	if ((len1 == 0) || (len2 == 0)) return; 
	if (len1+len2 == 2) { 
		if (I7_Sort_Compare(pivot, from) < 0) 
		I7_Sort_Exchange(pivot, from); 
		return; 
	}
	if (len1 > len2) { 
		len11 = len1/2; 
		first_cut = from + len11; 
		second_cut = IPMS_Lower(pivot, to, first_cut); 
		len22 = second_cut - pivot; 
	} else { 
		len22 = len2/2; 
		second_cut = pivot + len22; 
		first_cut = IPMS_Upper(from, pivot, second_cut); 
		len11 = first_cut - from; 
	} 
	IPMS_Rotate(first_cut, pivot, second_cut); 
	new_mid = first_cut + len22; 
	IPMS_Merge(from, first_cut, new_mid, len11, len22); 
	IPMS_Merge(new_mid, second_cut, to, len1 - len11, len2 - len22); 
];

! End of Tables.i6
