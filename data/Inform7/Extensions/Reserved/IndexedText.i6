! IndexedText.i6

#IFDEF I7_HEAP_SIZE; ! Will exist if any use is made of indexed texts

Constant I7_IT_Storage_Glulx_Unicode;

#IFDEF TARGET_ZCODE;
Constant I7_IT_Storage_Flags = BLK_FLAG_MULTIPLE;
Constant I7_ZSCII_Tables;
#IFNOT;
#IFDEF I7_IT_Storage_Glulx_Unicode;
Constant I7_IT_Storage_Flags = BLK_FLAG_MULTIPLE + BLK_FLAG_16_BIT;
Constant I7_Large_Unicode_Tables;
#IFNOT;
Constant I7_IT_Storage_Flags = BLK_FLAG_MULTIPLE;
Constant I7_Small_Unicode_Tables;
#ENDIF;
#ENDIF;

{-segment:UnicodeData.i6}
{-segment:Char.i6}

! Compulsory services required by NI:

[ I7_INDEXED_TEXT_TY_Create opcast x;
	x =  I7_Blk_Allocate(32, INDEXED_TEXT_TY, I7_IT_Storage_Flags);
	!print "Created as ", I7_Blk_Type(x), "^";
	if (opcast) I7_INDEXED_TEXT_TY_Cast(opcast, TEXT_TY, x);
	return x;
];

[ I7_INDEXED_TEXT_TY_Free indt;
];

[ I7_INDEXED_TEXT_TY_Deep_Copy ito ifrom;
];

[ I7_INDEXED_TEXT_TY_Say indt ch i dsize;
	if ((indt==0) || (I7_Blk_Type(indt) ~= INDEXED_TEXT_TY)) return;
	dsize = I7_Blk_Get_Extent(indt);
	for (i=0:i<dsize:i++) {
		ch = I7_Blk_Get(indt, i);
		if (ch == 0) break;
		#ifdef TARGET_ZCODE;
		print (char) ch;
		#ifnot; ! TARGET_ZCODE
			#ifdef I7_IT_Storage_Glulx_Unicode;
			glk_put_char_uni(ch);
			#ifnot; ! I7_IT_Storage_Glulx_Unicode
			print (char) ch;
			#endif;
		#endif;
	}
];

#ifndef I7_IT_MAX_LENGTH;
Constant I7_IT_MAX_LENGTH = 512;
#endif;

#ifdef TARGET_ZCODE;
Array I7_Raw_Buffer -> I7_IT_MAX_LENGTH;
#ifnot;
#IFDEF I7_IT_Storage_Glulx_Unicode;
Array I7_Raw_Buffer --> I7_IT_MAX_LENGTH;
#ifnot; ! I7_IT_Storage_Glulx_Unicode
Array I7_Raw_Buffer -> I7_IT_MAX_LENGTH;
#endif; ! I7_IT_Storage_Glulx_Unicode
Array I7_Raw_Buffer_Results --> 2;
#endif;

Global I7_Raw_Buffer_Address = I7_Raw_Buffer;
Global I7_Raw_Buffer_Size = I7_IT_MAX_LENGTH;
!Global I7_Raw_Buffer_Size = 10;

[ I7_INDEXED_TEXT_TY_Cast tx fromkov indt len i str oldstr offs realloc news;
	.RetryWithLargerBuffer;
	!print "trying with buffer length ", I7_Raw_Buffer_Size, "^";
	if (tx == 0) {
		#ifdef TARGET_ZCODE;
		I7_Raw_Buffer_Address-->0 = 1;
		I7_Raw_Buffer_Address->2 = 0;
		#ifnot;
		I7_Raw_Buffer_Address-->0 = 0;
		#endif;
		len = 1;
	} else {
		#ifdef TARGET_ZCODE;
		@output_stream 3 I7_Raw_Buffer_Address;
		#ifnot;
		oldstr = glk_stream_get_current();
		#IFDEF I7_IT_Storage_Glulx_Unicode;
		str = glk_stream_open_memory_uni(I7_Raw_Buffer_Address, I7_Raw_Buffer_Size, filemode_Write, 0);
		#IFNOT;
		str = glk_stream_open_memory(I7_Raw_Buffer_Address, I7_Raw_Buffer_Size, filemode_Write, 0);
		#ENDIF;
		glk_stream_set_current(str);
		#endif;
		if (fromkov == SNIPPET_TY) print (PrintSnippet) tx;
		else {
			if (tx ofclass String) print (string) tx;
			if (tx ofclass Routine) (tx)();	
		}
		#ifdef TARGET_ZCODE;
		@output_stream -3;
		len = I7_Raw_Buffer_Address-->0;
		if (len > I7_Raw_Buffer_Size-1) len = I7_Raw_Buffer_Size-1;
		offs = 2;
		I7_Raw_Buffer_Address->(len+2) = 0;
		#ifnot; ! i.e. GLULX
		
		glk_stream_close(str, I7_Raw_Buffer_Results);
		glk_stream_set_current(oldstr);
		len = I7_Raw_Buffer_Results-->1; ! "Writecount"
		if (len > I7_Raw_Buffer_Size-1) {
			!print "Possible buffer overrun^";
			@gestalt 7 0 i;
			if (i ~= 0) {
				!print "gestalt allows^";
				news = I7_Raw_Buffer_Size;
				while (news < len) news=news*2;
				news = news*4; ! Bytes rather than words
				@malloc news i;
				if (i ~= 0) {
					I7_Raw_Buffer_Address = i;
					I7_Raw_Buffer_Size = news/4;
					!print "Increasing raw buffer size to ", I7_Raw_Buffer_Size, "^";
					jump RetryWithLargerBuffer;
				}
			}
			!print "gestalt refused: trimming^";
			len = I7_Raw_Buffer_Size-1;
		}
		!print "no overrun^";
		offs = 0;
		#IFDEF I7_IT_Storage_Glulx_Unicode;
		I7_Raw_Buffer_Address-->(len) = 0;
		#IFNOT;
		I7_Raw_Buffer_Address->(len) = 0;
		#ENDIF;
		#endif;
		len++;
	}
	!print "Writing ", len, " chars to indt ", indt, "^";

	if (indt == 0) {
		indt = I7_Blk_Allocate(len+1, INDEXED_TEXT_TY, I7_IT_Storage_Flags);
		if (indt == 0) return;
		! print "As created: "; I7_Blk_Debug(indt);
	} else {
		if (I7_Blk_Change_Extent(indt, len+1, 1) == false) return;
	}

	#ifdef TARGET_ZCODE;
	for (i=0:i<=len:i++) I7_Blk_Put(indt, i, I7_Raw_Buffer_Address->(i+offs));
	#ifnot;
	#IFDEF I7_IT_Storage_Glulx_Unicode;
	for (i=0:i<=len:i++) I7_Blk_Put(indt, i, I7_Raw_Buffer_Address-->(i+offs));
	#IFNOT;
	for (i=0:i<=len:i++) I7_Blk_Put(indt, i, I7_Raw_Buffer_Address->(i+offs));
	#endif;
	#endif;

	return indt;
];

[ I7_INDEXED_TEXT_TY_Compare txbleft txbright pos ch1 ch2 dsizeleft dsizeright;
	dsizeleft = I7_Blk_Get_Extent(txbleft);
	dsizeright = I7_Blk_Get_Extent(txbright);
	for (pos=0:(pos<dsizeleft) && (pos<dsizeright):pos++) {
		ch1 = I7_Blk_Get(txbleft, pos);
		ch2 = I7_Blk_Get(txbright, pos);
		if (ch1 ~= ch2) return ch2-ch1;
		if (ch1 == 0) return 0;
	}
	if (pos == dsizeleft) return 1;
	return -1;
];

[ I7_INDEXED_TEXT_TY_Understand txb
	pos len wa wl wpos bdm ch own;
	if (txb == 0) return GPR_FAIL;
	bdm = true; own = wn;
	len = I7_Blk_Get_Extent(txb); !print "Parsing: "; I7_INDEXED_TEXT_TY_Say(txb); print "^";
	for (pos=0: pos<=len: pos++) {
		if (pos == len) ch = 0; else ch = I7_Blk_Get(txb, pos);
		if (ch == 32 or 9 or 10 or 0) {
			if (bdm) continue;
			bdm = true; !print "wpos = ", wl, "^";
			if (wpos ~= wl) return GPR_FAIL;
			if (ch == 0) break;
		} else {
			if (bdm) {
				bdm = false;
				if (NextWordStopped() == -1) return GPR_FAIL;
				wa = WordAddress(wn-1);
				wl = WordLength(wn-1); !print "wl = ", wl, "^";
				wpos = 0;
			}
			!print (char) wa->wpos, " vs ", (char) ch, "^";
			if (wa->wpos ~= ch or I7_IT_RevCase(ch)) return GPR_FAIL;
			wpos++;
		}
	}
	if (wn == own) return GPR_FAIL; ! Progress must be made to avoid looping
	!print "YES^";
	return GPR_PREPOSITION;
];

[ I7_INDEXED_TEXT_TY_Distinguish txb1 txb2;
	if (I7_INDEXED_TEXT_TY_Compare(txb1, txb2) == 0) rfalse;
	rtrue;
];

[ I7_INDEXED_TEXT_TY_WFF txb len pos ch;
	len = I7_Blk_Get_Extent(txb);
	print "S";
	for (pos=0: pos<=len: pos++) {
		if (pos == len) ch = 0; else ch = I7_Blk_Get(txb, pos);
		if (ch == 0) {
			print "0;"; break;
		} else {
			print ch, ",";
		}
	}
];

[ I7_INDEXED_TEXT_TY_RFF txb auxf ch i v dg pos tsize;
	!print "I7_INDEXED_TEXT_TY_RFF: ", txb, " ", auxf, " ", ch, "^";
	tsize = I7_Blk_Get_Extent(txb);
	while (ch ~= 32 or 9 or 10 or 13 or 0 or -1) {
		ch = I7_FileIO_GetC(auxf);
		if (ch == ',' or ';') {
			if (pos+1 >= tsize) {
				if (I7_Blk_Change_Extent(txb, 2*pos, 20) == false) break;
				tsize = I7_Blk_Get_Extent(txb);
			}
			I7_Blk_Put(txb, pos++, v);
			v = 0;
			if (ch == ';') break;
		} else {
			dg = ch - '0';
			v = v*10 + dg;
		}
	}
	I7_Blk_Put(txb, pos, 0);
	!print "Read ", pos, " characters up to ch = ", ch, "^";
	!print "Viz: "; I7_INDEXED_TEXT_TY_Say(txb); print "^";
	return txb;
];

! Optional services used only by definitions in the Standard Rules:

Constant CHR_BLOB = 1;
Constant WORD_BLOB = 2;
Constant PWORD_BLOB = 3;
Constant UWORD_BLOB = 4;
Constant PARA_BLOB = 5;
Constant LINE_BLOB = 6;
Constant REGEXP_BLOB = 7;

Constant WS_BRM = 1;
Constant SKIPPED_BRM = 2;
Constant ACCEPTED_BRM = 3;
Constant ACCEPTEDP_BRM = 4;
Constant ACCEPTEDN_BRM = 5;
Constant ACCEPTEDPN_BRM = 6;

[ I7_IT_Blob_Length indt blobtype cindt blobcountwanted rindt
	brm oldbrm ch i dsize csize blobcount gp cl j;
	if ((indt==0) || (I7_Blk_Type(indt) ~= INDEXED_TEXT_TY)) return 0;
	if (blobtype == CHR_BLOB) return I7_IT_Character_Length(indt);
	dsize = I7_Blk_Get_Extent(indt);
	if (cindt) csize = I7_Blk_Get_Extent(cindt);
	else if (rindt) "*** rindt without cindt ***";
!	print "Cindt is "; I7_INDEXED_TEXT_TY_Say(cindt); print "^";
!	print "Rindt is "; I7_INDEXED_TEXT_TY_Say(rindt); print "^";
	brm = WS_BRM;
	for (i=0:i<dsize:i++) {
!		print "i = ", i, "^";
		ch = I7_Blk_Get(indt, i);
		if (ch == 0) break;
		oldbrm = brm;
		if (ch == 10 or 13 or 32 or 9) {
			if (oldbrm ~= WS_BRM) {
				gp = 0;
				for (j=i:j<dsize:j++) {
					ch = I7_Blk_Get(indt, j);
					if (ch == 0) { brm = WS_BRM; break; }
					if (ch == 10 or 13) { gp++; continue; }
					if (ch ~= 32 or 9) break;
				}
				ch = I7_Blk_Get(indt, i);
				if (j == dsize) brm = WS_BRM;
				switch (blobtype) {
					PARA_BLOB: if (gp >= 2) brm = WS_BRM;
					LINE_BLOB: if (gp >= 1) brm = WS_BRM;
					default: brm = WS_BRM;
				}
			}
		} else {
			gp = false;
			if ((blobtype == WORD_BLOB or PWORD_BLOB or UWORD_BLOB) &&
				(ch == '.' or ',' or '!' or '?'
						or '-' or '/' or '"' or ':' or ';'
						or '(' or ')' or '[' or ']' or '{' or '}'))
				gp = true;
			switch (oldbrm) {
				WS_BRM:
					brm = ACCEPTED_BRM;
					if (blobtype == WORD_BLOB) {
						if (gp) brm = SKIPPED_BRM;
					}
					if (blobtype == PWORD_BLOB) {
						if (gp) brm = ACCEPTEDP_BRM;
					}
				SKIPPED_BRM:
					if (blobtype == WORD_BLOB) {
						if (gp == false) brm = ACCEPTED_BRM;
					}
				ACCEPTED_BRM:
					if (blobtype == WORD_BLOB) {
						if (gp) brm = SKIPPED_BRM;
					}
					if (blobtype == PWORD_BLOB) {
						if (gp) brm = ACCEPTEDP_BRM;
					}
				ACCEPTEDP_BRM:
					if (blobtype == PWORD_BLOB) {
						if (gp == false) brm = ACCEPTED_BRM;
						else {
							if ((ch == I7_Blk_Get(indt, i-1)) &&
								(ch == '-' or '.')) blobcount--;
							blobcount++;
						}
					}
				ACCEPTEDN_BRM:
					if (blobtype == WORD_BLOB) {
						if (gp) brm = SKIPPED_BRM;
					}
					if (blobtype == PWORD_BLOB) {
						if (gp) brm = ACCEPTEDP_BRM;
					}
				ACCEPTEDPN_BRM:
					if (blobtype == PWORD_BLOB) {
						if (gp == false) brm = ACCEPTED_BRM;
						else {
							if ((ch == I7_Blk_Get(indt, i-1)) &&
								(ch == '-' or '.')) blobcount--;
							blobcount++;
						}
					}
			}
		}
		if (brm == ACCEPTED_BRM or ACCEPTEDP_BRM) {
			if (oldbrm ~= brm) blobcount++;
			if ((cindt) && (blobcount == blobcountwanted)) {
				if (rindt) {
!	print "Cindt is initially "; I7_INDEXED_TEXT_TY_Say(cindt); print "^";
					I7_Blk_Put(cindt, cl, 0);
					I7_IT_Concatenate(cindt, rindt, CHR_BLOB);
!	print "Cindt is then "; I7_INDEXED_TEXT_TY_Say(cindt); print "^";
					csize = I7_Blk_Get_Extent(cindt);
					cl = I7_IT_Character_Length(cindt);
					if (brm == ACCEPTED_BRM) brm = ACCEPTEDN_BRM;
					if (brm == ACCEPTEDP_BRM) brm = ACCEPTEDPN_BRM;
				} else {
					if (cl+1 >= csize) {
						if (I7_Blk_Change_Extent(cindt, 2*cl, 2) == false) break;
						csize = I7_Blk_Get_Extent(cindt);
					}
					I7_Blk_Put(cindt, cl++, ch);
				}
			} else {
				if (rindt) {
					if (cl+1 >= csize) {
						if (I7_Blk_Change_Extent(cindt, 2*cl, 3) == false) break;
						csize = I7_Blk_Get_Extent(cindt);
					}
					I7_Blk_Put(cindt, cl++, ch);
				}
			}
		} else {
			if ((rindt) && (brm ~= ACCEPTEDN_BRM or ACCEPTEDPN_BRM)) {
				if (cl+1 >= csize) {
					if (I7_Blk_Change_Extent(cindt, 2*cl, 4) == false) break;
					csize = I7_Blk_Get_Extent(cindt);
				}
				I7_Blk_Put(cindt, cl++, ch);
			}
		}
	}
	if (cindt) I7_Blk_Put(cindt, cl++, 0);
	return blobcount;
];

[ I7_IT_Replace_Blob blobtype indt blobcountwanted rindt cindt ilen rlen i;
	if (blobtype == CHR_BLOB) {
		ilen = I7_IT_Character_Length(indt);
		rlen = I7_IT_Character_Length(rindt);
		!	print "Indt is "; I7_INDEXED_TEXT_TY_Say(indt); print "^";
		!	print "Rindt is "; I7_INDEXED_TEXT_TY_Say(rindt); print "^";
		!	print "bcw is ", blobcountwanted, "^";
		blobcountwanted--;
		if ((blobcountwanted >= 0) && (blobcountwanted<ilen)) {
			if (rlen == 1) {
				I7_Blk_Put(indt, blobcountwanted, I7_Blk_Get(rindt, 0));
			} else {
				cindt = I7_Blk_Create(INDEXED_TEXT_TY);
				if (I7_Blk_Change_Extent(cindt, ilen+rlen+1, 5)) {
					for (i=0:i<blobcountwanted:i++)
						I7_Blk_Put(cindt, i, I7_Blk_Get(indt, i));
					for (i=0:i<rlen:i++)
						I7_Blk_Put(cindt, blobcountwanted+i, I7_Blk_Get(rindt, i));
					for (i=blobcountwanted+1:i<ilen:i++)
						I7_Blk_Put(cindt, rlen+i-1, I7_Blk_Get(indt, i));
					I7_Blk_Put(cindt, rlen+ilen, 0);
					I7_Blk_Deep_Copy(indt, cindt);
				}
				I7_Blk_Free(cindt);
			}
		}
	} else {
		cindt = I7_Blk_Create(INDEXED_TEXT_TY);
		I7_IT_Blob_Length(indt, blobtype, cindt, blobcountwanted, rindt);
		!	print "Cindt is ultimately "; I7_INDEXED_TEXT_TY_Say(cindt); print "^";
		I7_Blk_Deep_Copy(indt, cindt);	
		!	print "Indt is deeply "; I7_INDEXED_TEXT_TY_Say(indt); print "^";
		I7_Blk_Free(cindt);
	}
];

! Character classes

Constant NEWLINE_RE_CC = -1;
Constant TAB_RE_CC = -2;
Constant DIGIT_RE_CC = -3;
Constant NONDIGIT_RE_CC = -4;
Constant WHITESPACE_RE_CC = -5;
Constant NONWHITESPACE_RE_CC = -6;
Constant PUNCTUATION_RE_CC = -7;
Constant NONPUNCTUATION_RE_CC = -8;
Constant WORD_RE_CC = -9;
Constant NONWORD_RE_CC = -10;
Constant ANYTHING_RE_CC = -11;
Constant NOTHING_RE_CC = -12;
Constant RANGE_RE_CC = -13;
Constant LCASE_RE_CC = -14;
Constant NONLCASE_RE_CC = -15;
Constant UCASE_RE_CC = -16;
Constant NONUCASE_RE_CC = -17;

! Control structures

Constant SUBEXP_RE_CC = -20;
Constant DISJUNCTION_RE_CC = -21;
Constant CHOICE_RE_CC = -22;
Constant QUANTIFIER_RE_CC = -23;
Constant IF_RE_CC = -24;
Constant CONDITION_RE_CC = -25;
Constant THEN_RE_CC = -26;
Constant ELSE_RE_CC = -27;

! Substring matchers

Constant VARIABLE_RE_CC = -30;
Constant LITERAL_RE_CC = -31;

! Positional matchers

Constant START_RE_CC = -40;
Constant END_RE_CC = -41;
Constant BOUNDARY_RE_CC = -42;
Constant NONBOUNDARY_RE_CC = -43;
Constant ALWAYS_RE_CC = -44;
Constant NEVER_RE_CC = -45;

! Mode switches

Constant SENSITIVITY_RE_CC = -50;

Constant RE_MAX_PACKETS = 32;
Constant RE_PACKET_SIZE = 14; ! Words, that is
#ifdef TARGET_ZCODE;
Constant RE_PACKET_SIZE_IN_BYTES = 2*RE_PACKET_SIZE;
#ifnot;
Constant RE_PACKET_SIZE_IN_BYTES = 4*RE_PACKET_SIZE;
#endif;
Array RE_PACKET_space --> RE_MAX_PACKETS*RE_PACKET_SIZE;
Constant RE_CCLASS = 0;
Constant RE_PAR1 = 1;
Constant RE_PAR2 = 2;
Constant RE_PAR3 = 3;
Constant RE_NEXT = 4;
Constant RE_PREVIOUS = 5;
Constant RE_DOWN = 6;
Constant RE_UP = 7;
Constant RE_DATA1 = 8;
Constant RE_DATA2 = 9;
Constant RE_CONSTRAINT = 10;
Constant RE_CACHE1 = 11;
Constant RE_CACHE2 = 12;
Constant RE_MODES = 13;

[ I7_IT_RE_Node n cc par1 par2 par3
	offset;
	if ((n<0) || (n >= RE_MAX_PACKETS)) rfalse;
	offset = RE_PACKET_space + n*RE_PACKET_SIZE_IN_BYTES;
	offset-->RE_CCLASS = cc;
	offset-->RE_PAR1 = par1;
	offset-->RE_PAR2 = par2;
	offset-->RE_PAR3 = par3;
	offset-->RE_NEXT = I6_NULL;
	offset-->RE_PREVIOUS = I6_NULL;
	offset-->RE_DOWN = I6_NULL;
	offset-->RE_UP = I6_NULL;
	offset-->RE_DATA1 = -1; ! Match start
	offset-->RE_DATA2 = -1; ! Match end
	offset-->RE_CONSTRAINT = -1; ! Rewind edge
	return offset;
];

[ I7_IT_RE_NodeAddress n;
	if ((n<0) || (n >= RE_MAX_PACKETS)) return -1;
	return RE_PACKET_space + n*RE_PACKET_SIZE_IN_BYTES;
];

Array RE_Subexpressions --> 11;
Array I7_IT_RE_Match_Vars --> 10;
Array Allocated_Match_Vars --> 10;

[ I7_IT_RE_Debug_Match_Vars indt
	offset n i;
	print n<RE_Subexpressions-->10, " collecting subexps^";
	for (n=0:(n<RE_Subexpressions-->10) && (n<10): n++) {
		offset = RE_Subexpressions-->n;
		print "Subexp ", offset-->RE_PAR1, " = [", offset-->RE_DATA1, ",", offset-->RE_DATA2, "] = ";
		for (i=offset-->RE_DATA1:i<offset-->RE_DATA2:i++)
			print (char) I7_Blk_Get(indt, i);
		print "^";
	}
];

[ I7_IT_Empty_Match_Vars indt
	n;
	for (n=0:(n<RE_Subexpressions-->10) && (n<10): n++)
		if (Allocated_Match_Vars-->n ~= 0)
			I7_Blk_Put(Allocated_Match_Vars-->n, 0, 0);
];

[ I7_IT_MV_End n end
	offset;
	offset = RE_Subexpressions-->n;
	if (end==0) return offset-->RE_DATA1;
	return offset-->RE_DATA2;
];

[ I7_IT_Create_Match_Vars indt
	offset n i ch cindt cl csize;
	for (n=0:(n<RE_Subexpressions-->10) && (n<10): n++) {
		offset = RE_Subexpressions-->n;
		if (Allocated_Match_Vars-->n == 0)
			Allocated_Match_Vars-->n = I7_INDEXED_TEXT_TY_Create(); ! Permanently
		cindt = Allocated_Match_Vars-->n;
		csize = I7_Blk_Get_Extent(cindt);
		cl = 0;
		!print "Variable ", n, " = ", offset-->RE_DATA1, ", ", offset-->RE_DATA2, " is ", Allocated_Match_Vars-->n, "^";
		for (i=offset-->RE_DATA1:i<offset-->RE_DATA2:i++) {
			ch = I7_Blk_Get(indt, i); !print (char) ch;
			if (cl+1 >= csize) {
				if (I7_Blk_Change_Extent(cindt, 2*cl, 6) == false) break;
				csize = I7_Blk_Get_Extent(cindt);
			}
			I7_Blk_Put(cindt, cl++, ch);
			!print ch;
		}
		!print "^";
		I7_Blk_Put(cindt, cl, 0);
		!I7_INDEXED_TEXT_TY_Say(cindt);
	}
];

[ I7_IT_Get_Match_Var indt vn
	offset;
	if ((vn<0) || (vn>=10) || (vn >= RE_Subexpressions-->10)) jump Nope;
	offset = RE_Subexpressions-->vn;
	if (offset == 0) jump Nope;
	if (offset-->RE_DATA1 < 0) jump Nope;
	if (Allocated_Match_Vars-->vn == 0) {
		print "*** ", vn, " unallocated! ***^";
		jump Nope;
	}
	!print "DC at ", Allocated_Match_Vars-->vn;
	!I7_INDEXED_TEXT_TY_Say(Allocated_Match_Vars-->vn);
	I7_Blk_Deep_Copy(indt, Allocated_Match_Vars-->vn);
	!I7_Blk_Put(indt, 0, 0);
	return indt;
	.Nope;
	I7_Blk_Put(indt, 0, 0);
	return indt;
];

[ I7_IT_RE_Clear_Markers token;
	for (: token ~= I6_NULL: token = token-->RE_NEXT) {
		if (token-->RE_DOWN ~= I6_NULL) I7_IT_RE_Clear_Markers(token-->RE_DOWN);
		token-->RE_DATA1 = -1;
		token-->RE_DATA2 = -1;
		token-->RE_CONSTRAINT = -1;
	}
];

[ I7_IT_Debug_SearchNode offset findt detail
	i par1 par2 par3;
	if (offset == I6_NULL) "[NULL]";
	print "[", (offset-RE_PACKET_space)/(RE_PACKET_SIZE_IN_BYTES), "] ";
	! for (i=0:i<RE_PACKET_SIZE:i++) print offset-->i, " ";
	par1 = offset-->RE_PAR1;
	par2 = offset-->RE_PAR2;
	par3 = offset-->RE_PAR3;
	switch (offset-->RE_CCLASS) {
		DIGIT_RE_CC: print "DIGIT";
		NONDIGIT_RE_CC: print "NONDIGIT";
		UCASE_RE_CC: print "UCASE";
		NONUCASE_RE_CC: print "NONUCASE";
		LCASE_RE_CC: print "LCASE";
		NONLCASE_RE_CC: print "NONLCASE";
		WHITESPACE_RE_CC: print "WHITESPACE";
		NONWHITESPACE_RE_CC: print "NONWHITESPACE";
		PUNCTUATION_RE_CC: print "PUNCTUATION";
		NONPUNCTUATION_RE_CC: print "NONPUNCTUATION";
		WORD_RE_CC: print "WORD";
		NONWORD_RE_CC: print "NONWORD";
		ALWAYS_RE_CC: print "ALWAYS";
		NEVER_RE_CC: print "NEVER";
		START_RE_CC: print "START";
		END_RE_CC: print "END";
		BOUNDARY_RE_CC: print "BOUNDARY";
		NONBOUNDARY_RE_CC: print "NONBOUNDARY";
		ANYTHING_RE_CC: print "ANYTHING";
		NOTHING_RE_CC: print "NOTHING";
		RANGE_RE_CC: print "RANGE"; if (par3 == true) print " (negated)";
			print " ";
			for (i=par1:i<par2:i++) print (char) I7_Blk_Get(findt, i);
		VARIABLE_RE_CC: print "VARIABLE ", par1;
		SUBEXP_RE_CC:
			if (par1 == 0) print "EXP";
			else print "SUBEXP ";
			if (par1 >= 0) print "= V", par1;
			if (par2 == 1) {
				if (par3 == 0) print " (?=...) lookahead";
				else print " (?<=...) lookbehind of width ", par3;
			}
			if (par2 == 2) {
				if (par3 == 0) print " (?!...) negated lookahead";
				else print " (?<!...) negated lookbehind of width ", par3;
			}
			if (par2 == 3) print " uncollecting";
			if (par2 == 0 or 3) {
				if (par3 == 1) print " forcing case sensitivity";
				if (par3 == 2) print " forcing case insensitivity";
			}
			if (par2 == 4) print " (?>...) possessive";
		NEWLINE_RE_CC: print "NEWLINE";
		TAB_RE_CC: print "TAB";
		QUANTIFIER_RE_CC: print "QUANTIFIER min=", par1, " max=", par2;
			if (par3) print " (lazy)"; else print " (greedy)";
		LITERAL_RE_CC: print "LITERAL";
			print " ";
			for (i=par1:i<par2:i++) print (char) I7_Blk_Get(findt, i);
		DISJUNCTION_RE_CC: print "DISJUNCTION of ", par1, " choices";
		CHOICE_RE_CC: print "CHOICE no ", par1;
		SENSITIVITY_RE_CC: print "SENSITIVITY";
			if (par1) print " off"; else print " on";
		IF_RE_CC: print "IF"; if (par1 >= 1) print " = V", par1;
		CONDITION_RE_CC: print "CONDITION"; if (par1 >= 1) print " = V", par1;
		THEN_RE_CC: print "THEN";
		ELSE_RE_CC: print "ELSE";
	}
	if (detail)
		print ": ", offset-->RE_DATA1, ", ", offset-->RE_DATA2, ", ", offset-->RE_CONSTRAINT;
	print "^";
];

[ I7_IT_Debug_SearchR findt depth offset detail
	cup;
	if (offset ~= I6_NULL) {
		cup = offset-->RE_UP;
		if (offset-->RE_PREVIOUS ~= I6_NULL) print "*** broken initial previous ***^";
	}
	while (offset ~= I6_NULL) {
		if (offset-->RE_UP ~= cup) print "*** broken up matching ***^";
		spaces(depth*2);
		I7_IT_Debug_SearchNode(offset, findt, detail);
		if (offset-->RE_DOWN ~= I6_NULL) {
			if ((offset-->RE_DOWN)-->RE_UP ~= offset)
				print "*** broken down/up ***^";
			I7_IT_Debug_SearchR(findt, depth+1, offset-->RE_DOWN, detail);
		}
		if (offset-->RE_NEXT ~= I6_NULL) {
			if ((offset-->RE_NEXT)-->RE_PREVIOUS ~= offset)
				print "*** broken next/previous ***^";
		}
		offset = offset-->RE_NEXT;
	}
];

[ I7_IT_Debug_Search findt detail;
	print "Pattern: ", (I7_INDEXED_TEXT_TY_Say) findt, "^";
	I7_IT_Debug_SearchR(findt, 1, RE_PACKET_space, detail);
];

[ I7_IT_CHR_Compile findt
	root literal fto;

	fto = I7_IT_Character_Length(findt);

	root = I7_IT_RE_Node(0, SUBEXP_RE_CC, 0, 0, 0);
	literal = I7_IT_RE_Node(1, LITERAL_RE_CC, 0, fto, 0);
	
	root-->RE_DOWN = literal;
	literal-->RE_UP = root;

	return 2;
];

Array Subexp_Posns --> 20;
[ I7_IT_REGEXP_Compile findt exactly
	no_packets ffrom fto cc par1 par2 par3
	quantifiable token attach_to no_subs blevel bits;

	!print ">> "; I7_INDEXED_TEXT_TY_Say(findt); print "^";


	fto = I7_IT_Character_Length(findt);
	if (fto == 0) {
		I7_IT_RE_Node(no_packets++, NEVER_RE_CC, 0, 0, 0); ! Empty regexp never matches
		return 1;
	}

	attach_to = I7_IT_RE_Node(no_packets++, SUBEXP_RE_CC, 0, 0, 0);
	RE_Subexpressions-->0 = attach_to; RE_Subexpressions-->10 = 1; no_subs = 1;

	quantifiable = false; blevel = 0;
	
	for (ffrom = 0: ffrom < fto: ) {
		!print "FF is ", ffrom, "^";
		cc = I7_Blk_Get(findt, ffrom++); par1 = 0; par2 = 0; par3 = 0;
		if (cc == '\') {
			if (ffrom == fto) return "Search pattern not terminated";
			cc = I7_Blk_Get(findt, ffrom++);
			switch (cc) {
				'b': cc = BOUNDARY_RE_CC;
				'B': cc = NONBOUNDARY_RE_CC;
				'd': cc = DIGIT_RE_CC;
				'D': cc = NONDIGIT_RE_CC;
				'l': cc = LCASE_RE_CC;
				'L': cc = NONLCASE_RE_CC;
				'n': cc = NEWLINE_RE_CC;
				'p': cc = PUNCTUATION_RE_CC;
				'P': cc = NONPUNCTUATION_RE_CC;
				's': cc = WHITESPACE_RE_CC;
				'S': cc = NONWHITESPACE_RE_CC;
				't': cc = TAB_RE_CC;
				'u': cc = UCASE_RE_CC;
				'U': cc = NONUCASE_RE_CC;
				'w': cc = WORD_RE_CC;
				'W': cc = NONWORD_RE_CC;
				default:
					if ((cc >= '1') && (cc <= '9')) {
						par1 = cc-'0';
						cc = VARIABLE_RE_CC;
					} else {
						if (((cc >= 'a') && (cc <= 'z')) ||
							((cc >= 'A') && (cc <= 'Z'))) return "unknown escape";
						cc = LITERAL_RE_CC;
						par1 = ffrom-1; par2 = ffrom;
					}
			}
			quantifiable = true;
		} else {
			switch (cc) {
				'(': par2 = 0;
					!if (I7_Blk_Get(findt, ffrom) == ')') return "empty subexpression";
					if (I7_Blk_Get(findt, ffrom) == '?') {
						ffrom++;
						bits = true;
						if (I7_Blk_Get(findt, ffrom) == '-') { ffrom++; bits = false; }
						else if (I7_Blk_Get(findt, ffrom) == '<') { ffrom++; bits = false; }
						switch (cc = I7_Blk_Get(findt, ffrom++)) {
							'#': while (I7_Blk_Get(findt, ffrom++) ~= 0 or ')') ;
								if (I7_Blk_Get(findt, ffrom-1) == 0)
									return "comment never ends";
								continue;
							'(': cc = I7_Blk_Get(findt, ffrom);
								if ((cc == '1' or '2' or '3' or '4' or
									'5' or '6' or '7' or '8' or '9') &&
									(I7_Blk_Get(findt, ffrom+1) ==')')) {
									ffrom = ffrom + 2;
									par1 = cc - '0';
								} else ffrom--;
								cc = IF_RE_CC; ! (?(...)...) conditional
								quantifiable = false;
								if (blevel == 20) return "subexpressions too deep";
								Subexp_Posns-->(blevel++) = I7_IT_RE_NodeAddress(no_packets);
								jump CClassKnown;
							'=': par2 = 1; ! (?=...) lookahead/behind
								par3 = 0; if (bits == false) par3 = -1;
							'!': par2 = 2; ! (?!...) negated lookahead/behind
								par3 = 0; if (bits == false) par3 = -1;
							':': par2 = 3; ! (?:...) uncollecting subexpression
							'>': par2 = 4; ! (?>...) possessive
							default:
								if (I7_Blk_Get(findt, ffrom) == ')') {
									if (cc == 'i') {
										cc = SENSITIVITY_RE_CC; par1 = bits; ffrom++;
										jump CClassKnown;
									}
								}
								if (I7_Blk_Get(findt, ffrom) == ':') {
									if (cc == 'i') {
										par1 = bits; par2 = 3; par3 = bits+1; ffrom++;
										jump AllowForm;
									}
								}
								return "unknown (?...) form";
						}
					}
					.AllowForm;
					if (par2 == 0) par1 = no_subs++; else par1 = -1;
					cc = SUBEXP_RE_CC; 
					quantifiable = false;
					if (blevel == 20) return "subexpressions too deep";
					Subexp_Posns-->(blevel++) = I7_IT_RE_NodeAddress(no_packets);
				')': if (blevel == 0) return "subexpression bracket mismatch";
					blevel--;
					attach_to = Subexp_Posns-->blevel;
					if (attach_to-->RE_DOWN == I6_NULL) {
						if (no_packets >= RE_MAX_PACKETS) return "regexp too complex";
						attach_to-->RE_DOWN =
							I7_IT_RE_Node(no_packets++, ALWAYS_RE_CC, 0, 0, 0);
						(attach_to-->RE_DOWN)-->RE_UP = attach_to;
					}
					quantifiable = true;
					continue;
				'.': cc = ANYTHING_RE_CC; quantifiable = true;
				'|': cc = CHOICE_RE_CC; quantifiable = false;
				'^': cc = START_RE_CC; quantifiable = false;
				'$': cc = END_RE_CC; quantifiable = false;
				'{': if (quantifiable == false) return "quantifier misplaced";
					par1 = 0; par2 = -1; bits = 1;
					while ((cc=I7_Blk_Get(findt, ffrom++)) ~= 0 or '}') {
						if (cc == ',') {
							bits++;
							if (bits >= 3) return "too many colons in ?{...}";
							continue;
						}
						if ((cc >= '0') || (cc <= '9')) {
							if (bits == 1) {
								if (par1 < 0) par1 = 0;
								par1 = par1*10 + (cc-'0');
							} else {
								if (par2 < 0) par2 = 0;
								par2 = par2*10 + (cc-'0');
							}
						} else return "non-digit in ?{...}";
					}
					if (cc ~= '}') return "{x,y} quantifier never ends";
					cc = QUANTIFIER_RE_CC;
					if (par2 == -1) {
						if (bits == 2) par2 = 30000;
						else par2 = par1;
					}
					if (par1 > par2) return "{x,y} with x greater than y";
					if (I7_Blk_Get(findt, ffrom) == '?') { ffrom++; par3 = true; }
					quantifiable = false;
				'<', '[': par3 = false; if (cc == '<') bits = '>'; else bits = ']';
					if (I7_Blk_Get(findt, ffrom) == '^') { ffrom++; par3 = true; }
					par1 = ffrom;
					if (I7_Blk_Get(findt, ffrom) == bits) { ffrom++; }
					while (cc ~= bits or 0) {
						cc = I7_Blk_Get(findt, ffrom++);
						if (cc == '\') {
							cc = I7_Blk_Get(findt, ffrom++);
							if (cc ~= 0) cc = I7_Blk_Get(findt, ffrom++);
						}
					}
					if (cc == 0) return "Character range never ends";
					par2 = ffrom-1;
					if ((par2 > par1 + 1) &&
						(I7_Blk_Get(findt, par1) == ':') &&
						(I7_Blk_Get(findt, par2-1) == ':') &&
						(I7_Blk_Get(findt, par2-2) ~= '\'))
						return "POSIX named character classes unsupported";
					bits = I7_IT_RE_Verify_Range(findt, par1, par2);
					if (bits) return bits;
					if (par1 < par2) cc = RANGE_RE_CC;
					else cc = NOTHING_RE_CC;
					quantifiable = true;
				'*': if (quantifiable == false) return "quantifier misplaced";
					cc = QUANTIFIER_RE_CC;
					par1 = 0; par2 = 30000;
					if (I7_Blk_Get(findt, ffrom) == '?') { ffrom++; par3 = true; }
					quantifiable = false;
				'+': if (quantifiable == false) return "quantifier misplaced";
					cc = QUANTIFIER_RE_CC;
					par1 = 1; par2 = 30000;
					if (I7_Blk_Get(findt, ffrom) == '?') { ffrom++; par3 = true; }
					quantifiable = false;
				'?': if (quantifiable == false) return "quantifier misplaced";
					cc = QUANTIFIER_RE_CC;
					par1 = 0; par2 = 1;
					if (I7_Blk_Get(findt, ffrom) == '?') { ffrom++; par3 = true; }
					quantifiable = false;
			}
		}
		
		.CClassKnown;
		
		if (cc >= 0) {
			quantifiable = true;
			if ((attach_to-->RE_CCLASS == LITERAL_RE_CC) &&
				(I7_Blk_Get(findt, ffrom) ~= '*' or '+' or '?' or '{')) {
				(attach_to-->RE_PAR2)++;
				if (I7_IT_RE_Trace == 2) {
					print "Extending literal by ", cc, "=", (char) cc, "^";
				}
				continue;
			}
			cc = LITERAL_RE_CC; par1 = ffrom-1; par2 = ffrom;
		}
		
		if (no_packets >= RE_MAX_PACKETS) return "regexp too complex";

		if (I7_IT_RE_Trace == 2) {
			print "Attaching packet ", no_packets+1, " to ";
			I7_IT_Debug_SearchNode(attach_to, findt);
			I7_IT_Debug_Search(findt);
		}

		token = I7_IT_RE_Node(no_packets++, cc, par1, par2, par3);

		if ((token-->RE_CCLASS == SUBEXP_RE_CC) && (token-->RE_PAR2 == 0)) {
			RE_Subexpressions-->(token-->RE_PAR1) = token;
			(RE_Subexpressions-->10)++;
		}
		
		if ((attach_to-->RE_CCLASS == SUBEXP_RE_CC or CHOICE_RE_CC or IF_RE_CC) &&
			(attach_to-->RE_DOWN == I6_NULL)) {
			attach_to-->RE_DOWN = token; token-->RE_UP = attach_to;
		} else {
			if ((token-->RE_CCLASS == CHOICE_RE_CC) &&
				((attach_to-->RE_UP)-->RE_CCLASS == CHOICE_RE_CC)) {
				no_packets--; token = attach_to-->RE_UP;
			} else {
				if (token-->RE_CCLASS == CHOICE_RE_CC) {
					while (attach_to-->RE_PREVIOUS ~= I6_NULL)
						attach_to = attach_to-->RE_PREVIOUS;
				}
				if (token-->RE_CCLASS == QUANTIFIER_RE_CC or CHOICE_RE_CC) {
					token-->RE_PREVIOUS = attach_to-->RE_PREVIOUS;
					token-->RE_UP = attach_to-->RE_UP;
					if ((attach_to-->RE_UP ~= I6_NULL) && (attach_to-->RE_PREVIOUS == I6_NULL))
						(attach_to-->RE_UP)-->RE_DOWN = token;
					token-->RE_DOWN = attach_to;
					bits = attach_to;
					while (bits ~= I6_NULL) {
						bits-->RE_UP = token;
						bits = bits-->RE_NEXT;
					}
					attach_to-->RE_PREVIOUS = I6_NULL;
					if (token-->RE_PREVIOUS ~= I6_NULL)
						(token-->RE_PREVIOUS)-->RE_NEXT = token;
				} else {
					attach_to-->RE_NEXT = token; token-->RE_PREVIOUS = attach_to;
					token-->RE_UP = attach_to-->RE_UP;
				}
			}
		}
		
		if (token-->RE_CCLASS == CHOICE_RE_CC) {
			if (no_packets >= RE_MAX_PACKETS) return "regexp too complex";
			token-->RE_NEXT = I7_IT_RE_Node(no_packets++, CHOICE_RE_CC, 0, 0, 0);
			(token-->RE_NEXT)-->RE_PREVIOUS = token;
			(token-->RE_NEXT)-->RE_UP = token-->RE_UP;
			token = token-->RE_NEXT;
		}

		attach_to = token;

		if (I7_IT_RE_Trace == 2) {
			print "Result:^";
			I7_IT_Debug_Search(findt);
		}

	}
	
	if (blevel ~= 0) return "subexpression bracket mismatch";

	if (exactly) {
		if (no_packets+3 > RE_MAX_PACKETS) return "regexp too complex";
		exactly = RE_PACKET_space-->RE_DOWN;
		token = I7_IT_RE_Node(no_packets++, START_RE_CC, 0, 0, 0);
		RE_PACKET_space-->RE_DOWN = token; token-->RE_UP = RE_PACKET_space;
		attach_to = I7_IT_RE_Node(no_packets++, SUBEXP_RE_CC, -1, 3, 0);
		token-->RE_NEXT = attach_to; attach_to-->RE_PREVIOUS = token;
		attach_to-->RE_UP = RE_PACKET_space;
		attach_to-->RE_NEXT = I7_IT_RE_Node(no_packets++, END_RE_CC, 0, 0, 0);
		(attach_to-->RE_NEXT)-->RE_PREVIOUS = attach_to;
		(attach_to-->RE_NEXT)-->RE_UP = RE_PACKET_space;
		attach_to-->RE_DOWN = exactly;
		while (exactly ~= I6_NULL) {
			exactly-->RE_UP = attach_to; exactly = exactly-->RE_NEXT;
		}
	}
	
	no_packets = I7_IT_RE_Expand_Choices(RE_PACKET_space, no_packets);

	if (I7_IT_RE_Trace) {
		print "Compiled pattern:^";
		I7_IT_Debug_Search(findt);
	}
	
	bits = I7_IT_RE_Check_Tree(RE_PACKET_space, no_subs); if (bits) return bits;
	
	return no_packets;
];

[ I7_IT_RE_Expand_Choices token no_packets
	rv prev nex holder new ct n cond_node then_node else_node;
	while (token ~= I6_NULL) {
		if (token-->RE_CCLASS == IF_RE_CC) {
			if ((token-->RE_DOWN)-->RE_CCLASS == CHOICE_RE_CC) {
				for (nex=token-->RE_DOWN, n=0: nex~=I6_NULL: nex=nex-->RE_NEXT) n++;
				if (n~=2) return "conditional has too many clauses";
				if (no_packets >= RE_MAX_PACKETS) return "regexp too complex";
				cond_node = I7_IT_RE_Node(no_packets++, CONDITION_RE_CC, 0, 0, 0);
				if (token-->RE_PAR1 >= 1) {
					cond_node-->RE_PAR1 = token-->RE_PAR1;
				}
				then_node = token-->RE_DOWN;
				then_node-->RE_CCLASS = THEN_RE_CC;
				else_node = then_node-->RE_NEXT;
				else_node-->RE_CCLASS = ELSE_RE_CC;
				if (cond_node-->RE_PAR1 < 1) {
					cond_node-->RE_DOWN = then_node-->RE_DOWN;
					then_node-->RE_DOWN = (then_node-->RE_DOWN)-->RE_NEXT;
					if (then_node-->RE_DOWN ~= I6_NULL)
						(then_node-->RE_DOWN)-->RE_PREVIOUS = I6_NULL;
					(cond_node-->RE_DOWN)-->RE_NEXT = I6_NULL;
					(cond_node-->RE_DOWN)-->RE_UP = cond_node;
				}
				token-->RE_DOWN = cond_node; cond_node-->RE_UP = token;
				cond_node-->RE_NEXT = then_node; then_node-->RE_PREVIOUS = cond_node;
			} else {
				if (no_packets >= RE_MAX_PACKETS) return "regexp too complex";
				cond_node = I7_IT_RE_Node(no_packets++, CONDITION_RE_CC, 0, 0, 0);
				if (no_packets >= RE_MAX_PACKETS) return "regexp too complex";
				then_node = I7_IT_RE_Node(no_packets++, THEN_RE_CC, 0, 0, 0);
				if (token-->RE_PAR1 >= 1) {
					cond_node-->RE_PAR1 = token-->RE_PAR1;
					then_node-->RE_DOWN = token-->RE_DOWN;
				} else {
					cond_node-->RE_DOWN = token-->RE_DOWN;
					then_node-->RE_DOWN = (token-->RE_DOWN)-->RE_NEXT;
					(cond_node-->RE_DOWN)-->RE_NEXT = I6_NULL;
					(cond_node-->RE_DOWN)-->RE_UP = cond_node;
				}
				token-->RE_DOWN = cond_node;
				cond_node-->RE_UP = token; cond_node-->RE_NEXT = then_node;
				then_node-->RE_PREVIOUS = cond_node; then_node-->RE_UP = token;
				then_node-->RE_NEXT = I6_NULL;
				if (then_node-->RE_DOWN ~= I6_NULL)
					(then_node-->RE_DOWN)-->RE_PREVIOUS = I6_NULL;
				for (nex = then_node-->RE_DOWN: nex ~= I6_NULL: nex = nex-->RE_NEXT) {
					nex-->RE_UP = then_node;
				}
			}
			
			if (cond_node-->RE_DOWN ~= I6_NULL) {
				nex = cond_node-->RE_DOWN;
				if ((nex-->RE_CCLASS ~= SUBEXP_RE_CC) ||
					(nex-->RE_NEXT ~= I6_NULL) ||
					(nex-->RE_PAR2 ~= 1 or 2)) {
					!I7_IT_Debug_SearchR(0, 0, nex, true);
					return "condition not lookahead/behind";
				}
			}
		}
		if ((token-->RE_CCLASS == CHOICE_RE_CC) && (token-->RE_PAR1 < 1)) {
			prev = token-->RE_PREVIOUS;
			nex = token-->RE_NEXT;
			while ((nex ~= I6_NULL) && (nex-->RE_CCLASS == CHOICE_RE_CC))
				nex = nex-->RE_NEXT;
			holder = token-->RE_UP; if (holder == I6_NULL) return "bang";
			if (no_packets >= RE_MAX_PACKETS) return "regexp too complex";
			new = I7_IT_RE_Node(no_packets++, DISJUNCTION_RE_CC, 0, 0, 0);
			holder-->RE_DOWN = new; new-->RE_UP = holder;
			if (prev ~= I6_NULL) {
				prev-->RE_NEXT = new; new-->RE_PREVIOUS = prev;
			}
			if (nex ~= I6_NULL) {
				nex-->RE_PREVIOUS = new; new-->RE_NEXT = nex;
			}
			new-->RE_DOWN = token;
			token-->RE_PREVIOUS = I6_NULL;
			ct = 1;
			while (token ~= I6_NULL) {
				token-->RE_PAR1 = ct++;
				token-->RE_UP = new;
				if ((token-->RE_NEXT ~= I6_NULL) &&
					((token-->RE_NEXT)-->RE_CCLASS ~= CHOICE_RE_CC))
					token-->RE_NEXT = I6_NULL;
				token = token-->RE_NEXT;
			}
			new-->RE_PAR1 = ct-1;
			if (token ~= I6_NULL) token-->RE_NEXT = I6_NULL;
			token = new; continue;
		}
		if (token-->RE_DOWN ~= I6_NULL) {
			no_packets = I7_IT_RE_Expand_Choices(token-->RE_DOWN, no_packets);
			if ((no_packets<0) || (no_packets >= RE_MAX_PACKETS)) break;
		}
		token = token-->RE_NEXT;
	}
	return no_packets;
];

[ I7_IT_RE_Check_Tree token no_subs
	rv;
	while (token ~= I6_NULL) {
		if (token-->RE_CCLASS == VARIABLE_RE_CC) {
			if (token-->RE_PAR1 >= no_subs) return "reference to nonexistent group";
		}
		if ((token-->RE_CCLASS == SUBEXP_RE_CC) &&
			(token-->RE_PAR2 == 1 or 2) &&
			(token-->RE_PAR3 == -1)) {
			token-->RE_PAR3 = I7_IT_RE_Width(token-->RE_DOWN);
			if (token-->RE_PAR3 == -1) return "variable length lookbehind not implemented";
		}
		if (token-->RE_DOWN ~= I6_NULL) {
			rv = I7_IT_RE_Check_Tree(token-->RE_DOWN, no_subs);
			if (rv) return rv;
		}
		token = token-->RE_NEXT;
	}
	rfalse;
];

[ I7_IT_RE_Width token downwards
	w rv aw choice;
	while (token ~= I6_NULL) {
		switch (token-->RE_CCLASS) {
			DIGIT_RE_CC, NONDIGIT_RE_CC, WHITESPACE_RE_CC, NONWHITESPACE_RE_CC,
			PUNCTUATION_RE_CC, NONPUNCTUATION_RE_CC, WORD_RE_CC, NONWORD_RE_CC,
			ANYTHING_RE_CC, NOTHING_RE_CC, RANGE_RE_CC, NEWLINE_RE_CC, TAB_RE_CC,
			UCASE_RE_CC, NONUCASE_RE_CC, LCASE_RE_CC, NONLCASE_RE_CC:
				w++;
			START_RE_CC, END_RE_CC, BOUNDARY_RE_CC, NONBOUNDARY_RE_CC, ALWAYS_RE_CC:
				;
			LITERAL_RE_CC:
				w = w + token-->RE_PAR2 - token-->RE_PAR1;
			VARIABLE_RE_CC:
				return -1;
			IF_RE_CC:
				rv = I7_IT_RE_Width((token-->RE_DOWN)-->RE_NEXT);
				if (rv == -1) return -1;
				if (rv ~= I7_IT_RE_Width(((token-->RE_DOWN)-->RE_NEXT)-->RE_NEXT))
					return -1;
				w = w + rv;
			SUBEXP_RE_CC:
				if (token-->RE_PAR2 == 1 or 2) rv = 0;
				else {
					rv = I7_IT_RE_Width(token-->RE_DOWN);
					if (rv == -1) return -1;
				}
				w = w + rv;
			QUANTIFIER_RE_CC:
				if (token-->RE_PAR1 ~= token-->RE_PAR2) return -1;
				rv = I7_IT_RE_Width(token-->RE_DOWN);
				if (rv == -1) return -1;
				w = w + rv*(token-->RE_PAR1);				
			DISJUNCTION_RE_CC:
				aw = -1;
				for (choice = token-->RE_DOWN: choice ~= I6_NULL: choice = choice-->RE_NEXT) {
					rv = I7_IT_RE_Width(choice-->RE_DOWN);
					!print "Option found ", rv, "^";
					if (rv == -1) return -1;
					if ((aw >= 0) && (aw ~= rv)) return -1;
					aw = rv;
				}
				w = w + aw;
			SENSITIVITY_RE_CC:
				;
		}
		if (downwards) return w;
		if (token ~= I6_NULL) token = token-->RE_NEXT;
	}
	return w;
];

Global I7_IT_RE_RewindCount;
[ I7_IT_RE_DebR;
	print I7_IT_RE_RewindCount;
];

Constant CIS_MFLAG = 1;
Constant ACCUM_MFLAG = 2;

[ I7_IT_RE_Parse_RE findt indt ipos insens
	ilen rv root i initial_mode;

	ilen = I7_IT_Character_Length(indt);
	if ((ipos<0) || (ipos>ilen)) return -1;
	
	root = RE_PACKET_space;
	
	initial_mode = 0; if (insens) initial_mode = CIS_MFLAG;
	
	I7_IT_RE_Clear_Markers(RE_PACKET_space);
	
	for (:ipos<=ilen:ipos++) {
		if ((RE_PACKET_space-->RE_DOWN ~= I6_NULL) &&
			((RE_PACKET_space-->RE_DOWN)-->RE_CCLASS == START_RE_CC) &&
			(ipos>0)) { rv = -1; break; }
		if (ipos > 0) I7_IT_RE_Parse_RE_Start_Fresh(RE_PACKET_space, initial_mode);
		I7_IT_RE_RewindCount = 0;
		rv = I7_IT_RE_Parse_RE_R(findt, indt, ipos, ilen, RE_PACKET_space, initial_mode);
		if (rv >= 0) break;
	}

	if (rv == -1) {
		root-->RE_DATA1 = -1;
		root-->RE_DATA2 = -1;
	} else {
		root-->RE_DATA1 = ipos;
		root-->RE_DATA2 = ipos+rv;
	}
	return rv;
];

! Returns: no chars matched for match (may be 0), -1 for no match

[ I7_IT_RE_Parse_RE_R findt indt ifrom ito token mode_flags
	outcome ipos npos rv i ch edge rewind_this;

	if (ifrom > ito) return -1;

	ipos = ifrom;

	.Rewind;
	while (token ~= I6_NULL) {
		outcome = false;
				if (I7_IT_RE_Trace) {
					print "Matching at ", ipos, ": ";
					I7_IT_Debug_SearchNode(token, findt, true);
				}

		if (ipos<ito) ch = I7_Blk_Get(indt, ipos); else ch = 0;

		token-->RE_MODES = mode_flags; ! Save in case of backtrack

		switch (token-->RE_CCLASS) {
			
			! Should never happen
			
			CHOICE_RE_CC: return "internal error";
			
			! Mode switches
			
			SENSITIVITY_RE_CC:
				if (token-->RE_PAR1) mode_flags = mode_flags | CIS_MFLAG;
				else mode_flags = mode_flags & (~CIS_MFLAG);
				outcome = true;
		
			! Zero-length positional markers
			
			ALWAYS_RE_CC:
				outcome = true;
			NEVER_RE_CC:
			START_RE_CC:
				if (ipos == 0) outcome = true;
			END_RE_CC:
				if (I7_Blk_Get(indt, ipos) == 0) outcome = true;
			BOUNDARY_RE_CC:
				rv = 0;
				if (I7_Blk_Get(indt, ipos) == 0 or 10 or 13 or 32 or 9
					or '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}') rv++;
				if (ipos == 0) ch = 0;
				else ch = I7_Blk_Get(indt, ipos-1);
				if (ch == 0 or 10 or 13 or 32 or 9
					or '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}') rv++;
				if (rv == 1) outcome = true;
			NONBOUNDARY_RE_CC:
				rv = 0;
				if (I7_Blk_Get(indt, ipos) == 0 or 10 or 13 or 32 or 9
					or '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}') rv++;
				if (ipos == 0) ch = 0;
				else ch = I7_Blk_Get(indt, ipos-1);
				if (ch == 0 or 10 or 13 or 32 or 9
					or '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}') rv++;
				if (rv ~= 1) outcome = true;

			! Control constructs
		
			IF_RE_CC:
				i = token-->RE_PAR1; ch = false;
				if (I7_IT_RE_Trace) {
					print "Trying conditional from ", ipos, ": ";
					I7_IT_Debug_SearchNode(token, findt, true);
				}
				if (i >= 1) {
					 if ((i<RE_Subexpressions-->10) &&
					 	((RE_Subexpressions-->i)-->RE_DATA1 >= 0)) ch = true;
				} else {					 	
					rv = I7_IT_RE_Parse_RE_R(findt, indt, ipos, ito,
						(token-->RE_DOWN)-->RE_DOWN, mode_flags);
					if (rv >= 0) ch = true;
				}
				if (I7_IT_RE_Trace) {
					print "Condition found to be ", ch, "^";
				}
				if (ch) {
					rv = I7_IT_RE_Parse_RE_R(findt, indt, ipos, ito,
						((token-->RE_DOWN)-->RE_NEXT)-->RE_DOWN, mode_flags);
					!print "Then clause returned ", rv, "^";
				} else {
					if ((((token-->RE_DOWN)-->RE_NEXT)-->RE_NEXT) == I6_NULL)
						rv = 0; ! The empty else clause matches
					else rv = I7_IT_RE_Parse_RE_R(findt, indt, ipos, ito,
						(((token-->RE_DOWN)-->RE_NEXT)-->RE_NEXT)-->RE_DOWN, mode_flags);
					!print "Else clause returned ", rv, "^";
				}
				if (rv >= 0) {
					outcome = true;
					ipos = ipos + rv;
				}
			DISJUNCTION_RE_CC:
				if (I7_IT_RE_Trace) {
					print "Trying disjunction from ", ipos, ": ";
					I7_IT_Debug_SearchNode(token, findt, true);
				}
				for (ch = token-->RE_DOWN: ch ~= I6_NULL: ch = ch-->RE_NEXT) {
					if (ch-->RE_PAR1 <= token-->RE_CONSTRAINT) continue;
					if (I7_IT_RE_Trace) {
						print "Trying choice at ", ipos, ": ";
						I7_IT_Debug_SearchNode(ch, findt, true);
					}
					rv = I7_IT_RE_Parse_RE_R(findt, indt, ipos, ito,
						ch-->RE_DOWN, mode_flags);
					if (rv >= 0) {
						token-->RE_DATA1 = ipos; ! Where match was made
						token-->RE_DATA2 = ch-->RE_PAR1; ! Option taken
						ipos = ipos + rv;
						outcome = true;
						if (I7_IT_RE_Trace) {
							print "Choice worked with width ", rv, ": ";
							I7_IT_Debug_SearchNode(ch, findt, true);
						}
						break;
					} else {
						if (mode_flags & ACCUM_MFLAG == false)
							I7_IT_RE_Fail_Subexpressions(ch-->RE_DOWN);
					}						
				}
				if (outcome == false) {
					if (I7_IT_RE_Trace) {
						print "Failed disjunction from ", ipos, ": ";
						I7_IT_Debug_SearchNode(token, findt, true);
					}
					token-->RE_DATA1 = ipos; ! Where match was tried
					token-->RE_DATA2 = -1; ! No option was taken
				}
			SUBEXP_RE_CC:
				if (token-->RE_PAR2 == 1 or 2) {
					npos = ipos - token-->RE_PAR3;
					if (npos<0) rv = -1; ! Lookbehind fails: nothing behind
					else rv = I7_IT_RE_Parse_RE_R(findt, indt, npos, ito, token-->RE_DOWN,
						mode_flags);
				} else {
					switch (token-->RE_PAR3) {
						0: rv = I7_IT_RE_Parse_RE_R(findt, indt, ipos, ito, token-->RE_DOWN,
							mode_flags);
						1: rv = I7_IT_RE_Parse_RE_R(findt, indt, ipos, ito, token-->RE_DOWN,
							mode_flags & (~CIS_MFLAG));
						2: rv = I7_IT_RE_Parse_RE_R(findt, indt, ipos, ito, token-->RE_DOWN,
							mode_flags | CIS_MFLAG);
					}
				}
				npos = ipos;
				if (rv >= 0) npos = ipos + rv;
				switch (token-->RE_PAR2) {
					1: if (rv >= 0) rv = 0;
					2: if (rv >= 0) rv = -1; else rv = 0;
				}
				if (rv >= 0) {
					token-->RE_DATA1 = ipos;
					ipos = ipos + rv;
					token-->RE_DATA2 = npos;
					outcome = true;
				} else {
					if (mode_flags & ACCUM_MFLAG == false) {
						token-->RE_DATA1 = -1;
						token-->RE_DATA2 = -1;
					}
				}
				if (token-->RE_PAR2 == 2) I7_IT_RE_Fail_Subexpressions(token, true);
			QUANTIFIER_RE_CC:
				token-->RE_DATA1 = ipos;
				if ((token-->RE_DOWN)-->RE_CCLASS == SUBEXP_RE_CC) {
					(token-->RE_DOWN)-->RE_CACHE1 = -1;
					(token-->RE_DOWN)-->RE_CACHE2 = -1;	
				}
				if (I7_IT_RE_Trace) {
					print "Trying quantifier from ", ipos, ": ";
					I7_IT_Debug_SearchNode(token, findt, true);
				}
				if (token-->RE_PAR3 == false) { ! Greedy quantifier
					!edge = ito; if (token-->RE_CONSTRAINT >= 0) edge = token-->RE_CONSTRAINT;
					edge = token-->RE_PAR2; if (token-->RE_CONSTRAINT >= 0) edge = token-->RE_CONSTRAINT;
					rv = -1;
					for (i=0, npos=ipos: i<edge: i++) {
						if (I7_IT_RE_Trace) {
							print "Trying quant rep ", i+1, " at ", npos, ": ";
							I7_IT_Debug_SearchNode(token, findt, true);
						}
						rv = I7_IT_RE_Parse_RE_R(findt, indt, npos, ito, token-->RE_DOWN,
							mode_flags | ACCUM_MFLAG);
						if (rv < 0) break;
						if ((token-->RE_DOWN)-->RE_CCLASS == SUBEXP_RE_CC) {
							(token-->RE_DOWN)-->RE_CACHE1 = (token-->RE_DOWN)-->RE_DATA1;
							(token-->RE_DOWN)-->RE_CACHE2 = (token-->RE_DOWN)-->RE_DATA2;	
						}
						if ((rv == 0) && (token-->RE_PAR2 == 30000) && (i>=1)) { i++; break; }
						npos = npos + rv;
					}
					if ((i >= token-->RE_PAR1) && (i <= token-->RE_PAR2))
						outcome = true;
				} else { ! Lazy quantifier
					edge = token-->RE_PAR1; if (token-->RE_CONSTRAINT > edge) edge = token-->RE_CONSTRAINT;
					for (i=0, npos=ipos: (npos<ito) && (i < token-->RE_PAR2): i++) {
						if (i >= edge) break;
						if (I7_IT_RE_Trace) {
							print "Trying quant rep ", i+1, " at ", npos, ": ";
							I7_IT_Debug_SearchNode(token, findt, true);
						}
						rv = I7_IT_RE_Parse_RE_R(findt, indt, npos, ito, token-->RE_DOWN,
							mode_flags | ACCUM_MFLAG);
						if (rv < 0) break;
						if ((token-->RE_DOWN)-->RE_CCLASS == SUBEXP_RE_CC) {
							(token-->RE_DOWN)-->RE_CACHE1 = (token-->RE_DOWN)-->RE_DATA1;
							(token-->RE_DOWN)-->RE_CACHE2 = (token-->RE_DOWN)-->RE_DATA2;	
						}
						if ((rv == 0) && (token-->RE_PAR2 == 30000) && (i>=1)) { i++; break; }
						npos = npos + rv;
					}
					if ((i >= edge) && (i <= token-->RE_PAR2))
						outcome = true;
				}
				if (outcome) {
					if (token-->RE_PAR3 == false) { ! Greedy quantifier
						if (i > token-->RE_PAR1) { ! I.e., if we have been greedy
							token-->RE_DATA2 = i-1; ! And its edge limitation
						} else {
							token-->RE_DATA2 = -1;
						}
					} else { ! Lazy quantifier
						if (i < token-->RE_PAR2) { ! I.e., if we have been lazy
							token-->RE_DATA2 = i+1; ! And its edge limitation
						} else {
							token-->RE_DATA2 = -1;
						}
					}
					ipos = npos;
					if ((i == 0) && (mode_flags & ACCUM_MFLAG == false))
						I7_IT_RE_Fail_Subexpressions(token-->RE_DOWN);
					if ((token-->RE_DOWN)-->RE_CCLASS == SUBEXP_RE_CC) {
						(token-->RE_DOWN)-->RE_DATA1 = (token-->RE_DOWN)-->RE_CACHE1;
						(token-->RE_DOWN)-->RE_DATA2 = (token-->RE_DOWN)-->RE_CACHE2;	
					}
					if (I7_IT_RE_Trace) {
						print "Successful quant reps ", i, ": ";
						I7_IT_Debug_SearchNode(token, findt, true);
					}
				} else {
					!token-->RE_DATA2 = -1;
					if (mode_flags & ACCUM_MFLAG == false)
						I7_IT_RE_Fail_Subexpressions(token-->RE_DOWN);
					if (I7_IT_RE_Trace) {
						print "Failed quant reps ", i, ": ";
						I7_IT_Debug_SearchNode(token, findt, true);
					}
				}
				
			! Character classes
				
			NOTHING_RE_CC: ;
			ANYTHING_RE_CC: if (ch) outcome = true; ipos++;
			WHITESPACE_RE_CC:
				if (ch == 10 or 13 or 32 or 9) { outcome = true; ipos++; }
			NONWHITESPACE_RE_CC:
				if ((ch) && (ch ~= 10 or 13 or 32 or 9)) { outcome = true; ipos++; }
			PUNCTUATION_RE_CC:
				if (ch == '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}') { outcome = true; ipos++; }
			NONPUNCTUATION_RE_CC:
				if ((ch) && (ch ~= '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}')) { outcome = true; ipos++; }
			WORD_RE_CC:
				if ((ch) && (ch ~= 10 or 13 or 32 or 9
					or '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}')) { outcome = true; ipos++; }
			NONWORD_RE_CC:
				if (ch == 10 or 13 or 32 or 9
					or '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}') { outcome = true; ipos++; }
			DIGIT_RE_CC:
				if (ch == '0' or '1' or '2' or '3' or '4'
					or '5' or '6' or '7' or '8' or '9') { outcome = true; ipos++; }
			NONDIGIT_RE_CC:
				if ((ch) && (ch ~= '0' or '1' or '2' or '3' or '4'
					or '5' or '6' or '7' or '8' or '9')) { outcome = true; ipos++; }
			LCASE_RE_CC:
				if (I7_iscase(ch, 0)) { outcome = true; ipos++; }
			NONLCASE_RE_CC:
				if ((ch) && (I7_iscase(ch, 0) == false)) { outcome = true; ipos++; }
			UCASE_RE_CC:
				if (I7_iscase(ch, 1)) { outcome = true; ipos++; }
			NONUCASE_RE_CC:
				if ((ch) && (I7_iscase(ch, 1) == false)) { outcome = true; ipos++; }
			NEWLINE_RE_CC: if (ch == 10) { outcome = true; ipos++; }
			TAB_RE_CC: if (ch == 9) { outcome = true; ipos++; }
			RANGE_RE_CC:
				if (I7_IT_RE_Range(ch, findt,
					token-->RE_PAR1, token-->RE_PAR2, token-->RE_PAR3, mode_flags & CIS_MFLAG))
					{ outcome = true; ipos++; }
			
			! Substring matches
			
			LITERAL_RE_CC:
				rv = I7_IT_RE_Submatch(indt, ipos,
					findt, token-->RE_PAR1, token-->RE_PAR2, mode_flags & CIS_MFLAG);
				if (rv >= 0) { ipos = ipos + rv; outcome = true; }
			VARIABLE_RE_CC:
				i = token-->RE_PAR1;
				if ((RE_Subexpressions-->i)-->RE_DATA1 >= 0) {
					rv = I7_IT_RE_Submatch(indt, ipos,
						indt, (RE_Subexpressions-->i)-->RE_DATA1,
						(RE_Subexpressions-->i)-->RE_DATA2, mode_flags & CIS_MFLAG);
					if (rv >= 0) { ipos = ipos + rv; outcome = true; }
				}
				.NeverMatchIncompleteVar;
		}
		
		if (outcome == false) {
			if (I7_IT_RE_RewindCount++ >= 10000) {
				if (I7_IT_RE_RewindCount == 10001) {
					style bold; print "OVERFLOW^"; style roman;
				}
				return -1;
			}
			if (I7_IT_RE_Trace) {
				print "Rewind sought from failure at pos ", ipos, " with: ";
					I7_IT_Debug_SearchNode(token, findt, true);
			}
			if ((token-->RE_CCLASS == QUANTIFIER_RE_CC) &&
				(I7_IT_RE_Seek_Rewind(token-->RE_DOWN, findt, false, ito, false)))
				jump RewindFound;
			if (mode_flags & ACCUM_MFLAG == false) I7_IT_RE_Fail_Subexpressions(token);
			token = token-->RE_PREVIOUS;
			while (token ~= I6_NULL) {
				if (I7_IT_RE_Seek_Rewind(token, findt, true, ito, false)) {
					.RewindFound;
					ipos = token-->RE_DATA1;
					mode_flags = token-->RE_MODES;
					if (mode_flags & ACCUM_MFLAG == false)
						I7_IT_RE_Fail_Subexpressions(token, true);
					if (ipos == -1)
						I7_IT_Debug_Search(findt, true);
					if (I7_IT_RE_Trace) {
						print "^[", ifrom, ",", ito, "] rewinding to ", ipos, " at ";
						I7_IT_Debug_SearchNode(token, findt, true);
					}
					jump Rewind;
				}
				token = token-->RE_PREVIOUS;
			}
			if (I7_IT_RE_Trace)
				print "^Rewind impossible^";
			return -1;
		}

		token = token-->RE_NEXT;
	}
	return ipos - ifrom;
];

[ I7_IT_RE_Fail_Subexpressions token downwards;
	for (: token ~= I6_NULL: token = token-->RE_NEXT) {
		if (token-->RE_DOWN ~= I6_NULL) I7_IT_RE_Fail_Subexpressions(token-->RE_DOWN);
		if (token-->RE_CCLASS == SUBEXP_RE_CC) {
			token-->RE_DATA1 = -1;
			token-->RE_DATA2 = -1;
		}
		if (downwards) break;
	}
];

[ I7_IT_RE_Seek_Rewind token findt downwards ito report_only
	untried;
	for (: token ~= I6_NULL: token = token-->RE_NEXT) {
		if ((I7_IT_RE_Trace) && (report_only == false)) {
			print "Scan for rewind: ";
			I7_IT_Debug_SearchNode(token, findt, true);
		}
		if ((token-->RE_CCLASS == SUBEXP_RE_CC) &&
			(token-->RE_PAR2 == 1 or 2 or 4)) {
			if (downwards) rfalse;
			continue;
		}
		if (token-->RE_DOWN ~= I6_NULL) {
			if ((I7_IT_RE_Trace) && (report_only == false)) print "Descend^";
			if (I7_IT_RE_Seek_Rewind(token-->RE_DOWN, findt, false, ito, report_only)) rtrue;
		}
		untried = false;
		switch (token-->RE_CCLASS) {
			DISJUNCTION_RE_CC:
				if ((token-->RE_DATA2 >= 1) &&
					(token-->RE_DATA2 < token-->RE_PAR1) &&
					(token-->RE_CONSTRAINT < token-->RE_PAR1)) { ! Matched but earlier than the last
					if (report_only) rtrue;
					if (token-->RE_CONSTRAINT == -1)
						token-->RE_CONSTRAINT = 1;
					else
						(token-->RE_CONSTRAINT)++;
					untried = true;
				}
			QUANTIFIER_RE_CC:
				if (token-->RE_CONSTRAINT ~= -2) {
					if ((I7_IT_RE_Trace) && (report_only == false)) {
						print "Quant with cons not -2: ";
						I7_IT_Debug_SearchNode(token, findt, true);
					}
					if (token-->RE_DATA2 >= 0) {
						if (report_only) rtrue;
						token-->RE_CONSTRAINT = token-->RE_DATA2;
						untried = true;
					}
				}
		}
		if (untried) {
			if (I7_IT_RE_Trace) {
				print "Grounds for rewind at: ";
				I7_IT_Debug_SearchNode(token, findt, true);
			}
			I7_IT_RE_Parse_RE_Start_Fresh(token-->RE_NEXT);
			I7_IT_RE_Parse_RE_Start_Fresh(token-->RE_DOWN);
			rtrue;
		}
		if (downwards) rfalse;
	}
	rfalse;
];

[ I7_IT_RE_Parse_RE_Start_Fresh token;
	while (token ~= I6_NULL) {
		switch (token-->RE_CCLASS) {
			DISJUNCTION_RE_CC:
				token-->RE_CONSTRAINT = -1;
			QUANTIFIER_RE_CC:
				token-->RE_CONSTRAINT = -1;
		}
		if (token-->RE_DOWN) I7_IT_RE_Parse_RE_Start_Fresh(token-->RE_DOWN);
		token = token-->RE_NEXT;
	}
];

[ I7_IT_RE_Verify_Range findt rf rt
	i chm;
	for (i=rf: i<rt: i++) {
		chm = I7_Blk_Get(findt, i);
		if ((chm == '\') && (i+1<rt)) {
			chm = I7_Blk_Get(findt, ++i);
			if (((chm >= 'a') && (chm <= 'z')) ||
				((chm >= 'A') && (chm <= 'Z'))) {
				if (chm ~= 's' or 'S' or 'p' or 'P' or 'w' or 'W' or 'd'
					or 'D' or 'n' or 't' or 'l' or 'L' or 'u' or 'U')
					return "Invalid escape in {} range";
			}
		}
		if ((i+2<rt) && (I7_Blk_Get(findt, i+1) == '-')) {
			if (chm > I7_Blk_Get(findt, i+2)) return "Invalid {} range";
			i=i+2;
		}
	}
	rfalse;
];

[ I7_IT_RE_Range ch findt rf rt negate insens
	i chm upper crev;
	if (ch == 0) rfalse;
	if (negate == true) {
		if (I7_IT_RE_Range(ch, findt, rf, rt, false, insens)) rfalse;
		rtrue;
	}
	for (i=rf: i<rt: i++) {
		chm = I7_Blk_Get(findt, i);
		if ((chm == '\') && (i+1<rt)) {
			chm = I7_Blk_Get(findt, ++i);
			switch (chm) {
				's':
					if (ch == 10 or 13 or 32 or 9) rtrue;
				'S':
					if ((ch) && (ch ~= 10 or 13 or 32 or 9)) rtrue;
				'p':
					if (ch == '.' or ',' or '!' or '?'
						or '-' or '/' or '"' or ':' or ';'
						or '(' or ')' or '[' or ']' or '{' or '}') rtrue;
				'P':
					if ((ch) && (ch ~= '.' or ',' or '!' or '?'
						or '-' or '/' or '"' or ':' or ';'
						or '(' or ')' or '[' or ']' or '{' or '}')) rtrue;
				'w':
					if ((ch) && (ch ~= 10 or 13 or 32 or 9
						or '.' or ',' or '!' or '?'
						or '-' or '/' or '"' or ':' or ';'
						or '(' or ')' or '[' or ']' or '{' or '}')) rtrue;
				'W':
					if (ch == 10 or 13 or 32 or 9
						or '.' or ',' or '!' or '?'
						or '-' or '/' or '"' or ':' or ';'
						or '(' or ')' or '[' or ']' or '{' or '}') rtrue;
				'd':
					if (ch == '0' or '1' or '2' or '3' or '4'
						or '5' or '6' or '7' or '8' or '9') rtrue;
				'D':
					if ((ch) && (ch ~= '0' or '1' or '2' or '3' or '4'
						or '5' or '6' or '7' or '8' or '9')) rtrue;
				'l': if (I7_iscase(ch, 0)) rtrue;
				'L': if (I7_iscase(ch, 0) == false) rtrue;
				'u': if (I7_iscase(ch, 1)) rtrue;
				'U': if (I7_iscase(ch, 1) == false) rtrue;
				'n': if (ch == 10) rtrue;
				't': if (ch == 9) rtrue;
			}
		}
		if ((i+2<rt) && (I7_Blk_Get(findt, i+1) == '-')) {
			upper = I7_Blk_Get(findt, i+2);
			if ((ch >= chm) && (ch <= upper)) rtrue;
			if (insens) {
				crev = I7_IT_RevCase(ch);
				if ((crev >= chm) && (crev <= upper)) rtrue;
			}
			i=i+2;
		} else {
			if (chm == ch) rtrue;
			if ((insens) && (chm == I7_IT_RevCase(ch))) rtrue;
		}
	}
	rfalse;
];

[ I7_IT_RE_Submatch indt ipos mindt mfrom mto insens
	i ch;
	if (mfrom < 0) return 0;
	if (insens)
		for (i=mfrom:i<mto:i++) {
			ch = I7_Blk_Get(mindt, i);
			if (I7_Blk_Get(indt, ipos++) ~= ch or I7_IT_RevCase(ch))
				return -1;
		}
	else
		for (i=mfrom:i<mto:i++)
			if (I7_Blk_Get(indt, ipos++) ~= I7_Blk_Get(mindt, i))
				return -1;
	return mto-mfrom;
];

#IFDEF TARGET_ZCODE;
[ I7_IT_RevCase ch;
	if (ch<'A') return ch;
	if ((ch >= 'a') && (ch <= 'z')) return ch-'a'+'A';
	if ((ch >= 'A') && (ch <= 'Z')) return ch-'A'+'a';
	if (ch<128) return ch;
	if ((ch >= 155) && (ch <= 157)) return ch+3; ! a, o, u umlaut in ZSCII
	if ((ch >= 158) && (ch <= 160)) return ch-3; ! A, O, U umlaut
	if ((ch >= 164) && (ch <= 165)) return ch+3; ! e, i umlaut
	if ((ch >= 167) && (ch <= 168)) return ch-3; ! E, I umlaut
	if ((ch >= 169) && (ch <= 174)) return ch+6; ! a, e, i, o, u, y acute
	if ((ch >= 175) && (ch <= 180)) return ch-6; ! A, E, I, O, U, Y acute
	if ((ch >= 181) && (ch <= 185)) return ch+5; ! a, e, i, o, u grave
	if ((ch >= 186) && (ch <= 190)) return ch-5; ! A, E, I, O, U grave
	if ((ch >= 191) && (ch <= 195)) return ch+5; ! a, e, i, o, u circumflex
	if ((ch >= 196) && (ch <= 200)) return ch-5; ! A, E, I, O, U circumflex
	if (ch == 201) return 202; ! a circle
	if (ch == 202) return 201; ! A circle
	if (ch == 203) return 204; ! o slash
	if (ch == 204) return 203; ! O slash
	if ((ch >= 205) && (ch <= 207)) return ch+3; ! a, n, o tilde
	if ((ch >= 208) && (ch <= 210)) return ch-3; ! A, N, O tilde
	if (ch == 211) return 212; ! ae ligature
	if (ch == 212) return 211; ! AE ligature
	if (ch == 213) return 214; ! c cedilla
	if (ch == 214) return 213; ! C cedilla
	if (ch == 215 or 216) return ch+2; ! thorn, eth
	if (ch == 217 or 218) return ch-2; ! Thorn, Eth
	if (ch == 220) return 221; ! oe ligature
	if (ch == 221) return 220; ! OE ligature
	return ch;
];
#IFNOT;
[ I7_IT_RevCase ch;
	if (ch<'A') return ch;
	if ((ch >= 'a') && (ch <= 'z')) return ch-'a'+'A';
	if ((ch >= 'A') && (ch <= 'Z')) return ch-'A'+'a';
	if (ch<128) return ch;
	if (I7_iscase(ch, 0)) return I7_tocase(ch, 1);
	if (I7_iscase(ch, 1)) return I7_tocase(ch, 0);
	return ch;
];
#ENDIF;

[ I7_IT_Replace_RE blobtype indt findt rindt insens exactly
	cindt csize ilen i cl mpos cpos ch chm;
	ilen = I7_IT_Character_Length(indt);

	I7_IT_RE_Err = 0;
	switch (blobtype) {
		REGEXP_BLOB: i = I7_IT_REGEXP_Compile(findt, exactly);
		CHR_BLOB: i = I7_IT_CHR_Compile(findt);
		default: "*** bad blobtype ***";
	}
	
	if ((i<0) || (i>RE_MAX_PACKETS)) {
		I7_IT_RE_Err = i;
		print "*** Regular expression error: ", (string) I7_IT_RE_Err, " ***^";
		return 0;
	}

	if (I7_IT_RE_Trace) {
		I7_IT_Debug_Search(findt);
		print "(compiled to ", i, " packets)^";
	}
	
	if (blobtype == REGEXP_BLOB) I7_IT_Empty_Match_Vars();

	mpos = 0; chm = 0; cpos = 0;
	while (I7_IT_RE_Parse_RE(findt, indt, mpos, insens) >= 0) {
		chm++;
		
		if (I7_IT_RE_Trace) {
			print "^*** Match ", chm, " found (", RE_PACKET_space-->RE_DATA1, ",",
				RE_PACKET_space-->RE_DATA2, "): ";
			if (RE_PACKET_space-->RE_DATA1 == RE_PACKET_space-->RE_DATA2) {
				print "<empty>";
			}
			for (i=RE_PACKET_space-->RE_DATA1:i<RE_PACKET_space-->RE_DATA2:i++) {
				print (char) I7_Blk_Get(indt, i);
			}
			print " ***^";
		}
		
		if (rindt == 0) break; ! Accept only one match, replace nothing
		
		if (rindt ~= 0 or 1) {
			if (chm == 1) {
				cindt = I7_Blk_Create(INDEXED_TEXT_TY);
				csize = I7_Blk_Get_Extent(cindt);
			}

			for (i=cpos:i<RE_PACKET_space-->RE_DATA1:i++) {
				ch = I7_Blk_Get(indt, i);
				if (cl+1 >= csize) {
					if (I7_Blk_Change_Extent(cindt, 2*cl, 7) == false) break;
					csize = I7_Blk_Get_Extent(cindt);
				}
				I7_Blk_Put(cindt, cl++, ch);
			}
			I7_Blk_Put(cindt, cl, 0);
	
			I7_IT_Concatenate(cindt, rindt, blobtype, indt);
			csize = I7_Blk_Get_Extent(cindt);
			cl = I7_IT_Character_Length(cindt);			
		}

		mpos = RE_PACKET_space-->RE_DATA2; cpos = mpos;
		if (RE_PACKET_space-->RE_DATA1 == RE_PACKET_space-->RE_DATA2)
			mpos++;

		if (I7_IT_RE_Trace) {
			if (chm == 100) {
				print "(Stopping after 100 matches.)^"; break;
			}
		}
	}
	if (chm > 0) {
		if (rindt ~= 0 or 1) {
			for (i=cpos:i<ilen:i++) {
				ch = I7_Blk_Get(indt, i);
				if (cl+1 >= csize) {
					if (I7_Blk_Change_Extent(cindt, 2*cl, 8) == false) break;
					csize = I7_Blk_Get_Extent(cindt);
				}
				I7_Blk_Put(cindt, cl++, ch);
			}
		}
		
		if (blobtype == REGEXP_BLOB) {
			I7_IT_Create_Match_Vars(indt);
			if (I7_IT_RE_Trace)
				I7_IT_RE_Debug_Match_Vars(indt);
		}

		if (rindt ~= 0 or 1) {
			I7_Blk_Put(cindt, cl, 0);
			I7_Blk_Deep_Copy(indt, cindt);	
			I7_Blk_Free(cindt);
		}
	}
	return chm;
];

[ I7_IT_Replace_Text blobtype indt findt rindt
	cindt csize ilen flen i cl mpos ch chm whitespace punctuation;
	
	if (blobtype == REGEXP_BLOB or CHR_BLOB) 
		return I7_IT_Replace_RE(blobtype, indt, findt, rindt);
	
	ilen = I7_IT_Character_Length(indt);
	flen = I7_IT_Character_Length(findt);
	cindt = I7_Blk_Create(INDEXED_TEXT_TY);
	csize = I7_Blk_Get_Extent(cindt);
	mpos = 0;

	whitespace = true; punctuation = false;
	for (i=0:i<=ilen:i++) {
		ch = I7_Blk_Get(indt, i);
		.MoreMatching;
		chm = I7_Blk_Get(findt, mpos++);
		if (mpos == 1) {
			switch (blobtype) {
				WORD_BLOB:
					if ((whitespace == false) && (punctuation == false)) chm = -1;
			}
		}
		whitespace = false;
		if (ch == 10 or 13 or 32 or 9) whitespace = true;
		punctuation = false;
		if (ch == '.' or ',' or '!' or '?'
			or '-' or '/' or '"' or ':' or ';'
			or '(' or ')' or '[' or ']' or '{' or '}') {
			if (blobtype == WORD_BLOB) chm = -1;
			punctuation = true;
		}
		if (ch == chm) {
			!	print ch, " matches^";
			if (mpos == flen) {
				if (i == ilen) chm = 0;
				else chm = I7_Blk_Get(indt, i+1);
				!	print chm, " is next^";
				if ((blobtype == CHR_BLOB) ||
					(chm == 0 or 10 or 13 or 32 or 9) ||
					(chm == '.' or ',' or '!' or '?'
						or '-' or '/' or '"' or ':' or ';'
						or '(' or ')' or '[' or ']' or '{' or '}')) {
					!	print "Success!^";
					mpos = 0;
					cl = cl - (flen-1);
					I7_Blk_Put(cindt, cl, 0);
					I7_IT_Concatenate(cindt, rindt, CHR_BLOB);
					csize = I7_Blk_Get_Extent(cindt);
					cl = I7_IT_Character_Length(cindt);
					continue;
				}
			}
		} else {
			mpos = 0;
		}
		if (cl+1 >= csize) {
			if (I7_Blk_Change_Extent(cindt, 2*cl, 9) == false) break;
			csize = I7_Blk_Get_Extent(cindt);
		}
		I7_Blk_Put(cindt, cl++, ch);
	}
	I7_Blk_Deep_Copy(indt, cindt);	
	I7_Blk_Free(cindt);
];

[ I7_IT_Get_Blob cindt indt i blobtype;
	if ((indt==0) || (I7_Blk_Type(indt) ~= INDEXED_TEXT_TY)) return;
	if (blobtype == CHR_BLOB) return I7_IT_Character(cindt, indt, i);
	I7_IT_Blob_Length(indt, blobtype, cindt, i);
	return cindt;
];

[ I7_IT_Character_Length indt ch i dsize;
	if ((indt==0) || (I7_Blk_Type(indt) ~= INDEXED_TEXT_TY)) return 0;
	dsize = I7_Blk_Get_Extent(indt);
	for (i=0:i<dsize:i++) {
		ch = I7_Blk_Get(indt, i);
		if (ch == 0) return i;
	}
	return dsize;
];

[ I7_IT_Character cindt indt i ch;
	if ((indt==0) || (I7_Blk_Type(indt) ~= INDEXED_TEXT_TY)) return;
	if ((i<=0) || (i>I7_IT_Character_Length(indt))) ch = 0;
	else ch = I7_Blk_Get(indt, i-1);
	I7_Blk_Put(cindt, 0, ch);
	I7_Blk_Put(cindt, 1, 0);
	return cindt;
];

[ I7_IT_Of_Case indt case i ch len;
	if ((indt==0) || (I7_Blk_Type(indt) ~= INDEXED_TEXT_TY)) rfalse;
	len = I7_IT_Character_Length(indt);
	for (i=0:i<len:i++) {
		ch = I7_Blk_Get(indt, i);
		if ((ch) && (I7_iscase(ch, case) == false)) rfalse;
	}
	rtrue;
];

[ I7_IT_To_Case cindt indt case i ch len bnd;
	if ((indt==0) || (I7_Blk_Type(indt) ~= INDEXED_TEXT_TY)) return;
	len = I7_IT_Character_Length(indt);
	if (I7_Blk_Change_Extent(cindt, len+1, 11) == false) return cindt;
	bnd = 1;
	for (i=0:i<len:i++) {
		ch = I7_Blk_Get(indt, i);
		if (case < 2) {
			I7_Blk_Put(cindt, i, I7_tocase(ch, case));
		} else {
			I7_Blk_Put(cindt, i, I7_tocase(ch, bnd));
			if (case == 2) {
				bnd = 0;
				if (ch == 0 or 10 or 13 or 32 or 9
					or '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}') bnd = 1;
			}
			if (case == 3) {
				if (ch ~= 0 or 10 or 13 or 32 or 9) {
					if (bnd == 1) bnd = 0;
					else {
						if (ch == '.' or '!' or '?') bnd = 1;
					}
				}
			}
		}
	}
	I7_Blk_Put(cindt, len, 0);
	return cindt;
];

[ I7_IT_Concatenate indt_to indt_from blobtype indt_ref
	pos len ch i tosize x y case;
	if ((indt_to==0) || (I7_Blk_Type(indt_to) ~= INDEXED_TEXT_TY)) rfalse;
	if ((indt_from==0) || (I7_Blk_Type(indt_from) ~= INDEXED_TEXT_TY)) return indt_to;
	if (blobtype == CHR_BLOB) {
		pos = I7_IT_Character_Length(indt_to);
		len = I7_IT_Character_Length(indt_from);
		if (I7_Blk_Change_Extent(indt_to, pos+len+1, 10) == false) return indt_to;
		for (i=0:i<len:i++) {
			ch = I7_Blk_Get(indt_from, i);
			I7_Blk_Put(indt_to, i+pos, ch);
		}
		I7_Blk_Put(indt_to, len+pos, 0);
	} else {
		pos = I7_IT_Character_Length(indt_to);
		tosize = I7_Blk_Get_Extent(indt_to);
		len = I7_IT_Character_Length(indt_from);
		for (i=0:i<len:i++) {
			ch = I7_Blk_Get(indt_from, i);
			if ((ch == '\') && (i < len-1)) {
				ch = I7_Blk_Get(indt_from, ++i);
				if (ch == 'n') ch = 10;
				if (ch == 't') ch = 9;
				case = -1;
				if (ch == 'l') case = 0;
				if (ch == 'u') case = 1;
				if (case >= 0) ch = I7_Blk_Get(indt_from, ++i);
				if ((ch >= '0') && (ch <= '9')) {
					ch = ch - '0';
					if (ch < RE_Subexpressions-->10) {
						x = (RE_Subexpressions-->ch)-->RE_DATA1;
						y = (RE_Subexpressions-->ch)-->RE_DATA2;
						if (x >= 0) {
							for (:x<y:x++) {
								ch = I7_Blk_Get(indt_ref, x);
								if (pos+1 >= tosize) {
									if (I7_Blk_Change_Extent(indt_to, 2*tosize, 11) == false) break;
									tosize = I7_Blk_Get_Extent(indt_to);
								}
								if (case >= 0)
									I7_Blk_Put(indt_to, pos++, I7_tocase(ch, case));
								else
									I7_Blk_Put(indt_to, pos++, ch);
							}
						}
					}
					continue;
				}
				
			}
			if (pos+1 >= tosize) {
				if (I7_Blk_Change_Extent(indt_to, 2*tosize, 12) == false) break;
				tosize = I7_Blk_Get_Extent(indt_to);
			}
			I7_Blk_Put(indt_to, pos++, ch);
		}
		I7_Blk_Put(indt_to, pos, 0);
	}
	return indt_to;
];

[ I7_IT_SetPlayersCommand indt_from i len at;
	len = I7_IT_Character_Length(indt_from);
	if (len > 118) len = 118;
#ifdef TARGET_ZCODE;
	buffer->1 = len; at = 2;
#ifnot;
	buffer-->0 = len; at = 4;
#endif;
!print "Len is ", len, "^";
	for (i=0:i<len:i++) {
		buffer->(i+at) = I7_Blk_Get(indt_from, i);
		!print (char) buffer->(i+at);
	}
	for (:at+i<120:i++) buffer->(at+i) = ' ';
	Tokenise__(buffer, parse);
	I7_command = 100 + WordCount();
];

#IFNOT; ! IFDEF I7_HEAP_SIZE

[ I7_INDEXED_TEXT_TY_Say indt; ];
[ I7_IT_SetPlayersCommand indt_from; ];
[ I7_INDEXED_TEXT_TY_Create; ];
[ I7_INDEXED_TEXT_TY_Cast a b c; ];

#ENDIF; ! IFDEF I7_HEAP_SIZE

! End of IndexedText.i6
